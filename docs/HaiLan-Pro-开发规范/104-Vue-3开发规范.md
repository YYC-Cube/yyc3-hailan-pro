---
@file: 104-Vue-3开发规范.md
@description: HaiLan Pro Vue 3框架开发规范，包含Composition API、响应式、组件通信等
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-开发规范],[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 104 Vue 3开发规范

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-开发规范-Vue 3开发规范相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范Vue 3开发规范相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. Vue 3开发规范

#### 3.1 Composition API规范

```vue
<!-- 推荐：使用<script setup>语法糖 -->
<template>
  <div class="user-profile">
    <h1>{{ user.nickname }}</h1>
    <p v-if="isLoggedIn">欢迎回来！</p>
    <button @click="handleLogout">退出登录</button>
  </div>
</template>

<script setup lang="ts">
// 导入
import { ref, computed, onMounted, watch } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { useUserStore } from '@/stores/user';

// Props定义 - 使用TypeScript接口
interface Props {
  userId: string;
  showActions?: boolean;
  theme?: 'light' | 'dark';
}
const props = withDefaults(defineProps<Props>(), {
  showActions: true,
  theme: 'light'
});

// Emits定义 - 使用TypeScript类型
interface Emits {
  (e: 'update', user: UserInfo): void;
  (e: 'delete', userId: string): void;
  (e: 'change', value: string, index: number): void;
}
const emit = defineEmits<Emits>();

// 响应式状态
const userStore = useUserStore();
const route = useRoute();
const router = useRouter();
const loading = ref(false);
const errorMessage = ref('');

// 计算属性
const user = computed(() => userStore.currentUser);
const isLoggedIn = computed(() => !!user.value);
const displayName = computed(() => user.value?.nickname || '访客');

// 方法
async function handleLogout() {
  loading.value = true;
  try {
    await userStore.logout();
    router.push('/login');
  } catch (error) {
    errorMessage.value = '退出登录失败';
  } finally {
    loading.value = false;
  }
}

// 侦听器
watch(() => props.userId, async (newId) => {
  if (newId) {
    await userStore.fetchUser(newId);
  }
}, { immediate: true });

// 生命周期
onMounted(() => {
  console.log('组件已挂载');
});

// 暴露给父组件的方法（通过ref访问）
defineExpose({
  refresh: () => userStore.fetchUser(props.userId),
  isLoading: () => loading.value
});
</script>

<style scoped lang="scss">
.user-profile {
  padding: 20px;
}
</style>
```

#### 3.2 响应式数据规范

```typescript
// ref - 用于基本类型和需要响应式的对象
const count = ref(0);
const user = ref<UserInfo | null>(null);

// 修改ref的值
count.value++;
user.value = { id: '1', nickname: '张三' };

// reactive - 用于对象，保持响应性
const state = reactive({
  count: 0,
  user: null as UserInfo | null,
  loading: false
});

// 修改reactive的值
state.count++;
state.user = { id: '1', nickname: '张三' };

// computed - 计算属性
const doubleCount = computed(() => count.value * 2);
const isLoggedIn = computed(() => !!state.user);

// 可写的计算属性
const fullName = computed({
  get: () => `${state.firstName} ${state.lastName}`,
  set: (value) => {
    [state.firstName, state.lastName] = value.split(' ');
  }
});

// watch - 侦听器
// 侦听单个源
watch(count, (newValue, oldValue) => {
  console.log(`count changed from ${oldValue} to ${newValue}`);
});

// 侦听多个源
watch([count, user], ([newCount, newUser]) => {
  console.log('count or user changed');
});

// 侦听对象深层属性
watch(
  () => state.user?.nickname,
  (newNickname) => {
    console.log('nickname changed:', newNickname);
  }
);

// 带配置的侦听
watch(
  () => state.user,
  (newUser) => {
    console.log('user changed');
  },
  { deep: true, immediate: true }
);

// watchEffect - 自动追踪依赖
watchEffect(() => {
  console.log('count is:', count.value);
});
```

#### 3.3 组件通信规范

```typescript
// ========== Props (父传子) ==========
// 子组件定义
interface ChildProps {
  title: string;
  count?: number;
  items: string[];
  config?: {
    showIcon?: boolean;
    color?: string;
  };
}
const props = withDefaults(defineProps<ChildProps>(), {
  count: 0,
  config: () => ({ showIcon: true, color: '#0056b3' })
});

// 父组件使用
<ChildComponent
  title="标题"
  :count="5"
  :items="['a', 'b', 'c']"
  :config="{ showIcon: false }"
/>

// ========== Emits (子传父) ==========
// 子组件定义
interface ChildEmits {
  (e: 'update', value: string): void;
  (e: 'delete', id: string): void;
  (e: 'submit', data: FormData): void;
}
const emit = defineEmits<ChildEmits>();

function handleSubmit() {
  emit('submit', formData);
}

// 父组件监听
<ChildComponent @submit="handleChildSubmit" />

// ========== Provide/Inject (跨层级) ==========
// 祖先组件
import { provide, readonly, ref } from 'vue';

const theme = ref('light');
const updateTheme = (newTheme: string) => {
  theme.value = newTheme;
};

// 提供只读数据
provide('theme', readonly(theme));
// 提供修改方法
provide('updateTheme', updateTheme);

// 后代组件
import { inject } from 'vue';

const theme = inject<Ref<string>>('theme');
const updateTheme = inject<(theme: string) => void>('updateTheme');

// ========== v-model (双向绑定) ==========
// 子组件定义
interface Props {
  modelValue: string;
}
interface Emits {
  (e: 'update:modelValue', value: string): void;
}
const props = defineProps<Props>();
const emit = defineEmits<Emits>();

function handleInput(event: Event) {
  emit('update:modelValue', (event.target as HTMLInputElement).value);
}

// 父组件使用
<ChildComponent v-model="inputValue" />

// 多个v-model
interface MultiProps {
  modelValue: string;
  title: string;
}
interface MultiEmits {
  (e: 'update:modelValue', value: string): void;
  (e 'update:title', value: string): void;
}
<ChildComponent
  v-model="inputValue"
  v-model:title="titleValue"
/>

// ========== Slots (插槽) ==========
// 子组件
<template>
  <div class="card">
    <header>
      <slot name="header" />
    </header>
    <main>
      <slot /> <!-- 默认插槽 -->
    </main>
    <footer>
      <slot name="footer" />
    </footer>
  </div>
</template>

// 父组件
<Card>
  <template #header>
    <h1>卡片标题</h1>
  </template>

  <p>卡片内容</p>

  <template #footer>
    <button>操作按钮</button>
  </template>
</Card>

// 作用域插槽
<template>
  <slot name="item" :item="currentItem" :index="currentIndex" />
</template>

<UserList>
  <template #item="{ item, index }">
    <span>{{ index }}: {{ item.name }}</span>
  </template>
</UserList>
```

#### 3.4 组合式函数(Composables)规范

```typescript
// composables/useAuth.ts
import { ref, computed } from 'vue';
import { useUserStore } from '@/stores/user';

export function useAuth() {
  const userStore = useUserStore();
  const loading = ref(false);
  const error = ref<string | null>(null);

  const isAuthenticated = computed(() => !!userStore.currentUser);
  const isAdmin = computed(() => userStore.currentUser?.role === 'admin');

  async function login(email: string, password: string) {
    loading.value = true;
    error.value = null;

    try {
      await userStore.login({ email, password });
      return true;
    } catch (e: any) {
      error.value = e.message;
      return false;
    } finally {
      loading.value = false;
    }
  }

  async function logout() {
    loading.value = true;
    try {
      await userStore.logout();
    } finally {
      loading.value = false;
    }
  }

  return {
    // 状态
    loading,
    error,
    // 计算属性
    isAuthenticated,
    isAdmin,
    // 方法
    login,
    logout
  };
}

// 使用
<script setup lang="ts">
import { useAuth } from '@/composables/useAuth';

const { isAuthenticated, login, logout, loading } = useAuth();

async function handleLogin() {
  const success = await login('user@example.com', 'password');
  if (success) {
    console.log('登录成功');
  }
}
</script>

// composables/useLocalStorage.ts
import { ref, watch } from 'vue';

export function useLocalStorage<T>(key: string, defaultValue: T) {
  const storedValue = localStorage.getItem(key);
  const value = ref<T>(storedValue ? JSON.parse(storedValue) : defaultValue);

  watch(value, (newValue) => {
    localStorage.setItem(key, JSON.stringify(newValue));
  }, { deep: true });

  return value;
}

// composables/useDebounce.ts
import { ref, watch } from 'vue';

export function useDebounce<T>(value: Ref<T>, delay: number) {
  const debouncedValue = ref(value.value) as Ref<T>;
  let timeout: ReturnType<typeof setTimeout> | null = null;

  watch(value, (newValue) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      debouncedValue.value = newValue;
    }, delay);
  });

  return debouncedValue;
}
```

#### 3.5 指令规范

```typescript
// directives/permission.ts
import type { Directive, DirectiveBinding } from 'vue';

interface PermissionBinding {
  permission: string;
  fallback?: string;
}

export const permission: Directive = {
  mounted(el: HTMLElement, binding: DirectiveBinding<PermissionBinding>) {
    const { permission, fallback } = binding.value;
    const userStore = useUserStore();

    const hasPermission = userStore.permissions?.includes(permission);

    if (!hasPermission) {
      if (fallback) {
        el.textContent = fallback;
      } else {
        el.parentNode?.removeChild(el);
      }
    }
  }
};

// 使用
<button v-permission="{ permission: 'user:delete' }">删除用户</button>

// directives/loading.ts
export const loading: Directive = {
  mounted(el, binding) {
    const isLoading = binding.value;
    if (isLoading) {
      el.classList.add('is-loading');
      el.disabled = true;
    }
  },
  updated(el, binding) {
    const isLoading = binding.value;
    if (isLoading) {
      el.classList.add('is-loading');
      el.disabled = true;
    } else {
      el.classList.remove('is-loading');
      el.disabled = false;
    }
  }
};

// directives/click-outside.ts
export const clickOutside: Directive = {
  mounted(el, binding) {
    el.clickOutsideEvent = function (event: Event) {
      if (!(el === event.target || el.contains(event.target))) {
        binding.value(event);
      }
    };
    document.body.addEventListener('click', el.clickOutsideEvent);
  },
  unmounted(el) {
    document.body.removeEventListener('click', el.clickOutsideEvent);
  }
};

// 使用
<div v-click-outside="handleClickOutside">
  下拉菜单内容
</div>
```

#### 3.6 过渡与动画

```vue
<template>
  <!-- 单个元素过渡 -->
  <transition name="fade">
    <div v-if="show" class="box">内容</div>
  </transition>

  <!-- 多个元素过渡 -->
  <transition name="slide" mode="out-in">
    <component :is="activeComponent" />
  </transition>

  <!-- 列表过渡 -->
  <transition-group name="list" tag="ul">
    <li v-for="item in items" :key="item.id">
      {{ item.name }}
    </li>
  </transition-group>
</template>

<style scoped>
/* fade过渡 */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

/* slide过渡 */
.slide-enter-active,
.slide-leave-active {
  transition: all 0.3s ease;
}

.slide-enter-from {
  transform: translateX(-100%);
}

.slide-leave-to {
  transform: translateX(100%);
}

/* 列表过渡 */
.list-enter-active,
.list-leave-active {
  transition: all 0.5s ease;
}

.list-enter-from,
.list-leave-to {
  opacity: 0;
  transform: translateX(30px);
}

.list-move {
  transition: transform 0.5s ease;
}
</style>

<!-- JavaScript钩子 -->
<transition
  @before-enter="beforeEnter"
  @enter="enter"
  @after-enter="afterEnter"
  @enter-cancelled="enterCancelled"
  @before-leave="beforeLeave"
  @leave="leave"
  @after-leave="afterLeave"
  @leave-cancelled="leaveCancelled"
>
  <div v-if="show">内容</div>
</transition>

<script setup lang="ts">
function beforeEnter(el: Element) {
  (el as any).style.opacity = 0;
}

function enter(el: Element, done: () => void) {
  const element = el as HTMLElement;
  element.offsetHeight; // 触发重绘
  element.style.transition = 'opacity 0.5s';
  element.style.opacity = '1';
  setTimeout(done, 500);
}
</script>
```

#### 3.7 性能优化规范

```vue
<template>
  <!-- v-once - 只渲染一次 -->
  <h1 v-once>{{ staticTitle }}</h1>

  <!-- v-memo - 条件记忆 -->
  <div v-memo="[valueA, valueB]">
    <!-- 只有当valueA或valueB变化时才重新渲染 -->
    <span>{{ valueA }} - {{ valueB }}</span>
  </div>

  <!-- 异步组件 -->
  <Suspense>
    <template #default>
      <AsyncComponent />
    </template>
    <template #fallback>
      <LoadingSpinner />
    </template>
  </Suspense>

  <!-- 虚拟滚动（大列表） -->
  <RecycleScroller
    :items="largeList"
    :item-size="50"
    key-field="id"
    v-slot="{ item }"
  >
    <div>{{ item.name }}</div>
  </RecycleScroller>
</template>

<script setup lang="ts">
// 异步组件定义
import { defineAsyncComponent } from 'vue';

const AsyncComponent = defineAsyncComponent({
  loader: () => import('./HeavyComponent.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorDisplay,
  delay: 200,
  timeout: 3000
});

// 计算属性缓存
const expensiveValue = computed(() => {
  // 只在依赖变化时重新计算
  return heavyComputation(state.input);
});

// shallowRef/shallowReactive - 大数据优化
const largeData = shallowRef<LargeData>({ /* ... */ });

// watchEffect - 副作用清理
watchEffect((onCleanup) => {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);

  onCleanup(() => {
    clearInterval(timer);
  });
});
</script>
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
