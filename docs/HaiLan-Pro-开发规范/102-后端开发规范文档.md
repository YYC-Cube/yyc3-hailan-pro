---
file: 102-后端开发规范文档.md
description: HaiLan Pro 后端开发规范，包含代码风格、命名规范、模块规范、性能优化等
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-开发规范,[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 102 后端开发规范文档

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-开发规范-后端开发规范文档相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范后端开发规范文档相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 后端开发规范

#### 3.1 开发环境配置

```bash
# Node.js版本要求
node >= 20.0.0
npm >= 10.0.0 或 pnpm >= 8.0.0

# 全局安装NestJS CLI
npm install -g @nestjs/cli

# 创建新项目
nest new project-name

# 开发环境启动
pnpm run start:dev      # 开发模式，热重载
pnpm run start:debug    # 调试模式
pnpm run start:prod     # 生产模式
```

**环境变量配置**

```bash
# .env.development
NODE_ENV=development
PORT=3000
DATABASE_URL="postgresql://user:password@localhost:5432/hailan_dev"
REDIS_URL="redis://localhost:6379"
JWT_SECRET="your-dev-secret"
API_PREFIX=/api/v1

# .env.production
NODE_ENV=production
PORT=3000
DATABASE_URL="postgresql://user:password@prod-db:5432/hailan_prod"
REDIS_URL="redis://prod-redis:6379"
JWT_SECRET="${JWT_SECRET}" # 从环境变量读取
API_PREFIX=/api/v1
```

#### 3.2 项目目录结构

```
src/
├── modules/           # 业务模块
│   ├── user/          # 用户模块
│   │   ├── dto/       # 数据传输对象
│   │   ├── entities/  # 实体定义
│   │   ├── guards/    # 守卫
│   │   ├── controllers/ # 控制器
│   │   ├── services/  # 服务
│   │   ├── repositories/ # 数据访问层
│   │   └── user.module.ts
│   ├── product/       # 商品模块
│   ├── order/         # 订单模块
│   ├── ai/            # AI模块
│   └── iot/           # IoT设备模块
├── common/            # 公共模块
│   ├── decorators/    # 装饰器
│   ├── filters/       # 异常过滤器
│   ├── interceptors/  # 拦截器
│   ├── pipes/         # 管道
│   ├── guards/        # 守卫
│   ├── dto/           # 公共DTO
│   └── interfaces/    # 公共接口
├── config/            # 配置文件
│   ├── app.config.ts
│   ├── database.config.ts
│   └── redis.config.ts
├── database/          # 数据库相关
│   ├── migrations/    # 迁移文件
│   └── seeds/         # 种子数据
├── middleware/        # 中间件
├── utils/             # 工具函数
│   ├── crypto.ts      # 加密工具
│   ├── validator.ts   # 验证工具
│   └── logger.ts      # 日志工具
├── main.ts            # 应用入口
└── app.module.ts      # 根模块
```

#### 3.3 命名规范

```typescript
// 文件命名：kebab-case
user.controller.ts
user.service.ts
create-user.dto.ts
user.entity.ts

// 类命名：PascalCase
export class UserController { }
export class UserService { }
export class CreateUserDto { }
export class User { }

// 接口/类型命名：PascalCase，I前缀可选
export interface IUserRepository { }
export type UserId = string;

// 函数/变量命名：camelCase
const userRepository = new UserRepository();
async function findUserById(id: string) { }

// 常量命名：UPPER_SNAKE_CASE
const MAX_RETRY_COUNT = 3;
const DEFAULT_PAGE_SIZE = 20;

// 私有方法：以下划线前缀
private _validateUser(user: User) { }

// 装饰器命名：camelCase，无前缀
export const RequirePermissions = createParamDecorator(...)
export const CurrentUser = createParamDecorator(...)
```

#### 3.4 模块开发规范

```typescript
// user/user.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { UserRepository } from './repositories/user.repository';
import { User } from './entities/user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UsersController],
  providers: [
    UsersService,
    UserRepository,
  ],
  exports: [UsersService, UserRepository],
})
export class UserModule { }
```

#### 3.5 控制器规范

```typescript
// user/users.controller.ts
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { JwtAuthGuard } from '@/common/guards/jwt-auth.guard';
import { PermissionsGuard } from '@/common/guards/permissions.guard';
import { RequirePermissions } from '@/common/decorators/permissions.decorator';
import { TransformInterceptor } from '@/common/interceptors/transform.interceptor';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { QueryUsersDto } from './dto/query-users.dto';

@Controller('users')
@UseGuards(JwtAuthGuard, PermissionsGuard)
@UseInterceptors(TransformInterceptor)
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  /**
   * 创建用户
   * POST /api/v1/users
   */
  @Post()
  @RequirePermissions('user:create')
  async create(@Body() createUserDto: CreateUserDto) {
    const user = await this.usersService.create(createUserDto);
    return { data: user };
  }

  /**
   * 获取用户列表
   * GET /api/v1/users
   */
  @Get()
  @RequirePermissions('user:read')
  async findAll(@Query() query: QueryUsersDto) {
    const { users, total } = await this.usersService.findAll(query);
    return {
      data: users,
      meta: {
        total,
        page: query.page,
        pageSize: query.pageSize,
      },
    };
  }

  /**
   * 获取用户详情
   * GET /api/v1/users/:id
   */
  @Get(':id')
  @RequirePermissions('user:read')
  async findOne(@Param('id') id: string) {
    const user = await this.usersService.findOne(id);
    return { data: user };
  }

  /**
   * 更新用户
   * PUT /api/v1/users/:id
   */
  @Put(':id')
  @RequirePermissions('user:update')
  async update(
    @Param('id') id: string,
    @Body() updateUserDto: UpdateUserDto,
  ) {
    const user = await this.usersService.update(id, updateUserDto);
    return { data: user };
  }

  /**
   * 删除用户
   * DELETE /api/v1/users/:id
   */
  @Delete(':id')
  @RequirePermissions('user:delete')
  async remove(@Param('id') id: string) {
    await this.usersService.remove(id);
    return { message: 'User deleted successfully' };
  }
}
```

#### 3.6 服务层规范

```typescript
// user/users.service.ts
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { QueryUsersDto } from './dto/query-users.dto';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  /**
   * 创建用户
   */
  async create(createUserDto: CreateUserDto): Promise<User> {
    // 检查邮箱是否已存在
    const existingUser = await this.userRepository.findOne({
      where: { email: createUserDto.email },
    });

    if (existingUser) {
      throw new ConflictException('Email already exists');
    }

    // 密码加密
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);

    // 创建用户实体
    const user = this.userRepository.create({
      ...createUserDto,
      password: hashedPassword,
    });

    // 保存到数据库
    return await this.userRepository.save(user);
  }

  /**
   * 查询用户列表
   */
  async findAll(query: QueryUsersDto): Promise<{ users: User[]; total: number }> {
    const { page = 1, pageSize = 20, keyword, status } = query;

    const queryBuilder = this.userRepository.createQueryBuilder('user');

    // 关键词搜索
    if (keyword) {
      queryBuilder.andWhere(
        '(user.nickname LIKE :keyword OR user.email LIKE :keyword)',
        { keyword: `%${keyword}%` },
      );
    }

    // 状态筛选
    if (status) {
      queryBuilder.andWhere('user.status = :status', { status });
    }

    // 分页
    queryBuilder
      .skip((page - 1) * pageSize)
      .take(pageSize)
      .orderBy('user.createdAt', 'DESC');

    const [users, total] = await queryBuilder.getManyAndCount();

    return { users, total };
  }

  /**
   * 查询单个用户
   */
  async findOne(id: string): Promise<User> {
    const user = await this.userRepository.findOne({ where: { id } });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    return user;
  }

  /**
   * 更新用户
   */
  async update(id: string, updateUserDto: UpdateUserDto): Promise<User> {
    const user = await this.findOne(id);

    // 如果更新密码，需要加密
    if (updateUserDto.password) {
      updateUserDto.password = await bcrypt.hash(updateUserDto.password, 10);
    }

    Object.assign(user, updateUserDto);
    return await this.userRepository.save(user);
  }

  /**
   * 删除用户
   */
  async remove(id: string): Promise<void> {
    const user = await this.findOne(id);
    await this.userRepository.remove(user);
  }

  /**
   * 根据邮箱查找用户
   */
  async findByEmail(email: string): Promise<User | null> {
    return await this.userRepository.findOne({ where: { email } });
  }
}
```

#### 3.7 DTO规范

```typescript
// user/dto/create-user.dto.ts
import {
  IsEmail,
  IsNotEmpty,
  MinLength,
  MaxLength,
  IsEnum,
  IsOptional,
  Matches,
} from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { MemberLevel, PrivacyLevel } from '@/common/enums/user.enum';

export class CreateUserDto {
  @ApiProperty({ example: 'user@example.com', description: '用户邮箱' })
  @IsEmail({}, { message: '邮箱格式不正确' })
  @IsNotEmpty({ message: '邮箱不能为空' })
  email: string;

  @ApiProperty({ example: 'Password123!', description: '用户密码' })
  @IsNotEmpty({ message: '密码不能为空' })
  @MinLength(8, { message: '密码长度至少8位' })
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message: '密码必须包含大小写字母、数字和特殊字符',
  })
  password: string;

  @ApiProperty({ example: '张三', description: '用户昵称' })
  @IsNotEmpty({ message: '昵称不能为空' })
  @MaxLength(50, { message: '昵称长度不能超过50个字符' })
  nickname: string;

  @ApiProperty({ enum: MemberLevel, description: '会员等级' })
  @IsEnum(MemberLevel, { message: '会员等级无效' })
  @IsOptional()
  memberLevel?: MemberLevel;

  @ApiProperty({ enum: PrivacyLevel, description: '隐私等级' })
  @IsEnum(PrivacyLevel, { message: '隐私等级无效' })
  @IsOptional()
  privacyLevel?: PrivacyLevel;
}

// user/dto/update-user.dto.ts
import { PartialType } from '@nestjs/swagger';
import { CreateUserDto } from './create-user.dto';

export class UpdateUserDto extends PartialType(CreateUserDto) {
  // 继承CreateUserDto的所有字段，但都是可选的
}

// user/dto/query-users.dto.ts
import { IsOptional, IsEnum, IsInt, Min } from 'class-validator';
import { Type } from 'class-transformer';
import { ApiProperty } from '@nestjs/swagger';
import { UserStatus } from '@/common/enums/user.enum';

export class QueryUsersDto {
  @ApiProperty({ required: false, description: '页码' })
  @IsOptional()
  @Type(() => Number)
  @IsInt({ message: '页码必须是整数' })
  @Min(1, { message: '页码最小为1' })
  page?: number = 1;

  @ApiProperty({ required: false, description: '每页数量' })
  @IsOptional()
  @Type(() => Number)
  @IsInt({ message: '每页数量必须是整数' })
  @Min(1, { message: '每页数量最小为1' })
  pageSize?: number = 20;

  @ApiProperty({ required: false, description: '搜索关键词' })
  @IsOptional()
  keyword?: string;

  @ApiProperty({ enum: UserStatus, required: false, description: '用户状态' })
  @IsOptional()
  @IsEnum(UserStatus, { message: '用户状态无效' })
  status?: UserStatus;
}
```

#### 3.8 实体定义规范

```typescript
// user/entities/user.entity.ts
import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  BeforeInsert,
  BeforeUpdate,
} from 'typeorm';
import { MemberLevel, PrivacyLevel, UserStatus } from '@/common/enums/user.enum';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true, length: 100 })
  email: string;

  @Column({ name: 'password_hash', select: false }) // 查询时默认不返回
  password: string;

  @Column({ length: 50 })
  nickname: string;

  @Column({
    type: 'enum',
    enum: MemberLevel,
    default: MemberLevel.REGULAR,
  })
  memberLevel: MemberLevel;

  @Column({
    type: 'enum',
    enum: PrivacyLevel,
    default: PrivacyLevel.STANDARD,
  })
  privacyLevel: PrivacyLevel;

  @Column({
    type: 'enum',
    enum: UserStatus,
    default: UserStatus.ACTIVE,
  })
  status: UserStatus;

  @Column({ name: 'avatar_url', nullable: true })
  avatar: string;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  // 生命周期钩子
  @BeforeInsert()
  @BeforeUpdate()
  validateFields() {
    // 在插入/更新前验证字段
    if (this.nickname && this.nickname.length > 50) {
      throw new Error('昵称长度不能超过50个字符');
    }
  }
}
```

#### 3.9 异常处理规范

```typescript
// common/filters/business-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Response } from 'express';

interface ErrorResponse {
  code: number;
  message: string;
  timestamp: string;
  path: string;
}

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest();
    const status = exception.getStatus();
    const exceptionResponse = exception.getResponse();

    const errorResponse: ErrorResponse = {
      code: status,
      message: this.extractMessage(exceptionResponse),
      timestamp: new Date().toISOString(),
      path: request.url,
    };

    // 记录错误日志
    console.error('Error:', {
      ...errorResponse,
      stack: exception.stack,
    });

    response.status(status).json(errorResponse);
  }

  private extractMessage(exceptionResponse: any): string {
    if (typeof exceptionResponse === 'string') {
      return exceptionResponse;
    }
    if (exceptionResponse?.message) {
      if (Array.isArray(exceptionResponse.message)) {
        return exceptionResponse.message.join(', ');
      }
      return exceptionResponse.message;
    }
    return 'Internal server error';
  }
}

// main.ts中注册
import { HttpExceptionFilter } from './common/filters/business-exception.filter';

app.useGlobalFilters(new HttpExceptionFilter());

// 自定义业务异常
// common/exceptions/business.exception.ts
import { HttpException, HttpStatus } from '@nestjs/common';

export class BusinessException extends HttpException {
  constructor(
    message: string,
    code: number = HttpStatus.BAD_REQUEST,
  ) {
    super(
      {
        code,
        message,
      },
      code,
    );
  }
}

// 使用示例
throw new BusinessException('用户不存在', 404);
throw new BusinessException('邮箱已被注册', 400);
```

#### 3.10 守卫与权限控制

```typescript
// common/guards/jwt-auth.guard.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      throw new UnauthorizedException('Token not found');
    }

    try {
      const payload = await this.jwtService.verifyAsync(token);
      request.user = payload;
    } catch {
      throw new UnauthorizedException('Invalid token');
    }

    return true;
  }

  private extractTokenFromHeader(request: any): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}

// common/guards/permissions.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(
      'permissions',
      [context.getHandler(), context.getClass()],
    );

    if (!requiredPermissions) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();

    if (!user) {
      throw new ForbiddenException('User not authenticated');
    }

    const hasPermission = requiredPermissions.some(
      (permission) => user.permissions?.includes(permission),
    );

    if (!hasPermission) {
      throw new ForbiddenException('Insufficient permissions');
    }

    return true;
  }
}

// common/decorators/permissions.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const PERMISSIONS_KEY = 'permissions';
export const RequirePermissions = (...permissions: string[]) =>
  SetMetadata(PERMISSIONS_KEY, permissions);
```

#### 3.11 数据加密与隐私保护

```typescript
// utils/crypto.ts
import * as crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const KEY_LENGTH = 32;
const IV_LENGTH = 16;
const SALT_LENGTH = 64;
const TAG_LENGTH = 16;
const TAG_POSITION = SALT_LENGTH + IV_LENGTH;
const ENCRYPTED_POSITION = TAG_POSITION + TAG_LENGTH;

export class CryptoService {
  private getKey(salt: Buffer): Buffer {
    return crypto.pbkdf2Sync(
      process.env.ENCRYPTION_KEY || '',
      salt,
      100000,
      KEY_LENGTH,
      'sha256',
    );
  }

  /**
   * 加密数据
   */
  encrypt(text: string): string {
    const iv = crypto.randomBytes(IV_LENGTH);
    const salt = crypto.randomBytes(SALT_LENGTH);
    const key = this.getKey(salt);

    const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
    const encrypted = Buffer.concat([cipher.update(text, 'utf8'), cipher.final()]);

    const tag = cipher.getAuthTag();

    return Buffer.concat([salt, iv, tag, encrypted]).toString('base64');
  }

  /**
   * 解密数据
   */
  decrypt(encryptedData: string): string {
    const buffer = Buffer.from(encryptedData, 'base64');

    const salt = buffer.subarray(0, SALT_LENGTH);
    const iv = buffer.subarray(SALT_LENGTH, TAG_POSITION);
    const tag = buffer.subarray(TAG_POSITION, ENCRYPTED_POSITION);
    const encrypted = buffer.subarray(ENCRYPTED_POSITION);

    const key = this.getKey(salt);

    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
    decipher.setAuthTag(tag);

    return decipher.update(encrypted) + decipher.final('utf8');
  }

  /**
   * 哈希密码
   */
  async hashPassword(password: string): Promise<string> {
    const bcrypt = require('bcrypt');
    return bcrypt.hash(password, 10);
  }

  /**
   * 验证密码
   */
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    const bcrypt = require('bcrypt');
    return bcrypt.compare(password, hash);
  }
}

// 使用示例
const cryptoService = new CryptoService();

// 加密敏感数据存储
const encryptedAddress = cryptoService.encrypt(userAddress);
// 存入数据库...

// 读取时解密
const decryptedAddress = cryptoService.decrypt(encryptedAddress);
```

#### 3.12 日志记录规范

```typescript
// utils/logger.ts
import { Injectable, LoggerService, Scope } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';

@Injectable({ scope: Scope.TRANSIENT })
export class AppLogger implements LoggerService {
  private logFilePath = path.join(process.cwd(), 'logs', 'app.log');

  log(message: string, context?: string) {
    this.writeLog('LOG', message, context);
  }

  error(message: string, trace?: string, context?: string) {
    this.writeLog('ERROR', message, context, trace);
  }

  warn(message: string, context?: string) {
    this.writeLog('WARN', message, context);
  }

  debug(message: string, context?: string) {
    if (process.env.NODE_ENV === 'development') {
      this.writeLog('DEBUG', message, context);
    }
  }

  verbose(message: string, context?: string) {
    if (process.env.NODE_ENV === 'development') {
      this.writeLog('VERBOSE', message, context);
    }
  }

  private writeLog(level: string, message: string, context?: string, trace?: string) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      context,
      message,
      trace,
    };

    // 控制台输出
    console.log(JSON.stringify(logEntry));

    // 文件输出
    try {
      const logDir = path.dirname(this.logFilePath);
      if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
      }
      fs.appendFileSync(this.logFilePath, JSON.stringify(logEntry) + '\n');
    } catch (error) {
      console.error('Failed to write log:', error);
    }
  }
}

// 使用示例
import { AppLogger } from '@/utils/logger';

@Injectable()
export class UsersService {
  private readonly logger = new AppLogger();

  async create(createUserDto: CreateUserDto) {
    this.logger.log('Creating user', 'UsersService');
    try {
      // 业务逻辑
      this.logger.log('User created successfully', 'UsersService');
    } catch (error) {
      this.logger.error('Failed to create user', error.stack, 'UsersService');
      throw error;
    }
  }
}
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
