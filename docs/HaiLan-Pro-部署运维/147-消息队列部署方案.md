---
@file: 147-消息队列部署方案.md
@description: HaiLan Pro RabbitMQ消息队列部署方案，包含集群部署、高可用配置
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-部署运维],[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 147 消息队列部署方案

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-部署运维-消息队列部署方案相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范消息队列部署方案相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 消息队列部署方案

#### 3.1 消息队列选型

HaiLan Pro 使用 Supabase Realtime 作为主要消息传递方案，辅以 Redis Pub/Sub 实现实时通信。

**方案对比：**

| 方案 | 优势 | 劣势 | 适用场景 |
|------|------|------|----------|
| Supabase Realtime | 与数据库集成、开箱即用 | 依赖 Supabase | 实时数据同步 |
| Redis Pub/Sub | 高性能、低延迟 | 消息不持久化 | 实时通知 |
| RabbitMQ | 功能丰富、可靠 | 部署复杂 | 异步任务 |

#### 3.2 Supabase Realtime 配置

**订阅配置：**

```typescript
// lib/supabase/realtime.ts
import { supabase } from './client';

export class RealtimeManager {
  private channels: Map<string, RealtimeChannel> = new Map();

  // 订听订单变更
  subscribeToOrders(userId: string, callback: (payload: any) => void) {
    const channel = supabase
      .channel(`orders:${userId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'orders',
          filter: `user_id=eq.${userId}`,
        },
        callback
      )
      .subscribe();

    this.channels.set(`orders:${userId}`, channel);
    return channel;
  }

  // 订听设备状态
  subscribeToDevice(deviceId: string, callback: (payload: any) => void) {
    const channel = supabase
      .channel(`device:${deviceId}`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'devices',
          filter: `id=eq.${deviceId}`,
        },
        callback
      )
      .subscribe();

    this.channels.set(`device:${deviceId}`, channel);
    return channel;
  }

  // 取消订阅
  unsubscribe(channelName: string) {
    const channel = this.channels.get(channelName);
    if (channel) {
      supabase.removeChannel(channel);
      this.channels.delete(channelName);
    }
  }

  // 取消所有订阅
  unsubscribeAll() {
    this.channels.forEach((channel) => {
      supabase.removeChannel(channel);
    });
    this.channels.clear();
  }
}

export const realtimeManager = new RealtimeManager();
```

#### 3.3 Redis Pub/Sub 配置

**发布/订阅实现：**

```typescript
// lib/redis/pubsub.ts
import { Redis } from 'ioredis';

export class RedisPubSub {
  private publisher: Redis;
  private subscriber: Redis;
  private subscriptions: Map<string, Set<(message: any) => void>> = new Map();

  constructor() {
    this.publisher = new Redis({
      host: process.env.REDIS_HOST,
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
    });

    this.subscriber = new Redis({
      host: process.env.REDIS_HOST,
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
    });

    this.setupSubscriber();
  }

  private setupSubscriber() {
    this.subscriber.on('message', (channel, message) => {
      const callbacks = this.subscriptions.get(channel);
      if (callbacks) {
        const data = JSON.parse(message);
        callbacks.forEach((callback) => callback(data));
      }
    });
  }

  // 发布消息
  async publish(channel: string, data: any): Promise<number> {
    return this.publisher.publish(channel, JSON.stringify(data));
  }

  // 订阅频道
  async subscribe(channel: string, callback: (message: any) => void): Promise<void> {
    if (!this.subscriptions.has(channel)) {
      this.subscriptions.set(channel, new Set());
      await this.subscriber.subscribe(channel);
    }
    this.subscriptions.get(channel)!.add(callback);
  }

  // 取消订阅
  async unsubscribe(channel: string, callback?: (message: any) => void): Promise<void> {
    const callbacks = this.subscriptions.get(channel);
    if (callbacks) {
      if (callback) {
        callbacks.delete(callback);
      } else {
        callbacks.clear();
      }
      if (callbacks.size === 0) {
        await this.subscriber.unsubscribe(channel);
        this.subscriptions.delete(channel);
      }
    }
  }

  // 广播通知
  async broadcastNotification(userId: string, notification: {
    title: string;
    body: string;
    type: string;
  }): Promise<void> {
    await this.publish(`notifications:${userId}`, notification);
  }

  // 设备状态更新
  async publishDeviceState(deviceId: string, state: any): Promise<void> {
    await this.publish(`devices:${deviceId}`, state);
  }
}

export const redisPubSub = new RedisPubSub();
```

#### 3.4 消息队列使用场景

**场景定义：**

| 场景 | 方案 | 频道模式 | 持久化 |
|------|------|----------|--------|
| 订单状态变更 | Supabase Realtime | `orders:{userId}` | 是 |
| 设备数据同步 | Supabase Realtime | `devices:{deviceId}` | 是 |
| 实时通知 | Redis Pub/Sub | `notifications:{userId}` | 否 |
| AI 对话更新 | Supabase Realtime | `conversations:{id}` | 是 |
| 系统广播 | Redis Pub/Sub | `broadcast:system` | 否 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
