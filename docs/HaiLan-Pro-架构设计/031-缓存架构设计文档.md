---
file: 031-缓存架构设计文档.md
description: HaiLan Pro 缓存策略、缓存层级、缓存失效处理的设计方案，提升系统性能
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-架构设计,[]
---

> ***YanYuCloudCube***
> 言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> 万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 031 缓存架构设计文档

## 概述

本文档详细描述HaiLan Pro的缓存架构设计，包括多级缓存策略、缓存失效处理、缓存预热方案等，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 缓存价值
- **提升响应速度**：减少数据库查询，降低响应时间
- **减轻服务器压力**：减少后端服务负载
- **改善用户体验**：配合PWA实现离线能力
- **降低成本**：减少数据库资源消耗

#### 1.3 文档目标
- 规范缓存架构相关的业务标准与技术落地要求
- 定义多级缓存策略与失效处理机制
- 保障缓存模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：缓存故障时自动降级，不影响核心功能
- **高性能**：多级缓存架构，毫秒级响应
- **高安全性**：敏感数据不缓存，缓存数据加密
- **高扩展性**：支持分布式缓存，水平扩展
- **高可维护性**：统一的缓存管理接口，便于监控

#### 2.2 五标体系
- **标准化**：统一的缓存Key命名规范与数据格式
- **规范化**：缓存更新、失效的标准化流程
- **自动化**：自动缓存预热、自动过期清理
- **智能化**：智能缓存预测与热点数据识别
- **可视化**：缓存命中率监控与统计仪表板

#### 2.3 五化架构
- **流程化**：标准化的缓存读写流程
- **文档化**：完善的缓存策略文档
- **工具化**：缓存分析工具与命令行接口
- **数字化**：缓存效果量化指标
- **生态化**：兼容Redis、Memcached等主流方案

### 3. 缓存架构设计

#### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                      HaiLan Pro 缓存架构                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   L1 浏览器缓存                          │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │Cache API │  │IndexedDB │  │LocalStorage│ │Session │ │   │
│  │  │(动态资源) │  │(离线数据) │  │(配置数据)  │ │Storage │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   L2 CDN缓存                             │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │静态资源   │  │图片文件   │  │API响应    │  │边缘节点 │ │   │
│  │  │JS/CSS    │  │Images    │  │GET /public│ │Edge CDN │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   L3 应用缓存                             │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │内存缓存   │  │本地缓存   │  │进程缓存   │  │对象池  │ │   │
│  │  │LRU Cache │  │LocalCache │  │Process   │  │Pool    │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   L4 分布式缓存                           │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │Redis     │  │Redis     │  │持久化     │  │集群    │ │   │
│  │  │Master    │  │Slave     │  │RDB/AOF   │  │Cluster │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   L5 数据库                               │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │PostgreSQL│  │查询缓存   │  │连接池     │  │只读副本│ │   │
│  │  │Primary   │  │Query Cache│  │Pool      │  │Replica │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.2 缓存层级设计

##### 3.2.1 L1 浏览器缓存

```typescript
// src/cache/layer1/browser.ts
export class BrowserCacheManager {
  private cacheName = 'hailan-pro-v1';

  // Cache API - 用于网络请求缓存
  async cacheRequest(url: string, response: Response): Promise<void> {
    const cache = await caches.open(this.cacheName);
    await cache.put(url, response);
  }

  async getCachedRequest(url: string): Promise<Response | undefined> {
    const cache = await caches.open(this.cacheName);
    return await cache.match(url);
  }

  // IndexedDB - 用于离线数据存储
  async setIndexedDB<T>(storeName: string, key: string, value: T): Promise<void> {
    const db = await this.getDB();
    const tx = db.transaction(storeName, 'readwrite');
    await tx.objectStore(storeName).put(value, key);
  }

  async getIndexedDB<T>(storeName: string, key: string): Promise<T | undefined> {
    const db = await this.getDB();
    const tx = db.transaction(storeName, 'readonly');
    const result = await tx.objectStore(storeName).get(key);
    return result;
  }

  // LocalStorage - 用于配置数据
  async setLocalStorage(key: string, value: string): Promise<void> {
    localStorage.setItem(key, value);
  }

  async getLocalStorage(key: string): Promise<string | null> {
    return localStorage.getItem(key);
  }

  // SessionStorage - 用于会话数据
  async setSessionStorage(key: string, value: string): Promise<void> {
    sessionStorage.setItem(key, value);
  }

  async getSessionStorage(key: string): Promise<string | null> {
    return sessionStorage.getItem(key);
  }

  private async getDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('HaiLanPro', 1);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;

        // 创建对象存储
        if (!db.objectStoreNames.contains('userData')) {
          db.createObjectStore('userData');
        }
        if (!db.objectStoreNames.contains('productData')) {
          db.createObjectStore('productData');
        }
        if (!db.objectStoreNames.contains('chatHistory')) {
          db.createObjectStore('chatHistory');
        }
      };
    });
  }
}
```

##### 3.2.2 L2 CDN缓存策略

```typescript
// CDN缓存配置
export const CDN_CACHE_CONFIG = {
  // 静态资源 - 1年
  staticAssets: {
    pattern: '/assets/*.{js,css,woff2}',
    cacheControl: 'public, max-age=31536000, immutable',
  },

  // 图片资源 - 7天
  images: {
    pattern: '/images/*.{png,jpg,jpeg,svg,webp}',
    cacheControl: 'public, max-age=604800',
  },

  // 公开API - 5分钟
  publicAPI: {
    pattern: '/api/public/*',
    cacheControl: 'public, max-age=300, s-maxage=300',
  },

  // 私有数据 - 不缓存
  privateAPI: {
    pattern: '/api/private/*',
    cacheControl: 'no-store, no-cache, must-revalidate',
  },

  // HTML文档 - 不缓存
  html: {
    pattern: '*.html',
    cacheControl: 'no-cache',
  },
};
```

##### 3.2.3 L3 应用内存缓存

```typescript
// src/cache/layer3/memory.ts
interface CacheEntry<T> {
  value: T;
  expiresAt: number;
  accessCount: number;
  lastAccess: number;
}

export class MemoryCache {
  private cache = new Map<string, CacheEntry<any>>();
  private maxSize: number;
  private defaultTTL: number;

  constructor(maxSize = 1000, defaultTTL = 5 * 60 * 1000) {
    this.maxSize = maxSize;
    this.defaultTTL = defaultTTL;

    // 定期清理过期条目
    setInterval(() => this.cleanup(), 60 * 1000);
  }

  // 获取缓存
  get<T>(key: string): T | undefined {
    const entry = this.cache.get(key);

    if (!entry) {
      return undefined;
    }

    // 检查过期
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return undefined;
    }

    // 更新访问信息
    entry.accessCount++;
    entry.lastAccess = Date.now();

    return entry.value as T;
  }

  // 设置缓存
  set<T>(key: string, value: T, ttl?: number): void {
    // 检查容量限制
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      this.evict();
    }

    this.cache.set(key, {
      value,
      expiresAt: Date.now() + (ttl ?? this.defaultTTL),
      accessCount: 0,
      lastAccess: Date.now(),
    });
  }

  // 删除缓存
  delete(key: string): boolean {
    return this.cache.delete(key);
  }

  // 清空缓存
  clear(): void {
    this.cache.clear();
  }

  // 缓存淘汰 (LRU)
  private evict(): void {
    let oldestKey: string | undefined;
    let oldestTime = Infinity;

    for (const [key, entry] of this.cache.entries()) {
      if (entry.lastAccess < oldestTime) {
        oldestTime = entry.lastAccess;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  // 清理过期条目
  private cleanup(): void {
    const now = Date.now();

    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiresAt) {
        this.cache.delete(key);
      }
    }
  }

  // 获取缓存统计
  getStats(): {
    size: number;
    hitRate: number;
    entries: Array<{ key: string; accessCount: number }>;
  } {
    let totalAccess = 0;
    const entries: Array<{ key: string; accessCount: number }> = [];

    for (const [key, entry] of this.cache.entries()) {
      totalAccess += entry.accessCount;
      entries.push({ key, accessCount: entry.accessCount });
    }

    return {
      size: this.cache.size,
      hitRate: totalAccess > 0 ? 1 : 0,
      entries: entries.sort((a, b) => b.accessCount - a.accessCount),
    };
  }
}
```

##### 3.2.4 L4 Redis分布式缓存

```typescript
// src/cache/layer4/redis.ts
import { Redis } from 'ioredis';

export class RedisCacheManager {
  private client: Redis;

  constructor() {
    this.client = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      db: parseInt(process.env.REDIS_DB || '0'),
      retryStrategy: (times) => Math.min(times * 50, 2000),
    });

    this.client.on('error', (error) => {
      console.error('Redis error:', error);
    });
  }

  // 获取缓存
  async get<T>(key: string): Promise<T | null> {
    const data = await this.client.get(key);

    if (!data) {
      return null;
    }

    try {
      return JSON.parse(data) as T;
    } catch {
      return data as T;
    }
  }

  // 设置缓存
  async set<T>(key: string, value: T, ttl?: number): Promise<void> {
    const data = typeof value === 'string' ? value : JSON.stringify(value);

    if (ttl) {
      await this.client.setex(key, ttl, data);
    } else {
      await this.client.set(key, data);
    }
  }

  // 删除缓存
  async del(key: string): Promise<number> {
    return await this.client.del(key);
  }

  // 批量删除
  async delPattern(pattern: string): Promise<number> {
    const keys = await this.client.keys(pattern);

    if (keys.length === 0) {
      return 0;
    }

    return await this.client.del(...keys);
  }

  // 检查键是否存在
  async exists(key: string): Promise<boolean> {
    const result = await this.client.exists(key);
    return result === 1;
  }

  // 设置过期时间
  async expire(key: string, seconds: number): Promise<boolean> {
    const result = await this.client.expire(key, seconds);
    return result === 1;
  }

  // 获取剩余过期时间
  async ttl(key: string): Promise<number> {
    return await this.client.ttl(key);
  }

  // 原子递增
  async incr(key: string): Promise<number> {
    return await this.client.incr(key);
  }

  // 原子递减
  async decr(key: string): Promise<number> {
    return await this.client.decr(key);
  }

  // Hash操作
  async hset(key: string, field: string, value: string): Promise<number> {
    return await this.client.hset(key, field, value);
  }

  async hget(key: string, field: string): Promise<string | null> {
    return await this.client.hget(key, field);
  }

  async hgetall(key: string): Promise<Record<string, string>> {
    return await this.client.hgetall(key);
  }

  async hdel(key: string, ...fields: string[]): Promise<number> {
    return await this.client.hdel(key, ...fields);
  }

  // List操作
  async lpush(key: string, ...values: string[]): Promise<number> {
    return await this.client.lpush(key, ...values);
  }

  async rpop(key: string): Promise<string | null> {
    return await this.client.rpop(key);
  }

  async lrange(key: string, start: number, stop: number): Promise<string[]> {
    return await this.client.lrange(key, start, stop);
  }

  // Set操作
  async sadd(key: string, ...members: string[]): Promise<number> {
    return await this.client.sadd(key, ...members);
  }

  async smembers(key: string): Promise<string[]> {
    return await this.client.smembers(key);
  }

  async sismember(key: string, member: string): Promise<boolean> {
    const result = await this.client.sismember(key, member);
    return result === 1;
  }

  // 关闭连接
  async quit(): Promise<void> {
    await this.client.quit();
  }

  // 发布订阅
  async publish(channel: string, message: string): Promise<number> {
    return await this.client.publish(channel, message);
  }

  async subscribe(channel: string, callback: (message: string) => void): Promise<void> {
    const subscriber = this.client.duplicate();

    await subscriber.subscribe(channel);
    subscriber.on('message', (_, message) => callback(message));
  }
}
```

#### 3.3 缓存策略

##### 3.3.1 Cache-Aside模式

```typescript
// src/cache/strategies/cache-aside.ts
export class CacheAsideStrategy {
  constructor(
    private cache: RedisCacheManager,
    private db: Database
  ) {}

  async get<T>(key: string, dbLoader: () => Promise<T>, ttl?: number): Promise<T> {
    // 1. 先查缓存
    const cached = await this.cache.get<T>(key);
    if (cached !== null) {
      return cached;
    }

    // 2. 缓存未命中，查数据库
    const data = await dbLoader();

    // 3. 写入缓存
    if (data !== null) {
      await this.cache.set(key, data, ttl);
    }

    return data;
  }

  async set<T>(key: string, value: T, dbUpdater: (value: T) => Promise<void>, ttl?: number): Promise<void> {
    // 1. 先更新数据库
    await dbUpdater(value);

    // 2. 更新缓存
    await this.cache.set(key, value, ttl);
  }

  async delete(key: string, dbDeleter?: () => Promise<void>): Promise<void> {
    // 1. 删除缓存
    await this.cache.del(key);

    // 2. 删除数据库
    if (dbDeleter) {
      await dbDeleter();
    }
  }
}
```

##### 3.3.2 Read-Through模式

```typescript
// src/cache/strategies/read-through.ts
export class ReadThroughStrategy {
  constructor(
    private cache: RedisCacheManager,
    private dbLoader: (key: string) => Promise<any>
  ) {}

  async get<T>(key: string, ttl?: number): Promise<T | null> {
    // 1. 先查缓存
    let data = await this.cache.get<T>(key);

    // 2. 缓存未命中，由缓存层负责加载
    if (data === null) {
      data = await this.dbLoader(key);

      if (data !== null) {
        await this.cache.set(key, data, ttl);
      }
    }

    return data;
  }
}
```

##### 3.3.3 Write-Through模式

```typescript
// src/cache/strategies/write-through.ts
export class WriteThroughStrategy {
  constructor(
    private cache: RedisCacheManager,
    dbWriter: (key: string, value: any) => Promise<void>
  ) {
    this.dbWriter = dbWriter;
  }

  async set<T>(key: string, value: T, ttl?: number): Promise<void> {
    // 1. 同时更新缓存和数据库
    await Promise.all([
      this.cache.set(key, value, ttl),
      this.dbWriter(key, value),
    ]);
  }

  private dbWriter: (key: string, value: any) => Promise<void>;
}
```

##### 3.3.4 Write-Behind模式

```typescript
// src/cache/strategies/write-behind.ts
export class WriteBehindStrategy {
  private writeQueue = new Map<string, any>();
  private writeTimer?: NodeJS.Timeout;

  constructor(
    private cache: RedisCacheManager,
    private dbWriter: (key: string, value: any) => Promise<void>,
    private delayMs = 1000
  ) {}

  async set<T>(key: string, value: T, ttl?: number): Promise<void> {
    // 1. 立即更新缓存
    await this.cache.set(key, value, ttl);

    // 2. 加入写入队列
    this.writeQueue.set(key, value);

    // 3. 延迟写入数据库
    this.scheduleWrite();
  }

  private scheduleWrite(): void {
    if (this.writeTimer) {
      return;
    }

    this.writeTimer = setTimeout(async () => {
      await this.flushWrites();
      this.writeTimer = undefined;
    }, this.delayMs);
  }

  private async flushWrites(): Promise<void> {
    const writes = Array.from(this.writeQueue.entries());
    this.writeQueue.clear();

    await Promise.all(
      writes.map(([key, value]) => this.dbWriter(key, value))
    );
  }
}
```

#### 3.4 缓存失效处理

##### 3.4.1 TTL过期策略

```typescript
// src/cache/expiration/ttl.ts
export class TTLManager {
  // 不同数据类型的TTL配置
  static readonly TTL_CONFIG = {
    // 用户数据 - 1小时
    user: 60 * 60,

    // 产品数据 - 30分钟
    product: 30 * 60,

    // 订单数据 - 10分钟
    order: 10 * 60,

    // 会话数据 - 24小时
    session: 24 * 60 * 60,

    // 热门数据 - 5分钟
    hot: 5 * 60,

    // 配置数据 - 1小时
    config: 60 * 60,

    // AI对话上下文 - 30分钟
    aiContext: 30 * 60,

    // 计数器 - 永久
    counter: 0,
  };

  static getTTL(dataType: keyof typeof TTLManager.TTL_CONFIG): number {
    return TTLManager.TTL_CONFIG[dataType];
  }

  // 延长过期时间
  static async extend(
    cache: RedisCacheManager,
    key: string,
    additionalTTL: number
  ): Promise<boolean> {
    const currentTTL = await cache.ttl(key);

    if (currentTTL < 0) {
      return false;
    }

    return await cache.expire(key, currentTTL + additionalTTL);
  }
}
```

##### 3.4.2 主动失效策略

```typescript
// src/cache/invalidation/active.ts
export class CacheInvalidator {
  constructor(private cache: RedisCacheManager) {}

  // 数据更新时失效相关缓存
  async invalidateOnUpdate(entityType: string, entityId: string): Promise<void> {
    const patterns = [
      `${entityType}:${entityId}`,
      `${entityType}:list:*`,
      `${entityType}:detail:${entityId}`,
      `${entityType}:related:${entityId}`,
    ];

    for (const pattern of patterns) {
      await this.cache.delPattern(pattern);
    }
  }

  // 用户数据失效
  async invalidateUserData(userId: string): Promise<void> {
    await Promise.all([
      this.cache.delPattern(`user:${userId}:*`),
      this.cache.delPattern(`user:${userId}:profile`),
      this.cache.delPattern(`user:${userId}:preferences`),
      this.cache.delPattern(`user:${userId}:health:*`),
    ]);
  }

  // 产品数据失效
  async invalidateProductData(productId: string): Promise<void> {
    await Promise.all([
      this.cache.delPattern(`product:${productId}:*`),
      this.cache.delPattern(`product:list:*`),
      this.cache.delPattern(`product:related:${productId}`),
    ]);
  }

  // 全局缓存刷新
  async flushAll(): Promise<void> {
    await this.cache.delPattern('*');
  }
}
```

##### 3.4.3 缓存预热

```typescript
// src/cache/warming/preloader.ts
export class CacheWarmer {
  constructor(
    private cache: RedisCacheManager,
    private db: Database
  ) {}

  // 预热热门产品
  async warmPopularProducts(): Promise<void> {
    const products = await this.db.query(`
      SELECT * FROM products
      WHERE status = 'active'
      ORDER BY view_count DESC
      LIMIT 100
    `);

    for (const product of products) {
      const key = `product:${product.id}:detail`;
      await this.cache.set(key, product, TTLManager.getTTL('product'));
    }
  }

  // 预热用户数据
  async warmUserData(userId: string): Promise<void> {
    const [profile, preferences, healthData] = await Promise.all([
      this.db.query('SELECT * FROM user_profiles WHERE user_id = $1', [userId]),
      this.db.query('SELECT * FROM user_preferences WHERE user_id = $1', [userId]),
      this.db.query('SELECT * FROM health_records WHERE user_id = $1 ORDER BY date DESC LIMIT 10', [userId]),
    ]);

    if (profile) {
      await this.cache.set(`user:${userId}:profile`, profile, TTLManager.getTTL('user'));
    }

    if (preferences) {
      await this.cache.set(`user:${userId}:preferences`, preferences, TTLManager.getTTL('user'));
    }

    if (healthData.length > 0) {
      await this.cache.set(`user:${userId}:health:recent`, healthData, TTLManager.getTTL('user'));
    }
  }

  // 预热配置数据
  async warmConfigData(): Promise<void> {
    const configs = await this.db.query('SELECT * FROM app_configs');

    for (const config of configs) {
      const key = `config:${config.key}`;
      await this.cache.set(key, config.value, TTLManager.getTTL('config'));
    }
  }
}
```

#### 3.5 缓存监控

##### 3.5.1 缓存指标

```typescript
// src/cache/monitoring/metrics.ts
export interface CacheMetrics {
  // 命中率
  hitRate: number;
  hitCount: number;
  missCount: number;

  // 容量
  currentSize: number;
  maxSize: number;
  memoryUsage: number;

  // 延迟
  avgGetLatency: number;
  avgSetLatency: number;

  // 过期
  expiredCount: number;
  evictedCount: number;
}

export class CacheMetricsCollector {
  private metrics = {
    hitCount: 0,
    missCount: 0,
    getLatencies: [] as number[],
    setLatencies: [] as number[],
    expiredCount: 0,
    evictedCount: 0,
  };

  recordHit(): void {
    this.metrics.hitCount++;
  }

  recordMiss(): void {
    this.metrics.missCount++;
  }

  recordGetLatency(latency: number): void {
    this.metrics.getLatencies.push(latency);
    if (this.metrics.getLatencies.length > 1000) {
      this.metrics.getLatencies.shift();
    }
  }

  recordSetLatency(latency: number): void {
    this.metrics.setLatencies.push(latency);
    if (this.metrics.setLatencies.length > 1000) {
      this.metrics.setLatencies.shift();
    }
  }

  recordExpire(): void {
    this.metrics.expiredCount++;
  }

  recordEvict(): void {
    this.metrics.evictedCount++;
  }

  getMetrics(): CacheMetrics {
    const total = this.metrics.hitCount + this.metrics.missCount;

    return {
      hitRate: total > 0 ? this.metrics.hitCount / total : 0,
      hitCount: this.metrics.hitCount,
      missCount: this.metrics.missCount,
      currentSize: 0,
      maxSize: 0,
      memoryUsage: 0,
      avgGetLatency: this.average(this.metrics.getLatencies),
      avgSetLatency: this.average(this.metrics.setLatencies),
      expiredCount: this.metrics.expiredCount,
      evictedCount: this.metrics.evictedCount,
    };
  }

  private average(arr: number[]): number {
    if (arr.length === 0) return 0;
    return arr.reduce((a, b) => a + b, 0) / arr.length;
  }

  reset(): void {
    this.metrics = {
      hitCount: 0,
      missCount: 0,
      getLatencies: [],
      setLatencies: [],
      expiredCount: 0,
      evictedCount: 0,
    };
  }
}
```

### 4. 部署配置

#### 4.1 Redis集群配置

```yaml
# docker-compose.yml
version: '3.8'
services:
  redis-master:
    image: redis:7-alpine
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    ports:
      - "6379:6379"
    volumes:
      - redis-master-data:/data

  redis-slave-1:
    image: redis:7-alpine
    command: redis-server --slaveof redis-master 6379 --requirepass ${REDIS_PASSWORD} --masterauth ${REDIS_PASSWORD}
    ports:
      - "6380:6379"
    depends_on:
      - redis-master

  redis-slave-2:
    image: redis:7-alpine
    command: redis-server --slaveof redis-master 6379 --requirepass ${REDIS_PASSWORD} --masterauth ${REDIS_PASSWORD}
    ports:
      - "6381:6379"
    depends_on:
      - redis-master

  redis-sentinel-1:
    image: redis:7-alpine
    command: redis-sentinel /etc/redis/sentinel.conf
    volumes:
      - ./sentinel.conf:/etc/redis/sentinel.conf
    depends_on:
      - redis-master

volumes:
  redis-master-data:
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
