---
@file: 030-IoT设备架构设计.md
@description: HaiLan Pro 智能硬件设备集成架构设计，包含Web Bluetooth、设备管理、数据同步等
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-架构设计],[]
---

> ***YanYuCloudCube***
> 言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> 万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 030 IoT设备架构设计

## 概述

本文档详细描述HaiLan Pro的智能硬件设备(IoT)集成架构设计，包括Web Bluetooth连接、设备管理、数据同步、远程控制等核心功能，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 IoT设备类型
- **健康监测设备**：智能手环、体脂秤、血压计等
- **智能硬件产品**：各类智能化情趣健康设备
- **环境传感器**：温湿度、光照等环境监测设备
- **可穿戴设备**：智能首饰、健康追踪器等

#### 1.3 文档目标
- 规范IoT设备集成架构相关的业务标准与技术落地要求
- 定义设备连接、数据通信、远程控制的技术方案
- 保障IoT模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：设备断线自动重连，离线数据缓存
- **高性能**：低延迟数据传输，实时状态更新
- **高安全性**：设备配对加密，数据传输加密
- **高扩展性**：统一设备抽象层，支持多种设备类型
- **高可维护性**：设备固件OTA升级，远程诊断

#### 2.2 五标体系
- **标准化**：统一的设备接入协议与数据格式
- **规范化**：设备认证、配对、绑定流程规范
- **自动化**：自动发现、自动连接、自动同步
- **智能化**：AI分析设备数据，智能健康建议
- **可视化**：设备状态可视化，数据图表展示

#### 2.3 五化架构
- **流程化**：标准化的设备接入与管理流程
- **文档化**：完善的设备开发文档与API
- **工具化**：设备模拟器、调试工具
- **数字化**：设备数据量化与分析
- **生态化**：兼容主流设备厂商协议

### 3. IoT设备架构设计

#### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                      HaiLan Pro IoT架构                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    设备管理层                             │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │设备注册   │  │设备绑定   │  │设备监控   │  │OTA升级  │ │   │
│  │  │Register  │  │Binding   │  │Monitor   │  │Update   │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    连接层                                 │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │WebBluetooth│ │WebSocket │  │MQTT      │  │HTTP    │ │   │
│  │  │BLE连接    │  │实时通信   │  │消息队列   │  │RESTful │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    协议层                                 │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │设备认证   │  │数据加密   │  │指令下发   │  │数据上报 │ │   │
│  │  │Auth      │  │Crypto    │  │Command   │  │Report   │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    设备抽象层                             │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │健康设备   │  │智能硬件   │  │传感器     │  │可穿戴   │ │   │
│  │  │Health    │  │SmartHW   │  │Sensor    │  │Wearable │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
         │                                    │
    ┌────▼────┐                          ┌───▼────┐
    │PWA App  │                          │IoT Hub │
    │Browser  │                          │Cloud   │
    └─────────┘                          └────────┘
```

#### 3.2 Web Bluetooth连接

##### 3.2.1 设备扫描与连接

```typescript
// src/iot/bluetooth/manager.ts
export interface BluetoothDevice {
  id: string;
  name: string;
  type: DeviceType;
  connected: boolean;
  rssi?: number;
  services: BluetoothService[];
}

export interface BluetoothService {
  uuid: string;
  primary: boolean;
  characteristics: BluetoothCharacteristic[];
}

export interface BluetoothCharacteristic {
  uuid: string;
  properties: string[];
  value?: DataView;
}

export enum DeviceType {
  HEALTH_BAND = 'health_band',
  SMART_SCALE = 'smart_scale',
  BLOOD_PRESSURE = 'blood_pressure',
  SMART_HARDWARE = 'smart_hardware',
  SENSOR = 'sensor',
  WEARABLE = 'wearable',
}

// 设备服务UUID定义
export const SERVICE_UUIDS = {
  GENERIC_ACCESS: '0x1800',
  GENERIC_ATTRIBUTE: '0x1801',
  DEVICE_INFORMATION: '0x180A',
  HEALTH_THERMOMETER: '0x1809',
  HEART_RATE: '0x180D',
  BLOOD_PRESSURE: '0x1810',
  HAILAN_SERVICE: '0000FFF0-0000-1000-8000-00805F9B34FB',
};

// 特征UUID定义
export const CHARACTERISTIC_UUIDS = {
  DEVICE_NAME: '0x2A00',
  APPEARANCE: '0x2A01',
  MANUFACTURER: '0x2A29',
  BATTERY_LEVEL: '0x2A19',
  HEART_RATE_MEASUREMENT: '0x2A37',
  BLOOD_PRESSURE_MEASUREMENT: '0x2A35',
  HAILAN_COMMAND: '0000FFF1-0000-1000-8000-00805F9B34FB',
  HAILAN_DATA: '0000FFF2-0000-1000-8000-00805F9B34FB',
};

export class BluetoothManager {
  private device: BluetoothDevice | null = null;
  private server: BluetoothRemoteGATTServer | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 3;

  // 扫描设备
  async scanDevices(
    filters?: BluetoothLEScanFilter[],
    optionalServices?: string[]
  ): Promise<BluetoothDevice[]> {
    if (!navigator.bluetooth) {
      throw new Error('Web Bluetooth is not supported');
    }

    const defaultFilters = [
      { services: [SERVICE_UUIDS.HAILAN_SERVICE] },
      { namePrefix: 'HaiLan' },
      { services: [SERVICE_UUIDS.HEART_RATE] },
    ];

    const device = await navigator.bluetooth.requestDevice({
      filters: filters || defaultFilters,
      optionalServices: optionalServices || [
        SERVICE_UUIDS.HAILAN_SERVICE,
        SERVICE_UUIDS.HEART_RATE,
        SERVICE_UUIDS.BLOOD_PRESSURE,
        SERVICE_UUIDS.DEVICE_INFORMATION,
      ],
    });

    return [{
      id: device.id,
      name: device.name || 'Unknown Device',
      type: this.detectDeviceType(device.name),
      connected: device.gatt?.connected ?? false,
      services: [],
    }];
  }

  // 连接设备
  async connect(deviceId: string): Promise<void> {
    const device = await navigator.bluetooth.getDevices();
    const targetDevice = device.find(d => d.id === deviceId);

    if (!targetDevice) {
      throw new Error('Device not found');
    }

    this.server = await targetDevice.gatt?.connect();

    if (!this.server) {
      throw new Error('Failed to connect to GATT server');
    }

    this.device = {
      id: targetDevice.id,
      name: targetDevice.name || 'Unknown',
      type: this.detectDeviceType(targetDevice.name),
      connected: true,
      services: [],
    };

    // 监听断开事件
    targetDevice.addEventListener('gattserverdisconnected', () => {
      this.handleDisconnect();
    });

    // 发现服务
    await this.discoverServices();
  }

  // 发现服务
  private async discoverServices(): Promise<void> {
    if (!this.server) return;

    const services = await this.server.getPrimaryServices();

    for (const service of services) {
      const characteristics = await service.getCharacteristics();
      const serviceData: BluetoothService = {
        uuid: service.uuid,
        primary: true,
        characteristics: characteristics.map(c => ({
          uuid: c.uuid,
          properties: [],
        })),
      };

      this.device?.services.push(serviceData);
    }
  }

  // 断开连接
  async disconnect(): Promise<void> {
    if (this.server && this.device) {
      await this.server.disconnect();
      this.device.connected = false;
    }
  }

  // 处理断开
  private async handleDisconnect(): Promise<void> {
    if (this.device) {
      this.device.connected = false;
    }

    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      try {
        await this.connect(this.device?.id ?? '');
      } catch (error) {
        console.error('Reconnect failed:', error);
      }
    } else {
      this.reconnectAttempts = 0;
    }
  }

  // 检测设备类型
  private detectDeviceType(name: string): DeviceType {
    const lowerName = name.toLowerCase();

    if (lowerName.includes('band') || lowerName.includes('手环')) {
      return DeviceType.HEALTH_BAND;
    } else if (lowerName.includes('scale') || lowerName.includes('体重')) {
      return DeviceType.SMART_SCALE;
    } else if (lowerName.includes('bp') || lowerName.includes('血压')) {
      return DeviceType.BLOOD_PRESSURE;
    } else if (lowerName.includes('hailan') || lowerName.includes('海蓝')) {
      return DeviceType.SMART_HARDWARE;
    } else if (lowerName.includes('sensor') || lowerName.includes('传感器')) {
      return DeviceType.SENSOR;
    } else if (lowerName.includes('wearable') || lowerName.includes('可穿戴')) {
      return DeviceType.WEARABLE;
    }

    return DeviceType.SMART_HARDWARE;
  }
}
```

##### 3.2.2 数据读写

```typescript
// src/iot/bluetooth/data.ts
export class BluetoothDataHandler {
  private manager: BluetoothManager;

  constructor(manager: BluetoothManager) {
    this.manager = manager;
  }

  // 读取特征值
  async readCharacteristic(
    serviceUuid: string,
    characteristicUuid: string
  ): Promise<DataView | undefined> {
    const server = this.manager.getServer();
    if (!server) throw new Error('Not connected');

    const service = await server.getPrimaryService(serviceUuid);
    const characteristic = await service.getCharacteristic(characteristicUuid);

    return await characteristic.readValue();
  }

  // 写入特征值
  async writeCharacteristic(
    serviceUuid: string,
    characteristicUuid: string,
    value: BufferSource
  ): Promise<void> {
    const server = this.manager.getServer();
    if (!server) throw new Error('Not connected');

    const service = await server.getPrimaryService(serviceUuid);
    const characteristic = await service.getCharacteristic(characteristicUuid);

    await characteristic.writeValue(value);
  }

  // 订阅通知
  async subscribeToNotifications(
    serviceUuid: string,
    characteristicUuid: string,
    callback: (value: DataView) => void
  ): Promise<void> {
    const server = this.manager.getServer();
    if (!server) throw new Error('Not connected');

    const service = await server.getPrimaryService(serviceUuid);
    const characteristic = await service.getCharacteristic(characteristicUuid);

    await characteristic.startNotifications();
    characteristic.addEventListener('characteristicvaluechanged', (event) => {
      const value = (event.target as BluetoothRemoteGATTCharacteristic).value;
      if (value) callback(value);
    });
  }

  // 取消订阅
  async unsubscribeFromNotifications(
    serviceUuid: string,
    characteristicUuid: string
  ): Promise<void> {
    const server = this.manager.getServer();
    if (!server) throw new Error('Not connected');

    const service = await server.getPrimaryService(serviceUuid);
    const characteristic = await service.getCharacteristic(characteristicUuid);

    await characteristic.stopNotifications();
  }

  // 解析心率数据
  parseHeartRateData(data: DataView): { heartRate: number; contactDetected: boolean } {
    const flags = data.getUint8(0);
    const is16Bit = (flags & 0x1) === 1;
    const contactDetected = (flags & 0x6) !== 0;
    const sensorContactSupported = (flags & 0x4) !== 0;
    let energyExpendedPresent = (flags & 0x8) !== 0;
    let rrIntervalsPresent = (flags & 0x10) !== 0;

    let heartRate: number;
    if (is16Bit) {
      heartRate = data.getUint16(1, true);
    } else {
      heartRate = data.getUint8(1);
    }

    return { heartRate, contactDetected };
  }

  // 解析血压数据
  parseBloodPressureData(data: DataView): {
    systolic: number;
    diastolic: number;
    meanArterialPressure: number;
    unit: 'mmHg' | 'kPa';
  } {
    const flags = data.getUint8(0);
    const isKPa = (flags & 0x1) === 1;
    const timestampPresent = (flags & 0x2) === 0;
    const pulseRatePresent = (flags & 0x4) !== 0;

    let offset = 1;

    const systolic = data.getFloat16(offset, true);
    offset += 2;
    const diastolic = data.getFloat16(offset, true);
    offset += 2;
    const meanArterialPressure = data.getFloat16(offset, true);

    return {
      systolic,
      diastolic,
      meanArterialPressure,
      unit: isKPa ? 'kPa' : 'mmHg',
    };
  }

  // 解析电池电量
  parseBatteryLevel(data: DataView): number {
    return data.getUint8(0);
  }
}
```

#### 3.3 设备管理

##### 3.3.1 设备注册与绑定

```typescript
// src/iot/device/manager.ts
export interface DeviceInfo {
  deviceId: string;
  userId: string;
  name: string;
  type: DeviceType;
  model: string;
  firmwareVersion: string;
  macAddress?: string;
  bindingDate: Date;
  lastConnected: Date;
  status: 'online' | 'offline' | 'error';
}

export class DeviceManager {
  // 注册设备
  async registerDevice(device: {
    deviceId: string;
    userId: string;
    name: string;
    type: DeviceType;
    model: string;
    firmwareVersion: string;
  }): Promise<DeviceInfo> {
    const response = await fetch('/api/iot/devices', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(device),
    });

    if (!response.ok) {
      throw new Error('Failed to register device');
    }

    return await response.json();
  }

  // 绑定设备到用户
  async bindDevice(deviceId: string, userId: string): Promise<void> {
    await fetch(`/api/iot/devices/${deviceId}/bind`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId }),
    });
  }

  // 解绑设备
  async unbindDevice(deviceId: string): Promise<void> {
    await fetch(`/api/iot/devices/${deviceId}/unbind`, {
      method: 'POST',
    });
  }

  // 获取用户设备列表
  async getUserDevices(userId: string): Promise<DeviceInfo[]> {
    const response = await fetch(`/api/iot/users/${userId}/devices`);
    return await response.json();
  }

  // 获取设备详情
  async getDevice(deviceId: string): Promise<DeviceInfo> {
    const response = await fetch(`/api/iot/devices/${deviceId}`);
    return await response.json();
  }

  // 更新设备信息
  async updateDevice(
    deviceId: string,
    updates: Partial<DeviceInfo>
  ): Promise<DeviceInfo> {
    const response = await fetch(`/api/iot/devices/${deviceId}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates),
    });

    return await response.json();
  }

  // 删除设备
  async deleteDevice(deviceId: string): Promise<void> {
    await fetch(`/api/iot/devices/${deviceId}`, {
      method: 'DELETE',
    });
  }

  // 更新设备状态
  async updateDeviceStatus(
    deviceId: string,
    status: 'online' | 'offline' | 'error'
  ): Promise<void> {
    await fetch(`/api/iot/devices/${deviceId}/status`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ status }),
    });
  }
}
```

##### 3.3.2 设备数据同步

```typescript
// src/iot/device/sync.ts
export interface DeviceData {
  deviceId: string;
  timestamp: number;
  type: string;
  data: Record<string, any>;
}

export class DeviceDataSync {
  private offlineQueue: DeviceData[] = [];
  private syncInProgress = false;

  // 上报设备数据
  async reportData(data: DeviceData): Promise<void> {
    try {
      const response = await fetch('/api/iot/data', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        throw new Error('Failed to report data');
      }
    } catch (error) {
      // 离线时加入队列
      this.offlineQueue.push(data);
      await this.saveOfflineQueue();
    }
  }

  // 批量上报
  async reportBatch(dataList: DeviceData[]): Promise<void> {
    const response = await fetch('/api/iot/data/batch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data: dataList }),
    });

    if (!response.ok) {
      throw new Error('Failed to report batch data');
    }
  }

  // 同步离线数据
  async syncOfflineData(): Promise<void> {
    if (this.syncInProgress || this.offlineQueue.length === 0) {
      return;
    }

    this.syncInProgress = true;

    try {
      const batchSize = 50;
      while (this.offlineQueue.length > 0) {
        const batch = this.offlineQueue.splice(0, batchSize);
        await this.reportBatch(batch);
      }

      await this.clearOfflineQueue();
    } catch (error) {
      console.error('Sync failed:', error);
      // 将数据放回队列
      await this.saveOfflineQueue();
    } finally {
      this.syncInProgress = false;
    }
  }

  // 保存离线队列
  private async saveOfflineQueue(): Promise<void> {
    // 使用IndexedDB存储离线数据
    const db = await this.getDB();
    const tx = db.transaction(['offlineQueue'], 'readwrite');
    const store = tx.objectStore('offlineQueue');

    await store.clear();
    for (const data of this.offlineQueue) {
      await store.add(data);
    }
  }

  // 加载离线队列
  private async loadOfflineQueue(): Promise<void> {
    const db = await this.getDB();
    const tx = db.transaction(['offlineQueue'], 'readonly');
    const store = tx.objectStore('offlineQueue');

    this.offlineQueue = await store.getAll();
  }

  // 清空离线队列
  private async clearOfflineQueue(): Promise<void> {
    const db = await this.getDB();
    const tx = db.transaction(['offlineQueue'], 'readwrite');
    await tx.objectStore('offlineQueue').clear();
  }

  private async getDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('HaiLanIoT', 1);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains('offlineQueue')) {
          db.createObjectStore('offlineQueue', { autoIncrement: true });
        }
      };
    });
  }
}
```

#### 3.4 远程控制

##### 3.4.1 指令下发

```typescript
// src/iot/control/command.ts
export interface DeviceCommand {
  id: string;
  deviceId: string;
  type: CommandType;
  payload: any;
  status: 'pending' | 'delivered' | 'executed' | 'failed';
  createdAt: Date;
  executedAt?: Date;
}

export enum CommandType {
  START = 'start',
  STOP = 'stop',
  PAUSE = 'pause',
  RESUME = 'resume',
  SET_MODE = 'set_mode',
  SET_INTENSITY = 'set_intensity',
  SET_DURATION = 'set_duration',
  GET_STATUS = 'get_status',
  GET_DATA = 'get_data',
  UPDATE_FIRMWARE = 'update_firmware',
  RESET = 'reset',
}

export class DeviceCommandService {
  // 发送指令
  async sendCommand(command: {
    deviceId: string;
    type: CommandType;
    payload: any;
  }): Promise<DeviceCommand> {
    const response = await fetch('/api/iot/commands', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(command),
    });

    if (!response.ok) {
      throw new Error('Failed to send command');
    }

    return await response.json();
  }

  // 获取指令状态
  async getCommandStatus(commandId: string): Promise<DeviceCommand> {
    const response = await fetch(`/api/iot/commands/${commandId}`);
    return await response.json();
  }

  // 获取设备指令历史
  async getDeviceCommands(
    deviceId: string,
    limit: number = 50
  ): Promise<DeviceCommand[]> {
    const response = await fetch(
      `/api/iot/devices/${deviceId}/commands?limit=${limit}`
    );
    return await response.json();
  }

  // 取消待执行指令
  async cancelCommand(commandId: string): Promise<void> {
    await fetch(`/api/iot/commands/${commandId}/cancel`, {
      method: 'POST',
    });
  }
}
```

#### 3.5 固件升级

##### 3.5.1 OTA升级管理

```typescript
// src/iot/ota/manager.ts
export interface FirmwareVersion {
  version: string;
  deviceType: DeviceType;
  fileUrl: string;
  fileSize: number;
  checksum: string;
  releaseDate: Date;
  changelog: string;
  mandatory: boolean;
}

export class OTAManager {
  // 检查更新
  async checkUpdate(deviceType: DeviceType, currentVersion: string): Promise<FirmwareVersion | null> {
    const response = await fetch(
      `/api/iot/firmware/check?deviceType=${deviceType}&version=${currentVersion}`
    );

    if (response.status === 404) {
      return null;
    }

    return await response.json();
  }

  // 下载固件
  async downloadFirmware(url: string): Promise<ArrayBuffer> {
    const response = await fetch(url);
    return await response.arrayBuffer();
  }

  // 验证校验和
  async verifyChecksum(data: ArrayBuffer, expectedChecksum: string): Promise<boolean> {
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

    return hashHex === expectedChecksum;
  }

  // 执行升级
  async performUpgrade(
    deviceManager: BluetoothManager,
    firmwareData: ArrayBuffer
  ): Promise<void> {
    // 通过BLE传输固件数据
    const CHUNK_SIZE = 512;
    const totalChunks = Math.ceil(firmwareData.byteLength / CHUNK_SIZE);

    for (let i = 0; i < totalChunks; i++) {
      const start = i * CHUNK_SIZE;
      const end = Math.min(start + CHUNK_SIZE, firmwareData.byteLength);
      const chunk = firmwareData.slice(start, end);

      await deviceManager.writeCharacteristic(
        SERVICE_UUIDS.HAILAN_SERVICE,
        CHARACTERISTIC_UUIDS.HAILAN_DATA,
        chunk
      );

      // 报告进度
      const progress = Math.round(((i + 1) / totalChunks) * 100);
      await this.reportUpgradeProgress(progress);
    }
  }

  private async reportUpgradeProgress(progress: number): Promise<void> {
    await fetch('/api/iot/ota/progress', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ progress }),
    });
  }
}
```

### 4. 数据存储

#### 4.1 设备数据表

```sql
-- IoT设备表
CREATE TABLE iot_devices (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  device_id VARCHAR(255) UNIQUE NOT NULL,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  name VARCHAR(100) NOT NULL,
  type VARCHAR(50) NOT NULL,
  model VARCHAR(100),
  firmware_version VARCHAR(50),
  mac_address VARCHAR(17),
  binding_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_connected TIMESTAMP WITH TIME ZONE,
  status VARCHAR(20) DEFAULT 'offline',
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 设备数据表
CREATE TABLE iot_device_data (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  device_id VARCHAR(255) NOT NULL,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  data_type VARCHAR(50) NOT NULL,
  data JSONB NOT NULL,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  uploaded BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 设备指令表
CREATE TABLE iot_device_commands (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  device_id VARCHAR(255) NOT NULL,
  command_type VARCHAR(50) NOT NULL,
  payload JSONB NOT NULL,
  status VARCHAR(20) DEFAULT 'pending',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  executed_at TIMESTAMP WITH TIME ZONE,
  result JSONB
);

-- 固件版本表
CREATE TABLE iot_firmware_versions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  device_type VARCHAR(50) NOT NULL,
  version VARCHAR(50) NOT NULL,
  file_url TEXT NOT NULL,
  file_size BIGINT NOT NULL,
  checksum VARCHAR(64) NOT NULL,
  release_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  changelog TEXT,
  mandatory BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(device_type, version)
);

-- 索引
CREATE INDEX idx_iot_devices_user_id ON iot_devices(user_id);
CREATE INDEX idx_iot_devices_device_id ON iot_devices(device_id);
CREATE INDEX idx_iot_device_data_device_id ON iot_device_data(device_id);
CREATE INDEX idx_iot_device_data_timestamp ON iot_device_data(timestamp);
CREATE INDEX idx_iot_device_commands_device_id ON iot_device_commands(device_id);
```

### 5. 安全考虑

#### 5.1 设备认证

```typescript
// 设备配对密钥生成
export async function generateDeviceKey(): Promise<{
  privateKey: string;
  publicKey: string;
}> {
  const keyPair = await crypto.subtle.generateKey(
    {
      name: 'ECDH',
      namedCurve: 'P-256',
    },
    true,
    ['deriveBits', 'deriveKey']
  );

  const publicKey = await crypto.subtle.exportKey(
    'spki',
    keyPair.publicKey
  );

  const privateKey = await crypto.subtle.exportKey(
    'pkcs8',
    keyPair.privateKey
  );

  return {
    privateKey: arrayBufferToBase64(privateKey),
    publicKey: arrayBufferToBase64(publicKey),
  };
}

// 设备认证
export async function authenticateDevice(
  deviceId: string,
  signature: string,
  challenge: string
): Promise<boolean> {
  const response = await fetch('/api/iot/devices/authenticate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ deviceId, signature, challenge }),
  });

  const result = await response.json();
  return result.authenticated;
}
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
