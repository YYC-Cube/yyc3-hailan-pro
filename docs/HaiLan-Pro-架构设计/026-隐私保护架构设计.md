---
@file: 026-隐私保护架构设计.md
@description: HaiLan Pro 隐私保护专项架构设计，包含数据加密、脱敏、隐私模式、伪装机制等
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-02-03
@status: published
@tags: [架构设计],[隐私架构],[隐私保护]
---

> ***YanYuCloudCube***
> 言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> 万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 026 隐私保护架构设计

## 概述

本文档详细描述HaiLan Pro项目的隐私保护架构设计，阐述多级隐私保护体系，包括隐私等级、数据脱敏、隐私模式、伪装机制、零知识证明等核心隐私保护能力，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景

HaiLan Pro 作为医疗级私密健康管理系统，隐私保护是产品核心竞争力。系统需要为用户提供从标准浏览到极致隐私的多层次保护体验。

#### 1.2 隐私保护目标

- **用户掌控**：用户完全掌控数据访问权限
- **分级保护**：多级隐私模式适应不同场景
- **数据加密**：敏感数据端到端加密
- **零知识证明**：验证数据真实性无需暴露内容
- **伪装机制**：在公共场合保护用户隐私

### 2. 隐私等级体系

#### 2.1 隐私等级定义

```typescript
// 隐私等级枚举
enum PrivacyLevel {
  STANDARD = 'STANDARD',     // 标准模式
  STEALTH = 'STEALTH',       // 隐身模式
  DISGUISE = 'DISGUISE'      // 伪装模式
}

// 隐私等级配置
interface PrivacyLevelConfig {
  level: PrivacyLevel;
  name: string;
  description: string;
  features: {
    // 显示控制
    blurSensitive: boolean;      // 模糊敏感内容
    maskData: boolean;           // 遮罩数据
    hideImages: boolean;         // 隐藏图片
    // 交互控制
    requireAuth: boolean;        // 需要身份验证
    stealthMode: boolean;        // 隐身模式
    camouflage: boolean;         // 伪装界面
    // 数据控制
    encryptAll: boolean;         // 加密所有数据
    disableCache: boolean;       // 禁用缓存
    autoLogout: boolean;         // 自动登出
  };
}

// 隐私等级配置详情
const privacyConfigs: Record<PrivacyLevel, PrivacyLevelConfig> = {
  [PrivacyLevel.STANDARD]: {
    level: PrivacyLevel.STANDARD,
    name: '标准模式',
    description: '常规浏览体验，适合私人环境使用',
    features: {
      blurSensitive: false,
      maskData: false,
      hideImages: false,
      requireAuth: false,
      stealthMode: false,
      camouflage: false,
      encryptAll: false,
      disableCache: false,
      autoLogout: false
    }
  },
  [PrivacyLevel.STEALTH]: {
    level: PrivacyLevel.STEALTH,
    name: '隐身模式',
    description: '启用隐私遮罩，适合公共场合使用',
    features: {
      blurSensitive: true,
      maskData: true,
      hideImages: false,
      requireAuth: true,
      stealthMode: true,
      camouflage: false,
      encryptAll: true,
      disableCache: true,
      autoLogout: true
    }
  },
  [PrivacyLevel.DISGUISE]: {
    level: PrivacyLevel.DISGUISE,
    name: '伪装模式',
    description: '伪装界面展示，极端隐私保护',
    features: {
      blurSensitive: true,
      maskData: true,
      hideImages: true,
      requireAuth: true,
      stealthMode: true,
      camouflage: true,
      encryptAll: true,
      disableCache: true,
      autoLogout: true
    }
  }
};
```

#### 2.2 隐私等级切换流程

```
[用户触发隐私设置]
        ↓
[PrivacyContext 更新状态]
        ↓
[应用隐私配置]
        ├── UI 组件响应（模糊/遮罩）
        ├── 数据请求调整（加密/脱敏）
        ├── 缓存策略变更（禁用/清除）
        └── 自动登出启用（超时机制）
        ↓
[记录隐私变更日志]
        ↓
[通知用户当前隐私状态]
```

### 3. 核心隐私组件

#### 3.1 CamouflageScreen 伪装屏组件

```typescript
// 伪装屏组件
interface CamouflageScreenProps {
  trigger: 'manual' | 'shake' | 'proximity';
  camouflageType: 'news' | 'weather' | 'calculator' | 'notes';
}

const camouflageThemes = {
  news: {
    title: '今日头条',
    content: '科技新闻动态',
    icon: 'Newspaper'
  },
  weather: {
    title: '天气',
    content: '今日天气：晴 25°C',
    icon: 'CloudSun'
  },
  calculator: {
    title: '计算器',
    content: '0 + 0 =',
    icon: 'Calculator'
  },
  notes: {
    title: '备忘录',
    content: '今日待办事项',
    icon: 'FileText'
  }
};
```

**组件实现：**

```tsx
// src/app/components/privacy/CamouflageScreen.tsx
import React, { useState } from 'react';
import { usePrivacy } from '../../context/PrivacyContext';

export function CamouflageScreen() {
  const { privacyLevel, camouflageType } = usePrivacy();
  const [isActive, setIsActive] = useState(false);

  // 仅在隐私模式下启用
  if (privacyLevel !== 'DISGUISE' || !isActive) {
    return null;
  }

  const theme = camouflageThemes[camouflageType];

  return (
    <div className="fixed inset-0 z-50 bg-background flex items-center justify-center">
      <div className="text-center">
        <div className="text-6xl mb-4">{theme.icon}</div>
        <h1 className="text-2xl font-bold mb-2">{theme.title}</h1>
        <p className="text-muted-foreground">{theme.content}</p>
      </div>
    </div>
  );
}
```

#### 3.2 PrivacyBlur 隐私模糊组件

```tsx
// src/app/components/privacy/PrivacyBlur.tsx
import React from 'react';
import { usePrivacy } from '../../context/PrivacyContext';

interface PrivacyBlurProps {
  children: React.ReactNode;
  blurLevel?: 1 | 2 | 3 | 4 | 5;
}

export function PrivacyBlur({ children, blurLevel = 3 }: PrivacyBlurProps) {
  const { privacyLevel } = usePrivacy();

  // 隐身模式和伪装模式启用模糊
  const shouldBlur = privacyLevel === 'STEALTH' || privacyLevel === 'DISGUISE';

  return (
    <div
      className={shouldBlur ? 'blur-sm transition-all duration-300' : ''}
      style={{
        filter: shouldBlur ? `blur(${blurLevel * 2}px)` : 'none'
      }}
    >
      {children}
    </div>
  );
}
```

#### 3.3 PrivacyContext 隐私状态管理

```typescript
// src/app/context/PrivacyContext.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';

interface PrivacyContextType {
  privacyLevel: PrivacyLevel;
  camouflageType: CamouflageType;
  setPrivacyLevel: (level: PrivacyLevel) => void;
  setCamouflageType: (type: CamouflageType) => void;
  isPrivacyMode: boolean;
}

const PrivacyContext = createContext<PrivacyContextType | undefined>(undefined);

export function PrivacyProvider({ children }: { children: React.ReactNode }) {
  const [privacyLevel, setPrivacyLevelState] = useState<PrivacyLevel>(PrivacyLevel.STANDARD);
  const [camouflageType, setCamouflageType] = useState<CamouflageType>('news');

  // 从本地存储恢复隐私设置
  useEffect(() => {
    const saved = localStorage.getItem('privacyLevel');
    if (saved && Object.values(PrivacyLevel).includes(saved as PrivacyLevel)) {
      setPrivacyLevelState(saved as PrivacyLevel);
    }
  }, []);

  const setPrivacyLevel = (level: PrivacyLevel) => {
    setPrivacyLevelState(level);
    localStorage.setItem('privacyLevel', level);

    // 记录隐私变更
    logPrivacyChange(level);
  };

  const isPrivacyMode = privacyLevel !== PrivacyLevel.STANDARD;

  return (
    <PrivacyContext.Provider
      value={{
        privacyLevel,
        camouflageType,
        setPrivacyLevel,
        setCamouflageType,
        isPrivacyMode
      }}
    >
      {children}
    </PrivacyContext.Provider>
  );
}

export function usePrivacy() {
  const context = useContext(PrivacyContext);
  if (!context) {
    throw new Error('usePrivacy must be used within PrivacyProvider');
  }
  return context;
}
```

### 4. 数据脱敏策略

#### 4.1 脱敏规则

```typescript
// 数据脱敏配置
interface MaskingRule {
  pattern: RegExp;
  mask: string | ((match: string) => string);
  description: string;
}

const maskingRules: Record<string, MaskingRule> = {
  // 邮箱脱敏
  email: {
    pattern: /([^@]{1,2})[^@]*(@.+)/,
    mask: (match) => {
      const [, prefix, domain] = match;
      return prefix[0] + '***' + domain;
    },
    description: '邮箱地址脱敏：保留首字符和域名'
  },
  // 手机号脱敏
  phone: {
    pattern: /(\d{3})\d{4}(\d{4})/,
    mask: '$1****$2',
    description: '手机号脱敏：保留前3位和后4位'
  },
  // 地址脱敏
  address: {
    pattern: /(.{6}).*/,
    mask: '$1***',
    description: '地址脱敏：仅显示前6个字符'
  },
  // 姓名脱敏
  name: {
    pattern: /(.).*/,
    mask: '$1**',
    description: '姓名脱敏：仅显示姓氏首字符'
  },
  // 身份证号脱敏
  idCard: {
    pattern: /(\d{6})\d{8}(\d{4})/,
    mask: '$1********$2',
    description: '身份证号脱敏：保留前6位和后4位'
  }
};

// 脱敏函数
function maskData(data: string, type: keyof typeof maskingRules): string {
  const rule = maskingRules[type];
  if (!rule) return data;

  return data.replace(rule.pattern, rule.mask as string);
}
```

#### 4.2 脱敏组件

```tsx
// 数据脱敏显示组件
interface MaskedTextProps {
  data: string;
  type: keyof typeof maskingRules;
  showOnHover?: boolean;
}

export function MaskedText({ data, type, showOnHover = true }: MaskedTextProps) {
  const { privacyLevel } = usePrivacy();
  const [isRevealed, setIsRevealed] = useState(false);

  // 标准模式直接显示，其他模式脱敏
  const shouldMask = privacyLevel !== PrivacyLevel.STANDARD;
  const maskedData = shouldMask ? maskData(data, type) : data;

  return (
    <span
      className="font-mono"
      onMouseEnter={() => showOnHover && setIsRevealed(true)}
      onMouseLeave={() => setIsRevealed(false)}
    >
      {shouldMask && !isRevealed ? maskedData : data}
    </span>
  );
}
```

### 5. 零知识证明 (ZK-Proof)

#### 5.1 ZK-Proof 架构

```
┌─────────────────────────────────────────────────────────────┐
│                    数据所有者 (Prover)                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │  敏感数据    │  │  承诺方案    │  │  证明生成    │          │
│  │  Secret     │  │ Commitment  │  │  Prover     │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      ZK-Proof 验证层                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │  证明验证    │  │  验证密钥    │  │  验证合约    │          │
│  │  Verifier   │  │  VK/Proof   │  │  Contract   │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    数据请求者 (Verifier)                      │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │  验证结果    │  │  公开输入    │  │  访问授权    │          │
│  │  Result     │  │  Public In  │  │  Access     │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

#### 5.2 ZK-Proof 实现

```typescript
// ZK-Proof 服务
class ZKProofService {
  // 生成零知识证明
  async generateProof(
    secretData: any,
    publicInputs: any,
    provingKey: Uint8Array
  ): Promise<{
    proof: Uint8Array;
    publicInputs: Uint8Array;
  }> {
    // 使用 circom 或 snarkjs 生成证明
    // 这里简化实现
    const commitment = this.hashData(secretData);
    const proof = await this.createZKSnarkProof(secretData, publicInputs);

    return {
      proof,
      publicInputs: new TextEncoder().encode(JSON.stringify(publicInputs))
    };
  }

  // 验证零知识证明
  async verifyProof(
    proof: Uint8Array,
    publicInputs: Uint8Array,
    verificationKey: Uint8Array
  ): Promise<boolean> {
    // 使用验证密钥验证证明
    return this.verifyZKSnarkProof(proof, publicInputs, verificationKey);
  }

  // 数据承诺（哈希）
  private hashData(data: any): string {
    const str = JSON.stringify(data);
    return this.sha256(str);
  }

  private sha256(data: string): string {
    // 实现 SHA-256 哈希
    return crypto.subtle.digest('SHA-256', new TextEncoder().encode(data))
      .then(hash => Array.from(new Uint8Array(hash))
        .map(b => b.toString(16).padStart(2, '0'))
        .join(''));
  }
}
```

#### 5.3 健康数据 ZK-Proof 验证

```typescript
// 健康数据零知识证明
interface HealthDataZKProof {
  // 数据类型
  dataType: 'heartRate' | 'bloodPressure' | 'weight' | 'sleep';
  // 证明内容（不暴露具体数值）
  proof: {
    withinRange: boolean;        // 是否在正常范围
    meetsGoal: boolean;          // 是否达到目标
    trend: 'improving' | 'stable' | 'declining';  // 趋势
    timestamp: number;           // 数据时间戳
  };
  // 验证结果
  verified: boolean;
}

// 健康数据验证服务
class HealthDataZKService extends ZKProofService {
  async verifyHealthDataAccess(
    userId: string,
    dataId: string,
    proof: HealthDataZKProof
  ): Promise<boolean> {
    // 1. 验证证明有效性
    const isValid = await this.verifyProof(
      proof.proof as any,
      new TextEncoder().encode(JSON.stringify(proof)),
      this.getVerificationKey()
    );

    if (!isValid) return false;

    // 2. 验证用户权限
    const hasPermission = await this.checkUserPermission(userId, dataId);
    if (!hasPermission) return false;

    // 3. 记录验证日志
    await this.logVerification(userId, dataId, proof);

    return true;
  }
}
```

### 6. 伪装发货机制

#### 6.1 伪装发货策略

```typescript
// 伪装发货配置
interface DisguiseShippingConfig {
  // 发货包装
  packaging: {
    outerBox: string;              // 外包装描述
    label: string;                  // 外包装标签
    returnAddress: string;          // 回寄地址
  };
  // 物流信息
  logistics: {
    companyName: string;           // 物流公司名称
    trackingUrl: string;            // 查询网址
    privacyNote: string;            // 隐私说明
  };
  // 收件信息
  recipient: {
    allowAnonymous: boolean;       // 允许匿名收货
    usePickupPoint: boolean;        // 使用自提点
    pickupLocation: string;         // 自提点位置
  };
}

// 伪装发货配置示例
const disguiseConfig: DisguiseShippingConfig = {
  packaging: {
    outerBox: '通用礼品包装盒',
    label: '电商商品',
    returnAddress: 'XX市XX区XX路XX号'
  },
  logistics: {
    companyName: 'XX物流',
    trackingUrl: 'https://track.example.com',
    privacyNote: '您的隐私对我们很重要'
  },
  recipient: {
    allowAnonymous: true,
    usePickupPoint: true,
    pickupLocation: '丰巢快递柜'
  }
};
```

#### 6.2 订单隐私模式

```sql
-- 订单隐私模式
CREATE TYPE order_privacy_mode AS ENUM (
  'NORMAL',           -- 正常模式：显示完整信息
  'ENCRYPTED_ADDR',   -- 加密地址：地址加密存储
  'ANONYMOUS'         -- 匿名模式：不显示任何个人信息
);

-- 订单表增加隐私模式字段
ALTER TABLE orders ADD COLUMN privacy_mode order_privacy_mode DEFAULT 'NORMAL';
```

```typescript
// 订单隐私处理
class OrderPrivacyService {
  // 创建匿名订单
  async createAnonymousOrder(items: OrderItem[]): Promise<string> {
    const orderNumber = this.generateOrderNumber();

    // 生成匿名用户 ID
    const anonymousUserId = this.generateAnonymousId();

    // 创建订单
    const { data, error } = await supabase
      .from('orders')
      .insert({
        user_id: anonymousUserId,
        order_number: orderNumber,
        privacy_mode: 'ANONYMOUS',
        items: JSON.stringify(items),
        status: 'PENDING'
      })
      .select()
      .single();

    if (error) throw error;

    return orderNumber;
  }

  // 生成匿名 ID
  private generateAnonymousId(): string {
    return `anon_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

### 7. 隐私设置界面

#### 7.1 隐私控制页面

```tsx
// src/app/pages/profile/PrivacyControlPage.tsx
import React from 'react';
import { usePrivacy } from '../../context/PrivacyContext';

export function PrivacyControlPage() {
  const {
    privacyLevel,
    camouflageType,
    setPrivacyLevel,
    setCamouflageType
  } = usePrivacy();

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6">隐私控制</h1>

      {/* 隐私等级选择 */}
      <div className="space-y-4">
        <h2 className="text-lg font-semibold">隐私等级</h2>
        <div className="grid grid-cols-3 gap-4">
          <button
            onClick={() => setPrivacyLevel('STANDARD')}
            className={`p-4 rounded-lg border ${
              privacyLevel === 'STANDARD'
                ? 'border-primary bg-primary/10'
                : 'border-border'
            }`}
          >
            <h3 className="font-semibold">标准模式</h3>
            <p className="text-sm text-muted-foreground">常规浏览体验</p>
          </button>

          <button
            onClick={() => setPrivacyLevel('STEALTH')}
            className={`p-4 rounded-lg border ${
              privacyLevel === 'STEALTH'
                ? 'border-primary bg-primary/10'
                : 'border-border'
            }`}
          >
            <h3 className="font-semibold">隐身模式</h3>
            <p className="text-sm text-muted-foreground">启用隐私遮罩</p>
          </button>

          <button
            onClick={() => setPrivacyLevel('DISGUISE')}
            className={`p-4 rounded-lg border ${
              privacyLevel === 'DISGUISE'
                ? 'border-primary bg-primary/10'
                : 'border-border'
            }`}
          >
            <h3 className="font-semibold">伪装模式</h3>
            <p className="text-sm text-muted-foreground">伪装界面展示</p>
          </button>
        </div>
      </div>

      {/* 伪装类型选择 */}
      <div className="space-y-4">
        <h2 className="text-lg font-semibold">伪装类型</h2>
        <div className="grid grid-cols-4 gap-4">
          {(['news', 'weather', 'calculator', 'notes'] as const).map((type) => (
            <button
              key={type}
              onClick={() => setCamouflageType(type)}
              className={`p-4 rounded-lg border ${
                camouflageType === type
                  ? 'border-primary bg-primary/10'
                  : 'border-border'
              }`}
            >
              {type}
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}
```

### 8. 隐私审计

#### 8.1 隐私事件日志

```sql
-- 隐私事件日志表
CREATE TABLE privacy_audit_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),

  -- 事件信息
  event_type VARCHAR(100) NOT NULL,
  event_description TEXT,

  -- 隐私设置
  old_privacy_level VARCHAR(20),
  new_privacy_level VARCHAR(20),

  -- 数据信息
  data_type VARCHAR(50),
  data_id UUID,
  access_granted BOOLEAN,

  -- 位置信息（IP 地址脱敏）
  ip_address_hash VARCHAR(64),

  -- 时间戳
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_privacy_audit_logs_user_id ON privacy_audit_logs(user_id);
CREATE INDEX idx_privacy_audit_logs_event_type ON privacy_audit_logs(event_type);
CREATE INDEX idx_privacy_audit_logs_created_at ON privacy_audit_logs(created_at DESC);
```

#### 8.2 隐私合规报告

```typescript
// 隐私合规报告生成器
class PrivacyComplianceReport {
  async generateReport(userId: string, startDate: Date, endDate: Date) {
    const report = {
      userId,
      reportPeriod: { startDate, endDate },

      // 数据访问统计
      dataAccess: {
        totalAccess: 0,
        byType: {} as Record<string, number>,
        byResult: { granted: 0, denied: 0 }
      },

      // 隐私设置变更
      privacyChanges: {
        totalChanges: 0,
        byLevel: {} as Record<string, number>
      },

      // 数据共享记录
      dataSharing: {
        thirdPartyShares: 0,
        withConsent: 0,
        withoutConsent: 0
      },

      // 合规性评估
      compliance: {
        gdpr: true,
        pipl: true,
        score: 100
      }
    };

    // 查询审计日志
    const { data: logs } = await supabase
      .from('privacy_audit_logs')
      .select('*')
      .eq('user_id', userId)
      .gte('created_at', startDate.toISOString())
      .lte('created_at', endDate.toISOString());

    // 统计分析
    logs?.forEach(log => {
      report.dataAccess.totalAccess++;
      report.dataAccess.byResult[log.access_granted ? 'granted' : 'denied']++;

      if (log.event_type === 'privacy.level.changed') {
        report.privacyChanges.totalChanges++;
        report.privacyChanges.byLevel[log.new_privacy_level] =
          (report.privacyChanges.byLevel[log.new_privacy_level] || 0) + 1;
      }
    });

    return report;
  }
}
```

### 9. 附录

#### 9.1 隐私保护最佳实践

1. **最小化数据收集**：只收集必要的数据
2. **默认隐私保护**：默认启用隐私保护功能
3. **用户透明告知**：清晰告知数据使用目的
4. **用户授权控制**：用户可随时撤回授权
5. **数据加密存储**：敏感数据加密后存储
6. **定期安全审计**：定期检查隐私保护措施
7. **隐私影响评估**：新功能进行隐私影响评估

#### 9.2 参考文档

- [021-系统架构设计文档.md](./021-系统架构设计文档.md) - 系统架构
- [025-安全架构设计文档.md](./025-安全架构设计文档.md) - 安全架构

---

<div align="center">

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」

</div>
