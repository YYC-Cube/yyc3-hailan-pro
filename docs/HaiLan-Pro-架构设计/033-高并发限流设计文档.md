---
@file: 033-高并发限流设计文档.md
@description: HaiLan Pro 高并发场景下的限流、熔断、降级方案，保障系统高可用与稳定性
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-架构设计],[]
---

> ***YanYuCloudCube***
> 言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> 万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 033 高并发限流设计文档

## 概述

本文档详细描述HaiLan Pro的高并发限流架构设计，包括限流、熔断、降级等核心能力，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 高并发挑战
- **流量突增**：营销活动、热点事件带来的流量激增
- **资源限制**：数据库连接、API调用配额有限
- **恶意攻击**：DDoS攻击、恶意爬虫
- **雪崩效应**：单个服务故障导致整个系统崩溃

#### 1.3 文档目标
- 规范高并发限流相关的业务标准与技术落地要求
- 定义限流、熔断、降级的技术方案
- 保障系统高可用和稳定性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：限流失败时优雅降级，保障核心功能
- **高性能**：高效的限流算法，对性能影响最小
- **高安全性**：防止恶意攻击，保护系统资源
- **高扩展性**：支持动态调整限流策略
- **高可维护性**：可视化的限流监控与配置

#### 2.2 五标体系
- **标准化**：统一的限流规则和响应格式
- **规范化**：标准化的限流、熔断、降级流程
- **自动化**：自动化的限流策略调整
- **智能化**：智能流量预测和动态限流
- **可视化**：限流指标可视化监控

#### 2.3 五化架构
- **流程化**：标准化的限流处理流程
- **文档化**：完善的限流配置文档
- **工具化**：自动化的限流测试工具
- **数字化**：限流效果量化指标
- **生态化**：兼容各类限流算法和策略

### 3. 高并发限流架构设计

#### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    HaiLan Pro 限流保护架构                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    请求接入层                              │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │CDN WAF   │  │负载均衡   │  │API网关    │  │网关限流 │ │   │
│  │  │DDoS防护  │  │Nginx/LVS │  │Kong/APISIX│  │全局限流 │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    应用层保护                              │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │限流中间件 │  │熔断器     │  │降级处理器 │  │隔离舱   │ │   │
│  │  │RateLimit │  │CircuitBreaker│  │Fallback │  │Bulkhead│ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    限流算法层                              │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │令牌桶     │  │漏桶       │  │固定窗口   │  │滑动窗口 │ │   │
│  │  │Token Bucket│ │Leaky Bucket│ │Fixed Window│ │Sliding  │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    存储层                                 │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │Redis计数 │  │分布式锁   │  │状态存储   │  │监控数据 │ │   │
│  │  │Counter   │  │Lock      │  │State     │  │Metrics │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.2 限流策略

##### 3.2.1 令牌桶算法

```typescript
// src/rate-limiting/token-bucket.ts
export interface TokenBucketConfig {
  capacity: number;      // 桶容量
  refillRate: number;    // 填充速率（tokens/秒）
  refillInterval: number; // 填充间隔（毫秒）
}

export class TokenBucket {
  private tokens: number;
  private lastRefill: number;
  private config: TokenBucketConfig;

  constructor(config: TokenBucketConfig) {
    this.config = config;
    this.tokens = config.capacity;
    this.lastRefill = Date.now();
  }

  // 尝试消费token
  tryConsume(tokens: number = 1): boolean {
    this.refill();

    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true;
    }

    return false;
  }

  // 获取当前可用token数
  getAvailableTokens(): number {
    this.refill();
    return this.tokens;
  }

  // 填充token
  private refill(): void {
    const now = Date.now();
    const elapsed = now - this.lastRefill;
    const intervals = elapsed / this.config.refillInterval;

    if (intervals >= 1) {
      const tokensToAdd = Math.floor(intervals) * this.config.refillRate;
      this.tokens = Math.min(
        this.config.capacity,
        this.tokens + tokensToAdd
      );
      this.lastRefill = now;
    }
  }
}

// 分布式令牌桶（基于Redis）
export class DistributedTokenBucket {
  private redis: Redis;
  private key: string;
  private config: TokenBucketConfig;

  constructor(redis: Redis, key: string, config: TokenBucketConfig) {
    this.redis = redis;
    this.key = key;
    this.config = config;
  }

  async tryConsume(tokens: number = 1): Promise<boolean> {
    const script = `
      local key = KEYS[1]
      local capacity = tonumber(ARGV[1])
      local refillRate = tonumber(ARGV[2])
      local refillInterval = tonumber(ARGV[3])
      local tokens = tonumber(ARGV[4])
      local now = tonumber(ARGV[5])

      local bucket = redis.call('HMGET', key, 'tokens', 'lastRefill')
      local currentTokens = tonumber(bucket[1]) or capacity
      local lastRefill = tonumber(bucket[2]) or now

      -- 计算需要填充的token
      local elapsed = now - lastRefill
      local intervals = math.floor(elapsed / refillInterval)
      if intervals > 0 then
        local tokensToAdd = intervals * refillRate
        currentTokens = math.min(capacity, currentTokens + tokensToAdd)
        lastRefill = now
      end

      -- 尝试消费
      if currentTokens >= tokens then
        currentTokens = currentTokens - tokens
        redis.call('HMSET', key, 'tokens', currentTokens, 'lastRefill', lastRefill)
        redis.call('EXPIRE', key, refillInterval * 2)
        return 1
      else
        redis.call('HMSET', key, 'tokens', currentTokens, 'lastRefill', lastRefill)
        redis.call('EXPIRE', key, refillInterval * 2)
        return 0
      end
    `;

    const result = await this.redis.eval(
      script,
      1,
      this.key,
      this.config.capacity,
      this.config.refillRate,
      this.config.refillInterval,
      tokens,
      Date.now()
    );

    return result === 1;
  }

  async getAvailableTokens(): Promise<number> {
    const result = await this.redis.hmget(this.key, 'tokens', 'lastRefill');
    return parseInt(result[0] || '0');
  }
}
```

##### 3.2.2 滑动窗口限流

```typescript
// src/rate-limiting/sliding-window.ts
export interface SlidingWindowConfig {
  windowSize: number;    // 窗口大小（毫秒）
  maxRequests: number;   // 最大请求数
}

export class SlidingWindowRateLimiter {
  private redis: Redis;
  private config: SlidingWindowConfig;

  constructor(redis: Redis, config: SlidingWindowConfig) {
    this.redis = redis;
    this.config = config;
  }

  async isAllowed(key: string): Promise<boolean> {
    const now = Date.now();
    const windowStart = now - this.config.windowSize;

    // 使用有序集合存储请求时间戳
    const pipeline = this.redis.pipeline();

    // 移除窗口外的旧记录
    pipeline.zremrangebyscore(key, 0, windowStart);

    // 统计当前窗口内的请求数
    pipeline.zcard(key);

    // 添加当前请求
    pipeline.zadd(key, now, `${now}:${Math.random()}`);

    // 设置过期时间
    pipeline.expire(key, Math.ceil(this.config.windowSize / 1000) + 1);

    const results = await pipeline.exec();

    // results[1][1] 是当前窗口内的请求数
    const currentCount = results?.[1]?.[1] as number || 0;

    return currentCount < this.config.maxRequests;
  }

  async getCurrentCount(key: string): Promise<number> {
    const windowStart = Date.now() - this.config.windowSize;
    await this.redis.zremrangebyscore(key, 0, windowStart);
    return await this.redis.zcard(key);
  }

  async reset(key: string): Promise<void> {
    await this.redis.del(key);
  }
}
```

##### 3.2.3 多维度限流

```typescript
// src/rate-limiting/multi-dimensional.ts
export enum RateLimitDimension {
  IP = 'ip',                    // 按IP限流
  USER = 'user',                // 按用户限流
  API = 'api',                  // 按API限流
  TENANT = 'tenant',            // 按租户限流
  GLOBAL = 'global',            // 全局限流
}

export interface RateLimitRule {
  dimension: RateLimitDimension;
  key: string;
  limit: number;
  window: number;              // 时间窗口（毫秒）
  algorithm: 'token-bucket' | 'sliding-window' | 'fixed-window';
}

export class MultiDimensionalRateLimiter {
  private redis: Redis;
  private limiters: Map<RateLimitDimension, any>;

  constructor(redis: Redis) {
    this.redis = redis;
    this.limiters = new Map();
  }

  // 检查是否允许请求
  async checkAllowed(rules: RateLimitRule[]): Promise<{
    allowed: boolean;
    dimension?: RateLimitDimension;
    limit?: number;
    remaining?: number;
    resetAt?: number;
  }> {
    for (const rule of rules) {
      const limiter = this.getLimiter(rule);
      const allowed = await limiter.isAllowed(rule.key);

      if (!allowed) {
        return {
          allowed: false,
          dimension: rule.dimension,
          limit: rule.limit,
          remaining: 0,
          resetAt: Date.now() + rule.window,
        };
      }
    }

    return { allowed: true };
  }

  private getLimiter(rule: RateLimitRule) {
    if (!this.limiters.has(rule.dimension)) {
      let limiter;

      switch (rule.algorithm) {
        case 'sliding-window':
          limiter = new SlidingWindowRateLimiter(this.redis, {
            windowSize: rule.window,
            maxRequests: rule.limit,
          });
          break;
        case 'token-bucket':
          limiter = new DistributedTokenBucket(this.redis, rule.key, {
            capacity: rule.limit,
            refillRate: Math.ceil(rule.limit / (rule.window / 1000)),
            refillInterval: 1000,
          });
          break;
        default:
          limiter = new SlidingWindowRateLimiter(this.redis, {
            windowSize: rule.window,
            maxRequests: rule.limit,
          });
      }

      this.limiters.set(rule.dimension, limiter);
    }

    return this.limiters.get(rule.dimension)!;
  }
}
```

#### 3.3 熔断机制

##### 3.3.1 熔断器实现

```typescript
// src/circuit-breaker/breaker.ts
export enum CircuitState {
  CLOSED = 'closed',       // 正常状态
  OPEN = 'open',           // 熔断状态
  HALF_OPEN = 'half-open', // 半开状态
}

export interface CircuitBreakerConfig {
  failureThreshold: number;      // 失败阈值
  successThreshold: number;      // 成功阈值
  timeout: number;               // 熔断超时（毫秒）
  halfOpenMaxCalls: number;      // 半开状态最大调用数
  monitoringPeriod: number;      // 监控周期（毫秒）
}

export class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failureCount = 0;
  private successCount = 0;
  private lastFailureTime = 0;
  private halfOpenCallCount = 0;
  private config: CircuitBreakerConfig;

  constructor(config: CircuitBreakerConfig) {
    this.config = config;
  }

  // 执行请求
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === CircuitState.OPEN) {
      if (this.shouldAttemptReset()) {
        this.transitionToHalfOpen();
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    if (this.state === CircuitState.HALF_OPEN) {
      this.halfOpenCallCount++;
      if (this.halfOpenCallCount >= this.config.halfOpenMaxCalls) {
        this.transitionToClosed();
      }
    } else {
      this.failureCount = 0;
    }
  }

  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();

    if (this.failureCount >= this.config.failureThreshold) {
      this.transitionToOpen();
    }
  }

  private transitionToOpen(): void {
    this.state = CircuitState.OPEN;
    this.halfOpenCallCount = 0;
  }

  private transitionToHalfOpen(): void {
    this.state = CircuitState.HALF_OPEN;
    this.halfOpenCallCount = 0;
  }

  private transitionToClosed(): void {
    this.state = CircuitState.CLOSED;
    this.failureCount = 0;
    this.successCount = 0;
  }

  private shouldAttemptReset(): boolean {
    return Date.now() - this.lastFailureTime >= this.config.timeout;
  }

  getState(): CircuitState {
    return this.state;
  }

  getFailureCount(): number {
    return this.failureCount;
  }
}
```

##### 3.3.2 熔断器管理器

```typescript
// src/circuit-breaker/manager.ts
export class CircuitBreakerManager {
  private breakers = new Map<string, CircuitBreaker>();
  private defaultConfig: CircuitBreakerConfig = {
    failureThreshold: 5,
    successThreshold: 2,
    timeout: 60000,
    halfOpenMaxCalls: 3,
    monitoringPeriod: 10000,
  };

  getBreaker(name: string, config?: Partial<CircuitBreakerConfig>): CircuitBreaker {
    if (!this.breakers.has(name)) {
      const breaker = new CircuitBreaker({
        ...this.defaultConfig,
        ...config,
      });
      this.breakers.set(name, breaker);
    }

    return this.breakers.get(name)!;
  }

  async execute<T>(
    name: string,
    fn: () => Promise<T>,
    config?: Partial<CircuitBreakerConfig>
  ): Promise<T> {
    const breaker = this.getBreaker(name, config);
    return breaker.execute(fn);
  }

  getAllStates(): Record<string, CircuitState> {
    const states: Record<string, CircuitState> = {};

    for (const [name, breaker] of this.breakers.entries()) {
      states[name] = breaker.getState();
    }

    return states;
  }
}
```

#### 3.4 降级策略

##### 3.4.1 降级处理器

```typescript
// src/fallback/handler.ts
export type FallbackFunction<T> = () => T | Promise<T>;

export class FallbackHandler {
  private fallbacks = new Map<string, FallbackFunction<any>>();

  // 注册降级函数
  register<T>(key: string, fn: FallbackFunction<T>): void {
    this.fallbacks.set(key, fn);
  }

  // 执行降级
  async execute<T>(key: string, defaultValue?: T): Promise<T> {
    const fallback = this.fallbacks.get(key);

    if (fallback) {
      try {
        return await fallback();
      } catch (error) {
        console.error(`Fallback ${key} failed:`, error);
        return defaultValue as T;
      }
    }

    return defaultValue as T;
  }

  // 预定义降级策略
  static readonly PREDEFINED_FALLBACKS = {
    // 返回空数组
    EMPTY_ARRAY: async () => [],

    // 返回空对象
    EMPTY_OBJECT: async () => ({}),

    // 返回缓存数据
    CACHED_DATA: async <T>(key: string) => {
      // 从缓存获取
      return null as T;
    },

    // 返回默认值
    DEFAULT_VALUE: async <T>(value: T) => value,

    // 返回错误提示
    ERROR_MESSAGE: async (message: string) => ({
      error: true,
      message,
      timestamp: Date.now(),
    }),
  };
}
```

##### 3.4.2 降级策略

```typescript
// src/fallback/strategy.ts
export enum FallbackStrategy {
  RETURN_NULL = 'return_null',           // 返回null
  RETURN_DEFAULT = 'return_default',     // 返回默认值
  RETURN_CACHE = 'return_cache',         // 返回缓存数据
  RETURN_EMPTY = 'return_empty',         // 返回空结果
  THROW_ERROR = 'throw_error',           // 抛出错误
  EXECUTE_FALLBACK = 'execute_fallback', // 执行降级函数
}

export class FallbackStrategyManager {
  private handler: FallbackHandler;

  constructor(handler: FallbackHandler) {
    this.handler = handler;
  }

  async apply<T>(
    strategy: FallbackStrategy,
    key: string,
    defaultValue?: T
  ): Promise<T> {
    switch (strategy) {
      case FallbackStrategy.RETURN_NULL:
        return null as T;

      case FallbackStrategy.RETURN_DEFAULT:
        return defaultValue as T;

      case FallbackStrategy.RETURN_CACHE:
        return this.handler.execute(`cache:${key}`);

      case FallbackStrategy.RETURN_EMPTY:
        return FallbackHandler.PREDEFINED_FALLBACKS.EMPTY_ARRAY();

      case FallbackStrategy.THROW_ERROR:
        throw new Error(`Service unavailable: ${key}`);

      case FallbackStrategy.EXECUTE_FALLBACK:
        return this.handler.execute(key, defaultValue);

      default:
        return defaultValue as T;
    }
  }
}
```

#### 3.5 隔离机制

##### 3.5.1 舱壁模式

```typescript
// src/isolation/bulkhead.ts
export interface BulkheadConfig {
  maxConcurrent: number;   // 最大并发数
  maxQueueSize: number;    // 队列大小
}

export class Bulkhead {
  private running = 0;
  private queue: Array<() => void> = [];
  private config: BulkheadConfig;

  constructor(config: BulkheadConfig) {
    this.config = config;
  }

  // 执行任务
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      const task = async () => {
        try {
          this.running++;
          const result = await fn();
          resolve(result);
        } catch (error) {
          reject(error);
        } finally {
          this.running--;
          this.processQueue();
        }
      };

      if (this.running < this.config.maxConcurrent) {
        task();
      } else if (this.queue.length < this.config.maxQueueSize) {
        this.queue.push(task);
      } else {
        reject(new Error('Bulkhead queue is full'));
      }
    });
  }

  private processQueue(): void {
    if (this.queue.length > 0 && this.running < this.config.maxConcurrent) {
      const task = this.queue.shift();
      if (task) {
        task();
      }
    }
  }

  getAvailablePermits(): number {
    return this.config.maxConcurrent - this.running;
  }

  getQueueSize(): number {
    return this.queue.length;
  }
}
```

### 4. 中间件集成

#### 4.1 Express限流中间件

```typescript
// src/middleware/rate-limit.ts
import { Request, Response, NextFunction } from 'express';

export interface RateLimitMiddlewareOptions {
  keyPrefix: string;
  limit: number;
  window: number;
  skipFailedRequests?: boolean;
  skipSuccessfulRequests?: boolean;
}

export function createRateLimitMiddleware(
  redis: Redis,
  options: RateLimitMiddlewareOptions
) {
  const limiter = new MultiDimensionalRateLimiter(redis);

  return async (req: Request, res: Response, next: NextFunction) => {
    // 生成限流key
    const key = `${options.keyPrefix}:${getClientIdentifier(req)}`;

    const result = await limiter.checkAllowed([
      {
        dimension: RateLimitDimension.IP,
        key,
        limit: options.limit,
        window: options.window,
        algorithm: 'sliding-window',
      },
    ]);

    // 设置响应头
    res.setHeader('X-RateLimit-Limit', options.limit);
    res.setHeader('X-RateLimit-Remaining', result.remaining ?? 0);
    res.setHeader('X-RateLimit-Reset', result.resetAt ?? Date.now());

    if (!result.allowed) {
      return res.status(429).json({
        error: 'Too Many Requests',
        message: 'Rate limit exceeded',
        retryAfter: Math.ceil((result.resetAt! - Date.now()) / 1000),
      });
    }

    next();
  };
}

function getClientIdentifier(req: Request): string {
  return req.ip || req.connection.remoteAddress || 'unknown';
}
```

#### 4.2 熔断中间件

```typescript
// src/middleware/circuit-breaker.ts
export function createCircuitBreakerMiddleware(
  manager: CircuitBreakerManager,
  serviceName: string,
  options?: Partial<CircuitBreakerConfig>
) {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      await manager.execute(serviceName, async () => {
        return new Promise<void>((resolve, reject) => {
          next();
          // 注意：这里需要特殊处理，因为next()不会等待请求完成
          res.on('finish', () => resolve());
          res.on('error', (err) => reject(err));
        });
      }, options);
    } catch (error) {
      return res.status(503).json({
        error: 'Service Unavailable',
        message: 'Circuit breaker is open',
      });
    }
  };
}
```

### 5. 监控告警

#### 5.1 限流指标

```typescript
// src/monitoring/rate-limit-metrics.ts
export class RateLimitMetrics {
  private meter: Meter;

  constructor(meter: Meter) {
    this.meter = meter;
  }

  createMetrics() {
    // 限流拒绝计数
    const rejectedCounter = this.meter.createCounter('rate_limit_rejected_total', {
      description: 'Total number of rate limited requests',
    });

    // 限流允许计数
    const allowedCounter = this.meter.createCounter('rate_limit_allowed_total', {
      description: 'Total number of allowed requests',
    });

    // 当前配额
    const quotaGauge = this.meter.createGauge('rate_limit_quota', {
      description: 'Current rate limit quota',
    });

    return {
      rejectedCounter,
      allowedCounter,
      quotaGauge,
    };
  }
}
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
