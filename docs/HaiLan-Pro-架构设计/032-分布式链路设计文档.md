---
@file: 032-分布式链路设计文档.md
@description: HaiLan Pro 分布式系统链路追踪、调用链设计，保障系统可观测性与问题排查
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-架构设计],[]
---

> ***YanYuCloudCube***
> 言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> 万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 032 分布式链路设计文档

## 概述

本文档详细描述HaiLan Pro的分布式链路追踪架构设计，包括调用链追踪、日志聚合、性能监控等核心功能，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 可观测性价值
- **问题定位**：快速定位跨服务调用链中的性能瓶颈和错误
- **性能分析**：分析各服务响应时间，识别优化点
- **依赖分析**：梳理服务间依赖关系，评估系统健康度
- **故障排查**：完整的请求上下文信息，加速故障排查

#### 1.3 文档目标
- 规范分布式链路追踪相关的业务标准与技术落地要求
- 定义追踪数据采集、传输、存储的技术方案
- 保障可观测性模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：追踪系统故障不影响业务正常运行
- **高性能**：低侵入性数据采集，对业务性能影响<5%
- **高安全性**：敏感数据脱敏，追踪数据加密传输
- **高扩展性**：支持水平扩展，处理海量追踪数据
- **高可维护性**：可视化分析界面，便于问题排查

#### 2.2 五标体系
- **标准化**：统一的Trace ID格式和上下文传递规范
- **规范化**：标准化的埋点方式和日志格式
- **自动化**：自动化的服务发现和调用链拓扑生成
- **智能化**：智能异常检测和性能告警
- **可视化**：调用链拓扑图、性能分析仪表板

#### 2.3 五化架构
- **流程化**：标准化的追踪数据采集和处理流程
- **文档化**：完善的埋点文档和最佳实践
- **工具化**：自动化的埋点工具链
- **数字化**：可观测性指标量化
- **生态化**：兼容OpenTelemetry、Jaeger等主流标准

### 3. 分布式链路追踪设计

#### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    HaiLan Pro 链路追踪架构                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    应用层埋点                              │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │HTTP埋点   │  │数据库埋点 │  │缓存埋点   │  │消息队列 │ │   │
│  │  │HTTP      │  │Database  │  │Cache     │  │MQ      │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  OpenTelemetry SDK                        │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │Tracer    │  │Context   │  │Propagator │  │Exporter │ │   │
│  │  │追踪器     │  │上下文     │  │传递器     │  │导出器   │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    数据收集层                              │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │OTLP Collector│ │Span     │  │Metric    │  │Log     │ │   │
│  │  │OTLP收集器 │  │Span收集  │  │Metric收集│  │Log收集 │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    数据存储层                              │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │Elasticsearch│ │ClickHouse│  │Prometheus │  │Loki    │ │   │
│  │  │Tracing    │  │Analytics │  │Metrics    │  │Logging │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    分析展示层                              │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │   │
│  │  │Jaeger UI │  │Grafana   │  │告警系统   │  │Dashboard│ │   │
│  │  │追踪界面  │  │可视化    │  │Alerting  │  │仪表板  │ │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.2 OpenTelemetry集成

##### 3.2.1 前端埋点配置

```typescript
// src/telemetry/browser.ts
import { trace, context, Span, SpanStatusCode, SpanKind } from '@opentelemetry/api';
import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { ZoneContextManager } from '@opentelemetry/context-zone';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { FetchInstrumentation } from '@opentelemetry/instrumentation-fetch';
import { XMLHttpRequestInstrumentation } from '@opentelemetry/instrumentation-xml-http-request';
import { UserInteractionInstrumentation } from '@opentelemetry/instrumentation-user-interaction';

// 初始化OpenTelemetry
export function initOpenTelemetry() {
  const resource = Resource.default().merge(
    new Resource({
      [SemanticResourceAttributes.SERVICE_NAME]: 'hailan-pro-frontend',
      [SemanticResourceAttributes.SERVICE_VERSION]: process.env.VITE_APP_VERSION || '1.0.0',
      [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV,
    })
  );

  const provider = new WebTracerProvider({
    resource,
  });

  // 配置导出器
  const exporter = new OTLPTraceExporter({
    url: process.env.VITE_OTEL_EXPORTER_OTLP_ENDPOINT || '/api/traces',
  });

  provider.addSpanProcessor(
    new BatchSpanProcessor(exporter, {
      maxQueueSize: 100,
      maxBatchSize: 10,
      scheduledDelayMillis: 1000,
    })
  );

  // 注册Provider
  provider.register({
    contextManager: new ZoneContextManager(),
  });

  // 自动埋点
  registerInstrumentations({
    instrumentations: [
      new FetchInstrumentation({
        propagateTraceHeaderCors: true,
        clearTimingResources: true,
      }),
      new XMLHttpRequestInstrumentation({
        propagateTraceHeaderCors: true,
      }),
      new UserInteractionInstrumentation(),
    ],
  });
}

// 创建自定义Span
export function startSpan(
  name: string,
  fn: (span: Span) => Promise<any> | any,
  options?: {
    kind?: SpanKind;
    attributes?: Record<string, any>;
  }
): Promise<any> {
  const tracer = trace.getTracer('hailan-pro');
  const span = tracer.startSpan(name, {
    kind: options?.kind,
    attributes: options?.attributes,
  });

  return context.with(trace.setSpan(context.active(), span), async () => {
    try {
      const result = await fn(span);
      span.setStatus({ code: SpanStatusCode.OK });
      return result;
    } catch (error) {
      span.recordException(error as Error);
      span.setStatus({ code: SpanStatusCode.ERROR, message: (error as Error).message });
      throw error;
    } finally {
      span.end();
    }
  });
}

// HTTP请求埋点
export async function tracedFetch(
  url: string,
  options?: RequestInit,
  spanName?: string
): Promise<Response> {
  const tracer = trace.getTracer('hailan-pro');

  return tracer.startActiveSpan(
    spanName || `HTTP ${options?.method || 'GET'} ${url}`,
    {
      kind: SpanKind.CLIENT,
      attributes: {
        [SemanticAttributes.HTTP_METHOD]: options?.method || 'GET',
        [SemanticAttributes.HTTP_URL]: url,
        [SemanticAttributes.HTTP_TARGET]: new URL(url).pathname,
      },
    },
    async (span) => {
      try {
        // 注入追踪头
        const headers = new Headers(options?.headers);
        const carrier: Record<string, string> = {};
        propagation.inject(context.active(), carrier, {
          set: (h, k, v) => headers.set(k, v),
        });

        // 执行请求
        const response = await fetch(url, {
          ...options,
          headers,
        });

        // 记录响应状态
        span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, response.status);

        if (!response.ok) {
          span.setStatus({
            code: SpanStatusCode.ERROR,
            message: `HTTP ${response.status}`,
          });
        }

        return response;
      } catch (error) {
        span.recordException(error as Error);
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: (error as Error).message,
        });
        throw error;
      } finally {
        span.end();
      }
    }
  );
}

// 用户交互埋点
export function trackUserInteraction(
  element: HTMLElement,
  eventType: string,
  handler: EventListener
): EventListener {
  const tracer = trace.getTracer('hailan-pro');

  return function (this: HTMLElement, event: Event) {
    const span = tracer.startSpan(`${eventType} on ${element.tagName}`, {
      kind: SpanKind.INTERNAL,
      attributes: {
        'ui.element.id': element.id,
        'ui.element.class': element.className,
        'ui.element.type': element.tagName,
        'ui.event.type': eventType,
      },
    });

    try {
      handler.call(this, event);
      span.setStatus({ code: SpanStatusCode.OK });
    } catch (error) {
      span.recordException(error as Error);
      span.setStatus({ code: SpanStatusCode.ERROR });
    } finally {
      span.end();
    }
  };
}
```

##### 3.2.2 后端埋点配置

```typescript
// src/telemetry/server.ts
import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-grpc';
import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { HttpInstrumentation } from '@opentelemetry/instrumentation-http';
import { ExpressInstrumentation } from '@opentelemetry/instrumentation-express';
import { PgInstrumentation } from '@opentelemetry/instrumentation-pg';
import { RedisInstrumentation } from '@opentelemetry/instrumentation-redis-4';
import { IORedisInstrumentation } from '@opentelemetry/instrumentation-ioredis';

export function initServerTelemetry() {
  const resource = Resource.default().merge(
    new Resource({
      [SemanticResourceAttributes.SERVICE_NAME]: process.env.OTEL_SERVICE_NAME || 'hailan-pro-api',
      [SemanticResourceAttributes.SERVICE_VERSION]: process.env.APP_VERSION || '1.0.0',
      [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV,
      [SemanticResourceAttributes.HOST_NAME]: require('os').hostname(),
    })
  );

  const provider = new NodeTracerProvider({
    resource,
  });

  // 配置导出器
  const exporter = new OTLPTraceExporter({
    url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317',
  });

  provider.addSpanProcessor(
    new BatchSpanProcessor(exporter, {
      maxQueueSize: 2048,
      maxBatchSize: 512,
      scheduledDelayMillis: 5000,
      exportTimeoutMillis: 30000,
    })
  );

  // 注册Provider
  provider.register();

  // 自动埋点
  registerInstrumentations({
    instrumentations: [
      new HttpInstrumentation({
        propagateTraceHeaderCors: true,
        applyCustomAttributesOnSpan: (span) => {
          span.setAttribute('custom.http.kind', 'server');
        },
      }),
      new ExpressInstrumentation(),
      new PgInstrumentation(),
      new RedisInstrumentation(),
      new IORedisInstrumentation(),
    ],
  });
}

// 中间件：注入追踪上下文
export function telemetryMiddleware(req: any, res: any, next: any) {
  const tracer = trace.getTracer('hailan-pro');
  const span = tracer.startSpan(`${req.method} ${req.path}`, {
    kind: SpanKind.SERVER,
    attributes: {
      [SemanticAttributes.HTTP_METHOD]: req.method,
      [SemanticAttributes.HTTP_URL]: req.url,
      [SemanticAttributes.HTTP_ROUTE]: req.route?.path || req.path,
      'http.user_agent': req.get('user-agent'),
      'http.client_ip': req.ip,
    },
  });

  // 将Span绑定到请求上下文
  context.with(trace.setSpan(context.active(), span), () => {
    req.span = span;
    res.on('finish', () => {
      span.setAttribute(SemanticAttributes.HTTP_STATUS_CODE, res.statusCode);
      if (res.statusCode >= 400) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: `HTTP ${res.statusCode}`,
        });
      } else {
        span.setStatus({ code: SpanStatusCode.OK });
      }
      span.end();
    });
    next();
  });
}

// 数据库查询埋点
export async function tracedQuery<T>(
  client: any,
  query: string,
  params?: any[],
  spanName?: string
): Promise<T> {
  const tracer = trace.getTracer('hailan-pro');

  return tracer.startActiveSpan(
    spanName || 'database.query',
    {
      kind: SpanKind.CLIENT,
      attributes: {
        [SemanticAttributes.DB_SYSTEM]: 'postgresql',
        [SemanticAttributes.DB_NAME]: client.database,
        'db.statement': query,
      },
    },
    async (span) => {
      try {
        const result = await client.query(query, params);
        span.setAttribute(SemanticAttributes.DB_ROWS_AFFECTED, result.rowCount);
        return result;
      } catch (error) {
        span.recordException(error);
        span.setStatus({ code: SpanStatusCode.ERROR });
        throw error;
      } finally {
        span.end();
      }
    }
  );
}

// 缓存操作埋点
export async function tracedCacheOperation<T>(
  operation: 'get' | 'set' | 'del',
  key: string,
  fn: () => Promise<T>
): Promise<T> {
  const tracer = trace.getTracer('hailan-pro');

  return tracer.startActiveSpan(
    `cache.${operation}`,
    {
      kind: SpanKind.CLIENT,
      attributes: {
        'cache.operation': operation,
        'cache.key': key,
        'cache.system': 'redis',
      },
    },
    async (span) => {
      try {
        const result = await fn();
        span.setStatus({ code: SpanStatusCode.OK });
        return result;
      } catch (error) {
        span.recordException(error);
        span.setStatus({ code: SpanStatusCode.ERROR });
        throw error;
      } finally {
        span.end();
      }
    }
  );
}
```

#### 3.3 追踪数据模型

##### 3.3.1 Span数据结构

```typescript
// src/telemetry/models.ts
export interface TraceID {
  value: string;
}

export interface SpanID {
  value: string;
}

export interface Span {
  // 基础信息
  traceId: TraceID;
  spanId: SpanID;
  parentSpanId?: SpanID;

  // 名称和时间
  name: string;
  startTimeUnixNano: number;
  endTimeUnixNano?: number;
  durationNano?: number;

  // 状态
  status?: SpanStatus;

  // 属性
  attributes?: Record<string, AttributeValue>;

  // 事件
  events?: SpanEvent[];

  // 链接
  links?: SpanLink[];

  // 类型
  kind: SpanKind;
}

export enum SpanKind {
  INTERNAL = 'INTERNAL',
  SERVER = 'SERVER',
  CLIENT = 'CLIENT',
  PRODUCER = 'PRODUCER',
  CONSUMER = 'CONSUMER',
}

export interface SpanStatus {
  code: SpanStatusCode;
  message?: string;
}

export enum SpanStatusCode {
  OK = 'OK',
  ERROR = 'ERROR',
  UNSET = 'UNSET',
}

export type AttributeValue =
  | string
  | number
  | boolean
  | Array<AttributeValue>
  | { [key: string]: AttributeValue };

export interface SpanEvent {
  timeUnixNano: number;
  name: string;
  attributes?: Record<string, AttributeValue>;
}

export interface SpanLink {
  traceId: TraceID;
  spanId: SpanID;
  attributes?: Record<string, AttributeValue>;
}

// Trace关联
export interface TraceLink {
  traceId: TraceID;
  parentSpanId?: SpanID;
  childSpanId?: SpanID;
  relationship: 'parent_of' | 'child_of' | 'follows_from';
}
```

##### 3.3.2 上下文传递

```typescript
// src/telemetry/propagation.ts
import {
  propagation,
  ROOT_CONTEXT,
  TraceContext,
  SpanContext,
} from '@opentelemetry/api';

// W3C Trace Context格式
export class W3CTraceContextPropagator implements TextMapPropagator {
  inject(context: Context, carrier: any, setter: TextMapSetter): void {
    const spanContext = trace.getSpanContext(context);
    if (!spanContext) return;

    // traceparent头
    const traceParent = `00-${spanContext.traceId}-${spanContext.spanId}-${Math.floor(spanContext.traceFlags * 16).toString(16).padStart(2, '0')}`;
    carrier = setter.set(carrier, 'traceparent', traceParent);

    // tracestate头（可选）
    if (spanContext.traceState) {
      carrier = setter.set(carrier, 'tracestate', spanContext.traceState.serialize());
    }
  }

  extract(context: Context, carrier: any, getter: TextMapGetter): Context {
    const traceParent = getter.get(carrier, 'traceparent');
    if (!traceParent) return context;

    const parts = traceParent.split('-');
    if (parts.length < 4) return context;

    const [, traceId, spanId, flags] = parts;
    const spanContext: SpanContext = {
      traceId,
      spanId,
      traceFlags: parseInt(flags, 16) / 16,
    };

    return trace.setSpanContext(context, spanContext);
  }

  fields(): string[] {
    return ['traceparent', 'tracestate'];
  }
}

// B3格式（兼容Jaeger）
export class B3Propagator implements TextMapPropagator {
  inject(context: Context, carrier: any, setter: TextMapSetter): void {
    const spanContext = trace.getSpanContext(context);
    if (!spanContext) return;

    carrier = setter.set(carrier, 'X-B3-TraceId', spanContext.traceId);
    carrier = setter.set(carrier, 'X-B3-SpanId', spanContext.spanId);

    if (spanContext.parentSpanId) {
      carrier = setter.set(carrier, 'X-B3-ParentSpanId', spanContext.parentSpanId);
    }

    carrier = setter.set(carrier, 'X-B3-Sampled', '1');
  }

  extract(context: Context, carrier: any, getter: TextMapGetter): Context {
    const traceId = getter.get(carrier, 'X-B3-TraceId');
    const spanId = getter.get(carrier, 'X-B3-SpanId');
    const parentSpanId = getter.get(carrier, 'X-B3-ParentSpanId');

    if (!traceId || !spanId) return context;

    const spanContext: SpanContext = {
      traceId,
      spanId,
      isRemote: true,
    };

    return trace.setSpanContext(context, spanContext);
  }

  fields(): string[] {
    return ['X-B3-TraceId', 'X-B3-SpanId', 'X-B3-ParentSpanId', 'X-B3-Sampled'];
  }
}

// 组合传播器
export const compositePropagator = new CompositePropagator({
  propagators: [
    new W3CTraceContextPropagator(),
    new B3Propagator(),
  ],
});
```

#### 3.4 监控指标

##### 3.4.1 性能指标

```typescript
// src/telemetry/metrics.ts
import { metrics } from '@opentelemetry/api';
import { MeterProvider } from '@opentelemetry/sdk-metrics';
import { PrometheusExporter } from '@opentelemetry/exporter-prometheus';

export function initMetrics() {
  const meterProvider = new MeterProvider();

  // Prometheus导出器
  const prometheusExporter = new PrometheusExporter({
    port: 9464,
    endpoint: '/metrics',
  });

  meterProvider.addMetricReader(prometheusExporter);
  metrics.setGlobalMeterProvider(meterProvider);

  return metrics.getMeter('hailan-pro');
}

// 创建指标
export function createMetrics(meter: Meter) {
  // HTTP请求计数器
  const httpRequestsCounter = meter.createCounter('http_requests_total', {
    description: 'Total number of HTTP requests',
  });

  // HTTP请求延迟直方图
  const httpDuration = meter.createHistogram('http_request_duration_ms', {
    description: 'HTTP request latency',
    unit: 'ms',
  });

  // 数据库查询计数器
  const dbQueriesCounter = meter.createCounter('db_queries_total', {
    description: 'Total number of database queries',
  });

  // 缓存命中率
  const cacheHitRatio = meter.createGauge('cache_hit_ratio', {
    description: 'Cache hit rate ratio',
  });

  // 活跃用户数
  const activeUsers = meter.createGauge('active_users', {
    description: 'Number of active users',
  });

  // 错误率
  const errorRate = meter.createGauge('error_rate', {
    description: 'Error rate ratio',
  });

  return {
    httpRequestsCounter,
    httpDuration,
    dbQueriesCounter,
    cacheHitRatio,
    activeUsers,
    errorRate,
  };
}
```

#### 3.5 日志关联

##### 3.5.1 结构化日志

```typescript
// src/telemetry/logging.ts
import { trace, context } from '@opentelemetry/api';

export interface LogEntry {
  timestamp: string;
  level: 'debug' | 'info' | 'warn' | 'error';
  message: string;
  traceId?: string;
  spanId?: string;
  attributes?: Record<string, any>;
  error?: Error;
}

export class Logger {
  constructor(private serviceName: string) {}

  private injectTraceContext(entry: LogEntry): LogEntry {
    const currentSpan = trace.getSpan(context.active());

    if (currentSpan) {
      const spanContext = currentSpan.spanContext();
      entry.traceId = spanContext.traceId;
      entry.spanId = spanContext.spanId;
    }

    return entry;
  }

  private formatMessage(entry: LogEntry): string {
    const { timestamp, level, message, traceId, spanId, attributes, error } = entry;

    let log = `[${timestamp}] [${level.toUpperCase()}]`;

    if (traceId) {
      log += ` [trace:${traceId}]`;
    }

    if (spanId) {
      log += ` [span:${spanId}]`;
    }

    log += ` ${message}`;

    if (attributes && Object.keys(attributes).length > 0) {
      log += ` ${JSON.stringify(attributes)}`;
    }

    if (error) {
      log += `\n${error.stack}`;
    }

    return log;
  }

  debug(message: string, attributes?: Record<string, any>): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: 'debug',
      message,
      attributes,
    };

    const tracedEntry = this.injectTraceContext(entry);
    console.debug(this.formatMessage(tracedEntry));
  }

  info(message: string, attributes?: Record<string, any>): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      attributes,
    };

    const tracedEntry = this.injectTraceContext(entry);
    console.info(this.formatMessage(tracedEntry));
  }

  warn(message: string, attributes?: Record<string, any>): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: 'warn',
      message,
      attributes,
    };

    const tracedEntry = this.injectTraceContext(entry);
    console.warn(this.formatMessage(tracedEntry));
  }

  error(message: string, error?: Error, attributes?: Record<string, any>): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      error,
      attributes,
    };

    const tracedEntry = this.injectTraceContext(entry);
    console.error(this.formatMessage(tracedEntry));
  }
}

export const logger = new Logger('hailan-pro');
```

### 4. 部署配置

#### 4.1 Jaeger部署

```yaml
# docker-compose.yml
version: '3.8'
services:
  jaeger-all-in-one:
    image: jaegertracing/all-in-one:latest
    ports:
      - "5775:5775/udp"       # accept zipkin.thrift over compact thrift protocol
      - "6831:6831/udp"       # accept jaeger.thrift over compact thrift protocol
      - "6832:6832/udp"       # accept jaeger.thrift over binary thrift protocol
      - "5778:5778"           # serve configs
      - "16686:16686"         # serve frontend
      - "14268:14268"         # serve http
      - "14250:14250"         # gRPC
      - "9411:9411"           # accept Zipkin compatible spans
    environment:
      - COLLECTOR_ZIPKIN_HOST_PORT=:9411
      - COLLECTOR_OTLP_ENABLED=true
      - SPAN_STORAGE_TYPE=elasticsearch
      - ES_SERVER_URLS=http://elasticsearch:9200
    depends_on:
      - elasticsearch

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.x
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana/datasources:/etc/grafana/provisioning/datasources
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards

volumes:
  elasticsearch-data:
  prometheus-data:
  grafana-data:
```

#### 4.2 环境变量

```bash
# .env
# OpenTelemetry配置
OTEL_SERVICE_NAME=hailan-pro-api
OTEL_SERVICE_VERSION=1.0.0
OTEL_DEPLOYMENT_ENVIRONMENT=production
OTEL_EXPORTER_OTLP_ENDPOINT=http://jaeger:4317
OTEL_TRACES_EXPORTER=otlp
OTEL_METRICS_EXPORTER=prometheus
OTEL_LOGS_EXPORTER=console

# 采样配置
OTEL_TRACES_SAMPLER=parentbased_traceidratio
OTEL_TRACES_SAMPLER_ARG=0.1

# 资源属性
OTEL_RESOURCE_ATTRIBUTES=service.name=hailan-pro,service.version=1.0.0
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
