---
file: 028-PWA架构设计文档.md
description: HaiLan Pro PWA专项架构设计，包含Service Worker、缓存策略、离线能力、推送通知等
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-架构设计,[]
---

> ***YanYuCloudCube***
> 言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> 万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 028 PWA架构设计文档

## 概述

本文档详细描述HaiLan Pro的PWA（渐进式Web应用）架构设计，包括Service Worker策略、缓存机制、离线能力、推送通知等核心功能，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 PWA技术优势
- **跨平台一致性**：一套代码覆盖iOS、Android、Desktop多端
- **离线可用性**：支持无网络环境下的核心功能访问
- **原生级体验**：可安装到桌面、支持全屏、启动画面
- **即时更新**：热更新机制，无需应用商店审核
- **推送通知**：Web Push API实现精准触达

#### 1.3 文档目标
- 规范PWA架构设计相关的业务标准与技术落地要求
- 定义Service Worker缓存策略与数据同步机制
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保应用在弱网、断网环境下仍可访问核心功能
- **高性能**：优化资源加载策略，首屏加载时间<2秒
- **高安全性**：Service Worker通信加密，敏感数据不缓存
- **高扩展性**：模块化缓存策略，易于扩展新资源类型
- **高可维护性**：清晰的版本管理，支持回滚

#### 2.2 五标体系
- **标准化**：遵循W3C PWA规范与Google Lighthouse标准
- **规范化**：统一的Service Worker生命周期管理
- **自动化**：自动检测更新、自动缓存静态资源
- **智能化**：智能预测用户需求，预加载可能访问的内容
- **可视化**：缓存状态可视化，网络状况实时反馈

#### 2.3 五化架构
- **流程化**：标准化的PWA安装、更新流程
- **文档化**：完善的API文档与最佳实践
- **工具化**：workbox-webpack-plugin自动化构建
- **数字化**：Core Web Vitals性能监控
- **生态化**：兼容各大浏览器与系统平台

### 3. PWA架构设计

#### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        HaiLan Pro PWA架构                        │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │  Manifest   │  │   Service   │  │    Push     │             │
│  │   配置层     │  │   Worker    │  │  Notification│             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│         │                │                  │                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   Shell     │  │   Cache     │  │    Indexed  │             │
│  │   应用壳     │  │   策略层     │  │      DB     │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│         │                │                  │                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   Router    │  │    离线     │  │    后台     │             │
│  │  MemoryRouter│  │   数据层     │  │    Sync     │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│         │                                                     │
│  ┌─────────────────────────────────────────────────────┐      │
│  │              React Application (Vite 6)              │      │
│  │   - 隐私保护组件  - PWA安装提示  - 网络状态监听     │      │
│  └─────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
         │                                    │
    ┌────▼────┐                          ┌───▼────┐
    │ Browser │                          │Server  │
    └─────────┘                          └────────┘
```

#### 3.2 Web App Manifest配置

##### 3.2.1 manifest.json配置

```json
{
  "name": "HaiLan Pro - 海蓝健康生活管理",
  "short_name": "海蓝Pro",
  "description": "新一代高端私密智能情趣健康生活管理平台",
  "start_url": "/",
  "scope": "/",
  "display": "standalone",
  "orientation": "portrait-primary",
  "theme_color": "#1E3A5F",
  "background_color": "#0F172A",
  "lang": "zh-CN",
  "dir": "ltr",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/maskable-icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  "screenshots": [
    {
      "src": "/screenshots/mobile-home.png",
      "sizes": "540x720",
      "type": "image/png",
      "form_factor": "narrow"
    },
    {
      "src": "/screenshots/desktop-home.png",
      "sizes": "1920x1080",
      "type": "image/png",
      "form_factor": "wide"
    }
  ],
  "shortcuts": [
    {
      "name": "智能顾问",
      "short_name": "AI咨询",
      "description": "快速访问AI健康顾问",
      "url": "/ai-assistant",
      "icons": [
        {
          "src": "/icons/shortcut-ai.png",
          "sizes": "96x96"
        }
      ]
    },
    {
      "name": "隐私模式",
      "short_name": "隐私模式",
      "description": "快速切换隐私保护模式",
      "url": "/privacy-mode",
      "icons": [
        {
          "src": "/icons/shortcut-privacy.png",
          "sizes": "96x96"
        }
      ]
    },
    {
      "name": "设备连接",
      "short_name": "设备",
      "description": "连接和管理IoT智能设备",
      "url": "/devices",
      "icons": [
        {
          "src": "/icons/shortcut-device.png",
          "sizes": "96x96"
        }
      ]
    },
    {
      "name": "健康档案",
      "short_name": "档案",
      "description": "查看个人健康数据档案",
      "url": "/profile",
      "icons": [
        {
          "src": "/icons/shortcut-profile.png",
          "sizes": "96x96"
        }
      ]
    }
  ],
  "related_applications": [],
  "prefer_related_applications": false,
  "categories": ["health", "lifestyle", "medical"],
  "edge_side_panel": {
    "preferred_width": 400
  },
  "launch_handler": {
    "client_mode": "focus-existing"
  }
}
```

##### 3.2.2 隐私级别主题配置

```typescript
// src/pwa/themes/index.ts
export interface PrivacyTheme {
  name: string;
  themeColor: string;
  backgroundColor: string;
  display: string;
  camouflageMode: boolean;
}

export const PRIVACY_THEMES: Record<PrivacyLevel, PrivacyTheme> = {
  STANDARD: {
    name: '海蓝标准',
    themeColor: '#1E3A5F',
    backgroundColor: '#0F172A',
    display: 'standalone',
    camouflageMode: false,
  },
  STEALTH: {
    name: '计算器',
    themeColor: '#1C1C1E',
    backgroundColor: '#000000',
    display: 'standalone',
    camouflageMode: true,
  },
  DISGUISE: {
    name: '系统工具',
    themeColor: '#F2F2F7',
    backgroundColor: '#FFFFFF',
    display: 'minimal-ui',
    camouflageMode: true,
  },
};

// 动态更新manifest
export function updateManifest(privacyLevel: PrivacyLevel): void {
  const theme = PRIVACY_THEMES[privacyLevel];
  const link = document.querySelector('link[rel="manifest"]') as HTMLLinkElement;

  if (link && theme.camouflageMode) {
    // 伪装模式下替换manifest
    const camouflageManifest = {
      ...theme,
      name: theme.name,
      short_name: theme.name,
      icons: getCamouflageIcons(privacyLevel),
    };

    // 通过data URL更新
    const blob = new Blob([JSON.stringify(camouflageManifest)], { type: 'application/json' });
    link.href = URL.createObjectURL(blob);
  }
}
```

#### 3.3 Service Worker架构

##### 3.3.1 Service Worker生命周期管理

```typescript
// src/pwa/service-worker/index.ts
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute, Route } from 'workbox-routing';
import {
  CacheFirst,
  NetworkFirst,
  StaleWhileRevalidate,
  NetworkOnly,
} from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// 版本管理
const SW_VERSION = 'v1.0.0';
const CACHE_PREFIX = 'hailan-pro';

// 缓存名称
const CACHE_NAMES = {
  STATIC: `${CACHE_PREFIX}-static-${SW_VERSION}`,
  DYNAMIC: `${CACHE_PREFIX}-dynamic-${SW_VERSION}`,
  API: `${CACHE_PREFIX}-api-${SW_VERSION}`,
  IMAGES: `${CACHE_PREFIX}-images-${SW_VERSION}`,
  OFFLINE: `${CACHE_PREFIX}-offline-${SW_VERSION}`,
};

// Service Worker安装
self.addEventListener('install', (event: ExtendableEvent) => {
  console.log(`[SW] Installing version ${SW_VERSION}`);

  event.waitUntil(
    (async () => {
      // 预缓存核心资源
      const cache = await caches.open(CACHE_NAMES.STATIC);
      await cache.addAll([
        '/',
        '/offline.html',
        '/manifest.json',
      ]);

      // 立即激活
      await self.skipWaiting();
    })()
  );
});

// Service Worker激活
self.addEventListener('activate', (event: ExtendableEvent) => {
  console.log(`[SW] Activating version ${SW_VERSION}`);

  event.waitUntil(
    (async () => {
      // 清理旧缓存
      const cacheNames = await caches.keys();
      const cachesToDelete = cacheNames.filter(
        name => name.startsWith(CACHE_PREFIX) && !name.includes(SW_VERSION)
      );

      await Promise.all(
        cachesToDelete.map(name => caches.delete(name))
      );

      // 立即控制所有客户端
      await self.clients.claim();
    })()
  );
});

// 消息处理
self.addEventListener('message', (event) => {
  const { data, ports } = event;

  switch (data.type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;

    case 'CLEAR_CACHE':
      clearCache(data.cacheName).then(() => {
        ports?.[0]?.postMessage({ type: 'CACHE_CLEARED' });
      });
      break;

    case 'GET_CACHE_SIZE':
      getCacheSize().then(size => {
        ports?.[0]?.postMessage({ type: 'CACHE_SIZE', data: size });
      });
      break;

    case 'SYNC_NOW':
      syncData().then(() => {
        ports?.[0]?.postMessage({ type: 'SYNC_COMPLETE' });
      });
      break;
  }
});

// 工具函数
async function clearCache(cacheName?: string): Promise<void> {
  if (cacheName) {
    await caches.delete(cacheName);
  } else {
    const keys = await caches.keys();
    await Promise.all(keys.map(key => caches.delete(key)));
  }
}

async function getCacheSize(): Promise<number> {
  const keys = await caches.keys();
  let totalSize = 0;

  for (const key of keys) {
    const cache = await caches.open(key);
    const requests = await cache.keys();
    for (const request of requests) {
      const response = await cache.match(request);
      if (response) {
        const blob = await response.blob();
        totalSize += blob.size;
      }
    }
  }

  return totalSize;
}

async function syncData(): Promise<void> {
  // 同步离线数据
  const syncQueue = await getSyncQueue();
  for (const item of syncQueue) {
    try {
      await fetch(item.url, {
        method: item.method,
        headers: item.headers,
        body: item.body,
      });
      await removeSyncItem(item.id);
    } catch (error) {
      console.error('[SW] Sync failed:', error);
    }
  }
}

async function getSyncQueue(): Promise<any[]> {
  // 从IndexedDB获取同步队列
  return [];
}

async function removeSyncItem(id: string): Promise<void> {
  // 从IndexedDB移除同步项
}
```

##### 3.3.2 缓存策略配置

```typescript
// src/pwa/service-worker/strategies.ts
import { registerRoute } from 'workbox-routing';
import {
  CacheFirst,
  NetworkFirst,
  StaleWhileRevalidate,
  NetworkOnly,
} from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// 1. 静态资源 - CacheFirst策略
registerRoute(
  ({ request }) => {
    return request.destination === 'script' ||
           request.destination === 'style' ||
           request.destination === 'font';
  },
  new CacheFirst({
    cacheName: CACHE_NAMES.STATIC,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30天
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// 2. 图片资源 - CacheFirst + 过期策略
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: CACHE_NAMES.IMAGES,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7天
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// 3. API请求 - NetworkFirst策略
const bgSyncPlugin = new BackgroundSyncPlugin('hailan-api-queue', {
  maxRetentionTime: 24 * 60, // 24小时
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request);
      } catch (error) {
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  },
});

// 公开API（可缓存）
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/public/'),
  new NetworkFirst({
    cacheName: CACHE_NAMES.API,
    networkTimeoutSeconds: 3,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 5, // 5分钟
      }),
    ],
  })
);

// 私有API（不缓存，后台同步）
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/private/'),
  new NetworkOnly({
    plugins: [bgSyncPlugin],
  })
);

// 4. HTML文档 - NetworkFirst策略
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: CACHE_NAMES.DYNAMIC,
    networkTimeoutSeconds: 3,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// 5. 隐私敏感资源 - NetworkOnly（永不缓存）
registerRoute(
  ({ url }) => {
    const sensitivePaths = [
      '/api/ai/chat',
      '/api/health/records',
      '/api/privacy/data',
    ];
    return sensitivePaths.some(path => url.pathname.startsWith(path));
  },
  new NetworkOnly()
);

// 6. 离线降级策略
const offlineFallback = async ({ request }: { request: Request }) => {
  const url = new URL(request.url);

  // HTML请求返回离线页面
  if (request.mode === 'navigate') {
    return caches.match('/offline.html');
  }

  // 图片请求返回占位符
  if (request.destination === 'image') {
    return caches.match('/images/offline-placeholder.png');
  }

  // API请求返回离线响应
  if (url.pathname.startsWith('/api/')) {
    return Response.json(
      { error: 'OFFLINE', message: '离线模式，请检查网络连接' },
      { status: 503, statusText: 'Service Unavailable' }
    );
  }

  return Response.error();
};

// 注册离线降级
setCatchHandler(offlineFallback);
```

#### 3.4 离线数据管理

##### 3.4.1 IndexedDB封装

```typescript
// src/pwa/storage/indexeddb.ts
import { openDB, DBSchema, IDBPDatabase } from 'idb';

interface HaiLanDB extends DBSchema {
  // 用户缓存数据
  userData: {
    key: string;
    value: {
      id: string;
      data: any;
      timestamp: number;
      expiresAt?: number;
      synced: boolean;
    };
    indexes: {
      'by-timestamp': number;
      'by-synced': boolean;
    };
  };

  // 同步队列
  syncQueue: {
    key: string;
    value: {
      id: string;
      url: string;
      method: string;
      headers: Record<string, string>;
      body?: string;
      timestamp: number;
      retryCount: number;
    };
  };

  // AI对话缓存
  aiConversations: {
    key: string;
    value: {
      id: string;
      sessionId: string;
      role: 'user' | 'assistant';
      content: string;
      timestamp: number;
      encrypted: boolean;
    };
    indexes: {
      'by-session': string;
      'by-timestamp': number;
    };
  };

  // 设备状态缓存
  deviceStates: {
    key: string;
    value: {
      deviceId: string;
      name: string;
      status: 'connected' | 'disconnected';
      lastSync: number;
      data: any;
    };
    indexes: {
      'by-status': string;
    };
  };
}

class IndexedDBManager {
  private db: IDBPDatabase<HaiLanDB> | null = null;
  private readonly DB_NAME = 'HaiLanProDB';
  private readonly DB_VERSION = 1;

  async init(): Promise<void> {
    this.db = await openDB<HaiLanDB>(this.DB_NAME, this.DB_VERSION, {
      upgrade(db) {
        // 创建userData存储
        const userDataStore = db.createObjectStore('userData', { keyPath: 'id' });
        userDataStore.createIndex('by-timestamp', 'timestamp');
        userDataStore.createIndex('by-synced', 'synced');

        // 创建syncQueue存储
        db.createObjectStore('syncQueue', { keyPath: 'id' });

        // 创建aiConversations存储
        const aiStore = db.createObjectStore('aiConversations', { keyPath: 'id' });
        aiStore.createIndex('by-session', 'sessionId');
        aiStore.createIndex('by-timestamp', 'timestamp');

        // 创建deviceStates存储
        const deviceStore = db.createObjectStore('deviceStates', { keyPath: 'deviceId' });
        deviceStore.createIndex('by-status', 'status');
      },
    });
  }

  // 用户数据操作
  async setUserData(key: string, data: any, ttl?: number): Promise<void> {
    if (!this.db) await this.init();

    const expiresAt = ttl ? Date.now() + ttl * 1000 : undefined;
    await this.db!.put('userData', {
      id: key,
      data,
      timestamp: Date.now(),
      expiresAt,
      synced: false,
    });
  }

  async getUserData(key: string): Promise<any | null> {
    if (!this.db) await this.init();

    const item = await this.db!.get('userData', key);
    if (!item) return null;

    // 检查过期
    if (item.expiresAt && item.expiresAt < Date.now()) {
      await this.db!.delete('userData', key);
      return null;
    }

    return item.data;
  }

  async clearUserData(): Promise<void> {
    if (!this.db) await this.init();
    await this.db!.clear('userData');
  }

  // 同步队列操作
  async addToSyncQueue(item: {
    url: string;
    method: string;
    headers: Record<string, string>;
    body?: string;
  }): Promise<string> {
    if (!this.db) await this.init();

    const id = `sync_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    await this.db!.add('syncQueue', {
      id,
      ...item,
      timestamp: Date.now(),
      retryCount: 0,
    });

    return id;
  }

  async getSyncQueue(): Promise<any[]> {
    if (!this.db) await this.init();
    return this.db!.getAll('syncQueue');
  }

  async removeSyncItem(id: string): Promise<void> {
    if (!this.db) await this.init();
    await this.db!.delete('syncQueue', id);
  }

  // AI对话操作
  async saveConversationMessage(message: {
    sessionId: string;
    role: 'user' | 'assistant';
    content: string;
    encrypted?: boolean;
  }): Promise<void> {
    if (!this.db) await this.init();

    await this.db!.add('aiConversations', {
      id: `${message.sessionId}_${Date.now()}`,
      sessionId: message.sessionId,
      role: message.role,
      content: message.content,
      encrypted: message.encrypted ?? false,
      timestamp: Date.now(),
    });
  }

  async getConversation(sessionId: string): Promise<any[]> {
    if (!this.db) await this.init();
    return this.db!.getAllFromIndex('aiConversations', 'by-session', sessionId);
  }

  // 设备状态操作
  async updateDeviceState(deviceId: string, state: {
    name: string;
    status: 'connected' | 'disconnected';
    data: any;
  }): Promise<void> {
    if (!this.db) await this.init();

    await this.db!.put('deviceStates', {
      deviceId,
      ...state,
      lastSync: Date.now(),
    });
  }

  async getConnectedDevices(): Promise<any[]> {
    if (!this.db) await this.init();
    return this.db!.getAllFromIndex('deviceStates', 'by-status', 'connected');
  }
}

export const indexedDBManager = new IndexedDBManager();
```

##### 3.4.2 离线状态管理

```typescript
// src/pwa/hooks/useOffline.ts
import { useState, useEffect } from 'react';
import { indexedDBManager } from '../storage/indexeddb';

export interface OfflineState {
  isOnline: boolean;
  offlineReady: boolean;
  syncQueueLength: number;
  cachedDataSize: number;
}

export function useOffline(): OfflineState {
  const [state, setState] = useState<OfflineState>({
    isOnline: navigator.onLine,
    offlineReady: false,
    syncQueueLength: 0,
    cachedDataSize: 0,
  });

  useEffect(() => {
    // 监听网络状态
    const handleOnline = () => {
      setState(prev => ({ ...prev, isOnline: true }));
      syncOfflineData();
    };

    const handleOffline = () => {
      setState(prev => ({ ...prev, isOnline: false }));
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    // 检查Service Worker状态
    checkOfflineReady();

    // 定期更新状态
    const interval = setInterval(updateState, 5000);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
      clearInterval(interval);
    };
  }, []);

  const checkOfflineReady = async () => {
    const registration = await navigator.serviceWorker.getRegistration();
    const offlineReady = !!registration &&
                        await registration.then(async reg => {
                          const caches = await self.caches?.keys() ?? [];
                          return caches.some(key => key.includes('hailan-pro'));
                        });

    setState(prev => ({ ...prev, offlineReady }));
  };

  const updateState = async () => {
    const syncQueue = await indexedDBManager.getSyncQueue();
    const cacheSize = await getCacheSize();

    setState(prev => ({
      ...prev,
      syncQueueLength: syncQueue.length,
      cachedDataSize: cacheSize,
    }));
  };

  const syncOfflineData = async () => {
    try {
      // 发送消息给Service Worker执行同步
      const registration = await navigator.serviceWorker.ready;
      registration.active?.postMessage({ type: 'SYNC_NOW' });

      // 同步IndexedDB中的数据
      const syncQueue = await indexedDBManager.getSyncQueue();

      for (const item of syncQueue) {
        try {
          const response = await fetch(item.url, {
            method: item.method,
            headers: item.headers,
            body: item.body,
          });

          if (response.ok) {
            await indexedDBManager.removeSyncItem(item.id);
          }
        } catch (error) {
          console.error('Sync failed:', error);
        }
      }

      updateState();
    } catch (error) {
      console.error('Sync error:', error);
    }
  };

  async function getCacheSize(): Promise<number> {
    if ('serviceWorker' in navigator && 'caches' in window) {
      const cacheNames = await caches.keys();
      let totalSize = 0;

      for (const name of cacheNames) {
        if (name.includes('hailan-pro')) {
          const cache = await caches.open(name);
          const keys = await cache.keys();

          for (const key of keys) {
            const response = await cache.match(key);
            if (response) {
              const blob = await response.blob();
              totalSize += blob.size;
            }
          }
        }
      }

      return totalSize;
    }
    return 0;
  }

  return state;
}
```

#### 3.5 推送通知系统

##### 3.5.1 Web Push配置

```typescript
// src/pwa/push/index.ts
import webpush from 'web-push';

// VAPID密钥配置
const VAPID_KEYS = {
  publicKey: process.env.VAPID_PUBLIC_KEY!,
  privateKey: process.env.VAPID_PRIVATE_KEY!,
  subject: 'mailto:admin@0379.email',
};

// 初始化Web Push
webpush.setVapidDetails(
  VAPID_KEYS.subject,
  VAPID_KEYS.publicKey,
  VAPID_KEYS.privateKey
);

// 通知类型
export enum NotificationType {
  ORDER_UPDATE = 'order_update',
  AI_RESPONSE = 'ai_response',
  DEVICE_ALERT = 'device_alert',
  HEALTH_REMINDER = 'health_reminder',
  PRIVACY_ALERT = 'privacy_alert',
}

// 通知Payload接口
export interface PushNotificationPayload {
  type: NotificationType;
  title: string;
  body: string;
  icon?: string;
  badge?: string;
  image?: string;
  data?: any;
  actions?: NotificationAction[];
  requireInteraction?: boolean;
  silent?: boolean;
  urgency?: 'very-low' | 'low' | 'normal' | 'high';
}

// 发送推送通知
export async function sendPushNotification(
  subscription: PushSubscription,
  payload: PushNotificationPayload
): Promise<boolean> {
  try {
    await webpush.sendNotification(subscription, JSON.stringify(payload), {
      TTL: 24 * 60 * 60, // 24小时
      urgency: payload.urgency || 'normal',
    });

    return true;
  } catch (error: any) {
    // 订阅过期，需要重新订阅
    if (error.statusCode === 410) {
      await removeSubscription(subscription);
    }
    return false;
  }
}

// 批量发送
export async function sendBulkPushNotification(
  userIds: string[],
  payload: PushNotificationPayload
): Promise<{ success: number; failed: number }> {
  const subscriptions = await getUserSubscriptions(userIds);

  const results = await Promise.allSettled(
    subscriptions.map(sub => sendPushNotification(sub, payload))
  );

  const success = results.filter(r => r.status === 'fulfilled' && r.value).length;
  const failed = results.length - success;

  return { success, failed };
}

// 获取用户订阅
async function getUserSubscriptions(userIds: string[]): Promise<PushSubscription[]> {
  // 从数据库获取用户的推送订阅
  return [];
}

// 移除过期订阅
async function removeSubscription(subscription: PushSubscription): Promise<void> {
  // 从数据库删除订阅
}
```

##### 3.5.2 前端订阅管理

```typescript
// src/pwa/hooks/usePushNotification.ts
import { useState, useEffect } from 'react';
import { indexedDBManager } from '../storage/indexeddb';

interface PushSubscriptionState {
  permission: NotificationPermission;
  subscribed: boolean;
  subscription: PushSubscription | null;
}

export function usePushNotification() {
  const [state, setState] = useState<PushSubscriptionState>({
    permission: 'default',
    subscribed: false,
    subscription: null,
  });

  useEffect(() => {
    checkSubscription();
  }, []);

  const checkSubscription = async () => {
    const permission = Notification.permission;
    setState(prev => ({ ...prev, permission }));

    if (permission === 'granted') {
      const registration = await navigator.serviceWorker.ready;
      const subscription = await registration.pushManager.getSubscription();

      setState(prev => ({
        ...prev,
        subscribed: !!subscription,
        subscription,
      }));
    }
  };

  const requestPermission = async (): Promise<boolean> => {
    if (!('Notification' in window)) {
      console.warn('Notification not supported');
      return false;
    }

    const permission = await Notification.requestPermission();
    setState(prev => ({ ...prev, permission }));

    if (permission === 'granted') {
      return await subscribe();
    }

    return false;
  };

  const subscribe = async (): Promise<boolean> => {
    try {
      const registration = await navigator.serviceWorker.ready;
      const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: urlBase64ToUint8Array(
          import.meta.env.VITE_VAPID_PUBLIC_KEY
        ),
      });

      // 保存订阅到服务器
      await saveSubscriptionToServer(subscription);

      setState(prev => ({
        ...prev,
        subscribed: true,
        subscription,
      }));

      return true;
    } catch (error) {
      console.error('Subscription failed:', error);
      return false;
    }
  };

  const unsubscribe = async (): Promise<void> => {
    if (state.subscription) {
      await state.subscription.unsubscribe();

      // 从服务器删除订阅
      await removeSubscriptionFromServer(state.subscription);

      setState(prev => ({
        ...prev,
        subscribed: false,
        subscription: null,
      }));
    }
  };

  const saveSubscriptionToServer = async (subscription: PushSubscription) => {
    // 发送订阅信息到后端
  };

  const removeSubscriptionFromServer = async (subscription: PushSubscription) => {
    // 从后端删除订阅
  };

  return {
    ...state,
    requestPermission,
    subscribe,
    unsubscribe,
  };
}

// 工具函数：VAPID Key转换
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }

  return outputArray;
}
```

##### 3.5.3 通知处理Service Worker

```typescript
// src/pwa/service-worker/push.ts
self.addEventListener('push', (event: PushEvent) => {
  if (!event.data) return;

  try {
    const payload = event.data.json() as PushNotificationPayload;

    const options: NotificationOptions = {
      body: payload.body,
      icon: payload.icon || '/icons/icon-192x192.png',
      badge: payload.badge || '/icons/badge-72x72.png',
      image: payload.image,
      data: payload.data,
      actions: payload.actions,
      requireInteraction: payload.requireInteraction,
      silent: payload.silent,
      tag: payload.type,
    };

    event.waitUntil(
      self.registration.showNotification(payload.title, options)
    );
  } catch (error) {
    console.error('[SW] Push error:', error);
  }
});

// 通知点击处理
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  event.notification.close();

  const { action, data } = event.notification.data || {};

  event.waitUntil(
    (async () => {
      const clients = await self.clients.matchAll({
        type: 'window',
        includeUncontrolled: true,
      });

      // 根据通知类型和操作处理导航
      let url = '/';

      switch (data?.type) {
        case 'order_update':
          url = `/orders/${data?.orderId}`;
          break;
        case 'ai_response':
          url = '/ai-assistant';
          break;
        case 'device_alert':
          url = `/devices/${data?.deviceId}`;
          break;
        case 'health_reminder':
          url = '/profile/health';
          break;
        case 'privacy_alert':
          url = '/privacy-mode';
          break;
      }

      // 尝试聚焦现有窗口
      for (const client of clients) {
        if (client.url === self.registration.scope && 'focus' in client) {
          await client.focus();
          await client.navigate(url);
          return;
        }
      }

      // 打开新窗口
      if ('openWindow' in self.clients) {
        await self.clients.openWindow(url);
      }
    })()
  );
});

// 通知关闭处理
self.addEventListener('notificationclose', (event: NotificationEvent) => {
  // 记录通知关闭事件用于分析
  logNotificationClose(event.notification);
});

function logNotificationClose(notification: Notification): void {
  // 发送分析数据
}
```

#### 3.6 更新管理

##### 3.6.1 自动更新检测

```typescript
// src/pwa/hooks/useServiceWorkerUpdate.ts
import { useEffect, useState, useCallback } from 'react';

export function useServiceWorkerUpdate() {
  const [waitingWorker, setWaitingWorker] = useState<ServiceWorker | null>(null);
  const [hasUpdate, setHasUpdate] = useState(false);

  useEffect(() => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.ready.then((registration) => {
        // 检查是否有等待中的Service Worker
        if (registration.waiting) {
          setWaitingWorker(registration.waiting);
          setHasUpdate(true);
        }

        // 监听更新
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;

          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // 新的Service Worker已安装，当前页面被控制
                setWaitingWorker(newWorker);
                setHasUpdate(true);
              }
            });
          }
        });
      });
    }
  }, []);

  const skipWaiting = useCallback(() => {
    if (waitingWorker) {
      waitingWorker.postMessage({ type: 'SKIP_WAITING' });

      // 刷新页面以应用更新
      window.location.reload();
    }
  }, [waitingWorker]);

  return { hasUpdate, skipWaiting };
}
```

##### 3.6.2 更新提示UI

```typescript
// src/components/pwa/UpdatePrompt.tsx
import { useServiceWorkerUpdate } from '@/pwa/hooks/useServiceWorkerUpdate';

export function UpdatePrompt() {
  const { hasUpdate, skipWaiting } = useServiceWorkerUpdate();

  if (!hasUpdate) return null;

  return (
    <div className="fixed bottom-4 right-4 z-50 animate-slide-up">
      <div className="bg-slate-900 text-white rounded-lg shadow-xl p-4 max-w-sm">
        <div className="flex items-start gap-3">
          <div className="flex-1">
            <h3 className="font-semibold text-lg mb-1">新版本可用</h3>
            <p className="text-slate-300 text-sm">
              海蓝Pro有新版本更新，点击按钮即可获取最新功能和修复。
            </p>
          </div>
          <button
            onClick={skipWaiting}
            className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
          >
            立即更新
          </button>
        </div>
      </div>
    </div>
  );
}
```

#### 3.7 性能监控

##### 3.7.1 Core Web Vitals监控

```typescript
// src/pwa/monitoring/metrics.ts
import { onCLS, onFID, onFCP, onLCP, onTTFB } from 'web-vitals';

export interface WebVitals {
  cls: number;  // Cumulative Layout Shift
  fid: number;  // First Input Delay
  fcp: number;  // First Contentful Paint
  lcp: number;  // Largest Contentful Paint
  ttfb: number; // Time to First Byte
}

export function initWebVitals(): void {
  onCLS((metric) => sendMetric('CLS', metric));
  onFID((metric) => sendMetric('FID', metric));
  onFCP((metric) => sendMetric('FCP', metric));
  onLCP((metric) => sendMetric('LCP', metric));
  onTTFB((metric) => sendMetric('TTFB', metric));
}

function sendMetric(name: string, metric: any): void {
  // 发送到分析服务
  const data = {
    name,
    value: metric.value,
    rating: metric.rating,
    delta: metric.delta,
    id: metric.id,
    navigationType: metric.navigationType,
    timestamp: Date.now(),
    url: window.location.href,
    userAgent: navigator.userAgent,
  };

  // 发送到后端或分析平台
  if (navigator.sendBeacon) {
    const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
    navigator.sendBeacon('/api/analytics/web-vitals', blob);
  }
}
```

##### 3.7.2 PWA特定指标

```typescript
// src/pwa/monitoring/pwa-metrics.ts
export interface PWAMetrics {
  installConversionRate: number;
  offlineUsageTime: number;
  pushNotificationOptIn: number;
  cacheHitRate: number;
  syncSuccessRate: number;
}

class PWAMetricsCollector {
  private metrics: Partial<PWAMetrics> = {};

  // 追踪安装转化
  trackInstallPrompt(prompt: any): void {
    prompt.addEventListener('dismiss', () => {
      this.metrics.installConversionRate = 0;
    });

    prompt.addEventListener('accept', () => {
      this.metrics.installConversionRate = 1;
    });
  }

  // 追踪离线使用时间
  trackOfflineUsage(): void {
    let offlineStart: number | null = null;

    window.addEventListener('offline', () => {
      offlineStart = Date.now();
    });

    window.addEventListener('online', () => {
      if (offlineStart) {
        const offlineDuration = Date.now() - offlineStart;
        this.metrics.offlineUsageTime =
          (this.metrics.offlineUsageTime || 0) + offlineDuration;
        offlineStart = null;
      }
    });
  }

  // 追踪缓存命中率
  async calculateCacheHitRate(): Promise<number> {
    if ('serviceWorker' in navigator && 'caches' in window) {
      const cacheNames = await caches.keys();
      let hits = 0;
      let total = 0;

      for (const name of cacheNames) {
        if (name.includes('hailan-pro')) {
          const cache = await caches.open(name);
          const keys = await cache.keys();
          total += keys.length;

          for (const key of keys) {
            const response = await cache.match(key);
            if (response) hits++;
          }
        }
      }

      return total > 0 ? hits / total : 0;
    }
    return 0;
  }

  // 获取所有指标
  async getMetrics(): Promise<PWAMetrics> {
    return {
      installConversionRate: this.metrics.installConversionRate ?? 0,
      offlineUsageTime: this.metrics.offlineUsageTime ?? 0,
      pushNotificationOptIn: this.metrics.pushNotificationOptIn ?? 0,
      cacheHitRate: await this.calculateCacheHitRate(),
      syncSuccessRate: this.metrics.syncSuccessRate ?? 0,
    };
  }
}

export const pwaMetricsCollector = new PWAMetricsCollector();
```

### 4. 部署配置

#### 4.1 Vite PWA插件配置

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: [
        'icons/*.png',
        'images/*.png',
        'fonts/*.woff2',
      ],
      manifest: {
        name: 'HaiLan Pro - 海蓝健康生活管理',
        short_name: '海蓝Pro',
        description: '新一代高端私密智能情趣健康生活管理平台',
        theme_color: '#1E3A5F',
        background_color: '#0F172A',
        display: 'standalone',
        icons: [
          {
            src: '/icons/icon-192x192.png',
            sizes: '192x192',
            type: 'image/png',
          },
          {
            src: '/icons/icon-512x512.png',
            sizes: '512x512',
            type: 'image/png',
          },
        ],
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\.hailan\.pro\/public\/.*/i,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'hailan-api-public',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 300, // 5分钟
              },
              cacheableResponse: {
                statuses: [0, 200],
              },
            },
          },
          {
            urlPattern: /\.(?:png|jpg|jpeg|svg|gif|webp)$/i,
            handler: 'CacheFirst',
            options: {
              cacheName: 'hailan-images',
              expiration: {
                maxEntries: 200,
                maxAgeSeconds: 604800, // 7天
              },
            },
          },
        ],
      },
      devOptions: {
        enabled: true,
        type: 'module',
      },
    }),
  ],
});
```

### 5. 最佳实践

#### 5.1 隐私保护
- 敏感数据不缓存在Service Worker中
- 推送通知内容需脱敏处理
- 离线数据加密存储

#### 5.2 性能优化
- 预缓存关键资源
- 使用StaleWhileRevalidate平衡速度与新鲜度
- 限制缓存大小，定期清理

#### 5.3 用户体验
- 提供离线状态提示
- 平滑的更新过渡
- 渐进式功能增强

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
