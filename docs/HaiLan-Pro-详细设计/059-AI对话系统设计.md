---
file: 059-AI对话系统设计.md
description: HaiLan Pro 基于LLM的AI对话系统设计，包含上下文管理、意图识别、响应生成
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-详细设计,[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 059 AI对话系统设计

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-详细设计-AI对话系统设计相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范AI对话系统设计相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. AI对话系统设计

#### 3.1 系统架构

##### 3.1.1 AI对话系统架构

```typescript
// AI对话系统架构定义
interface AIChatSystemArchitecture {
  // 表现层
  presentation: {
    frontend: 'Vue3 + WebSocket';
    mobile: 'PWA + Web Bluetooth';
    protocols: ['WebSocket', 'HTTP', 'WebRTC'];
  };

  // 网关层
  gateway: {
    loadBalancer: 'Nginx';
    apiGateway: 'API Gateway';
    rateLimiter: 'Token Bucket算法';
    auth: 'JWT验证';
  };

  // 业务层
  business: {
    chatService: '对话管理服务';
    intentService: '意图识别服务';
    contextService: '上下文管理服务';
    responseService: '响应生成服务';
    knowledgeService: '知识库服务';
  };

  // AI层
  ai: {
    llm: 'GPT-4 / 文心一言';
    framework: 'LangChain';
    rag: 'RAG (检索增强生成)';
    embedding: 'text-embedding-ada-002';
    vectorDb: 'Chroma / Pinecone';
  };

  // 数据层
  data: {
    conversations: 'MongoDB (对话历史)';
    knowledgeBase: '向量数据库 (知识库)';
    userProfiles: 'PostgreSQL (用户画像)';
    cache: 'Redis (会话缓存)';
  };
}
```

##### 3.1.2 系统流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户请求                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      预处理模块                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  用户认证     │  │  请求限流     │  │  参数验证     │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      意图识别模块                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  文本分析     │  │  意图分类     │  │  实体提取     │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      上下文管理模块                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  历史加载     │  │  上下文构建   │  │  话题追踪     │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      RAG检索模块                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  向量化       │  │  相似度搜索   │  │  结果排序     │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      LLM生成模块                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  提示词构建   │  │  LLM调用      │  │  流式输出     │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      后处理模块                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  内容过滤     │  │  格式化       │  │  安全检查     │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        用户响应                                   │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.2 对话上下文管理

##### 3.2.1 上下文结构

```typescript
// 对话上下文管理
interface ChatContextManagement {
  // 会话上下文
  session: {
    sessionId: string;          // 会话ID
    userId: string;             // 用户ID
    startTime: Date;            // 开始时间
    lastActivity: Date;         // 最后活动时间
    messageCount: number;       // 消息数量
  };

  // 对话历史
  history: {
    messages: ChatMessage[];    // 消息列表
    maxHistory: 10;             // 最大历史轮数
    summary: string;            // 对话摘要
  };

  // 用户状态
  userState: {
    intent: string;             // 当前意图
    entities: Record<string, any>; // 提取的实体
    sentiment: 'positive' | 'neutral' | 'negative'; // 情感
    topics: string[];           // 当前话题列表
  };

  // 上下文变量
  variables: {
    currentProduct?: string;   // 当前讨论的商品
    currentCategory?: string;  // 当前分类
    cartItems?: string[];      // 购物车商品
    lastQuery?: string;         // 上一次查询
  };
}
```

##### 3.2.2 上下文管理实现

```typescript
// 对话上下文服务
// modules/ai/services/context.service.ts
import { Injectable } from '@nestjs/common';
import { Redis } from 'ioredis';

@Injectable()
export class ChatContextService {
  constructor(
    @Inject('REDIS') private readonly redis: Redis
  ) {}

  /**
   * 加载对话历史
   */
  async loadHistory(sessionId: string, userId: string): Promise<ChatMessage[]> {
    // 尝试从缓存获取
    const cached = await this.redis.get(`chat:history:${sessionId}`);
    if (cached) {
      return JSON.parse(cached);
    }

    // 从数据库加载
    const history = await this.conversationModel.find({
      sessionId,
      userId
    }).sort({ timestamp: 1 }).limit(10).exec();

    // 缓存到Redis
    await this.redis.setex(
      `chat:history:${sessionId}`,
      3600, // 1小时
      JSON.stringify(history)
    );

    return history;
  }

  /**
   * 追加消息到历史
   */
  async appendMessage(sessionId: string, message: ChatMessage): Promise<void> {
    // 保存到数据库
    await this.conversationModel.create({
      sessionId,
      userId: message.userId,
      role: message.role,
      content: message.content,
      timestamp: message.timestamp
    });

    // 更新缓存
    const history = await this.loadHistory(sessionId, message.userId);
    history.push(message);

    // 限制历史长度
    if (history.length > 10) {
      history.shift();
    }

    await this.redis.setex(
      `chat:history:${sessionId}`,
      3600,
      JSON.stringify(history)
    );
  }

  /**
   * 更新用户状态
   */
  async updateUserState(sessionId: string, state: Partial<UserState>): Promise<void> {
    await this.redis.setex(
      `chat:state:${sessionId}`,
      1800, // 30分钟
      JSON.stringify(state)
    );
  }

  /**
   * 获取用户状态
   */
  async getUserState(sessionId: string): Promise<UserState | null> {
    const cached = await this.redis.get(`chat:state:${sessionId}`);
    return cached ? JSON.parse(cached) : null;
  }

  /**
   * 清理过期上下文
   */
  async cleanupExpiredContext(): Promise<void> {
    const keys = await this.redis.keys('chat:*');
    for (const key of keys) {
      const ttl = await this.redis.ttl(key);
      if (ttl === -1) { // 没有过期时间，设置默认过期
        await this.redis.expire(key, 7200); // 2小时
      }
    }
  }
}
```

#### 3.3 意图识别设计

##### 3.3.1 意图分类

```typescript
// 用户意图分类
interface UserIntentClassification {
  // 商品相关意图
  product: {
    search: {
      patterns: ['搜索', '查找', '有没有', '看看', '推荐'];
      entities: ['keyword', 'category', 'priceRange'];
      priority: 'high';
    };
    detail: {
      patterns: ['详情', '介绍', '怎么样', '如何使用'];
      entities: ['productId'];
      priority: 'high';
    };
    compare: {
      patterns: ['对比', '区别', '哪个好'];
      entities: ['products'];
      priority: 'medium';
    };
  };

  // 购物相关意图
  shopping: {
    addToCart: {
      patterns: ['加入购物车', '要这个', '买一个', '下单'];
      entities: ['productId', 'quantity'];
      priority: 'high';
    };
    checkout: {
      patterns: ['去结算', '结账', '支付'];
      entities: [];
      priority: 'high';
    };
    orderStatus: {
      patterns: ['订单', '我的订单', '物流'];
      entities: ['orderId'];
      priority: 'medium';
    };
  };

  // 健康咨询意图
  health: {
    consult: {
      patterns: ['咨询', '建议', '怎么', '如何', '是否可以'];
      entities: ['symptom', 'bodyPart'];
      priority: 'high';
    };
    knowledge: {
      patterns: ['什么是', '科普', '了解', '知识'];
      entities: ['topic'];
      priority: 'medium';
    };
  };

  // 闲聊意图
  chitchat: {
    greeting: {
      patterns: ['你好', '嗨', '在吗', '哈喽'];
      priority: 'low';
    };
    emotion: {
      patterns: ['开心', '难过', '压力大', '累'];
      priority: 'medium';
    };
  };
}
```

##### 3.3.2 意图识别实现

```typescript
// 意图识别服务
// modules/ai/services/intent.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class IntentRecognitionService {
  private intentPatterns: Map<string, RegExp[]>;

  constructor(private readonly configService: ConfigService) {
    this.initPatterns();
  }

  /**
   * 初始化意图模式
   */
  private initPatterns(): void {
    this.intentPatterns = new Map([
      ['search', [/搜索?(.+)/, /查找?(.+)/, /有没有(.+)/, /推荐?(.+)/]),
      ['detail', [/详情/, /介绍/, /怎么样/, /如何使用/]],
      ['addToCart', [/加入购物车/, /要这个/, /买一个/, /下单/]],
      ['checkout', [/去结算/, /结账/, /支付/]],
      ['consult', [/咨询/, /建议/, /怎么/, /是否可以/]],
      ['greeting', [/你好/, /嗨/, /在吗/, /哈喽/]],
      ['emotion', [/开心/, /难过/, /压力大/, /累/]]
    ]);
  }

  /**
   * 识别用户意图
   */
  async recognizeIntent(message: string): Promise<IntentResult> {
    // 1. 清理输入
    const cleanMessage = this.cleanInput(message);

    // 2. 模式匹配
    const matched = this.patternMatch(cleanMessage);

    // 3. 实体提取
    const entities = this.extractEntities(cleanMessage);

    // 4. 情感分析
    const sentiment = this.analyzeSentiment(cleanMessage);

    return {
      intent: matched?.intent || 'unknown',
      confidence: matched?.confidence || 0,
      entities,
      sentiment,
      originalMessage: message
    };
  }

  /**
   * 模式匹配
   */
  private patternMatch(message: string): { intent: string; confidence: number } | null {
    for (const [intent, patterns] of this.intentPatterns.entries()) {
      for (const pattern of patterns) {
        const match = message.match(pattern);
        if (match) {
          return { intent, confidence: 0.9 };
        }
      }
    }
    return null;
  }

  /**
   * 实体提取
   */
  private extractEntities(message: string): Record<string, any> {
    const entities: Record<string, any> = {};

    // 提取价格范围
    const priceMatch = message.match(/(\d+)(?:块|元|钱)/g);
    if (priceMatch) {
      entities.priceRange = priceMatch.map(p => parseInt(p));
    }

    // 提取商品关键词
    const productKeywords = ['按摩仪', '精油', '手环', '玩具'];
    for (const keyword of productKeywords) {
      if (message.includes(keyword)) {
        entities.productType = keyword;
        break;
      }
    }

    // 提取数量
    const quantityMatch = message.match(/(\d+)(?:个|件|台)/g);
    if (quantityMatch) {
      entities.quantity = parseInt(quantityMatch[0]);
    }

    return entities;
  }

  /**
   * 情感分析
   */
  private analyzeSentiment(message: string): 'positive' | 'neutral' | 'negative' {
    const positiveWords = ['好', '棒', '喜欢', '开心', '满意', '爱'];
    const negativeWords = ['差', '不好', '失望', '难过', '讨厌', '烦'];

    const hasPositive = positiveWords.some(word => message.includes(word));
    const hasNegative = negativeWords.some(word => message.includes(word));

    if (hasPositive && !hasNegative) return 'positive';
    if (hasNegative && !hasPositive) return 'negative';
    return 'neutral';
  }

  /**
   * 清理输入
   */
  private cleanInput(message: string): string {
    return message
      .trim()
      .replace(/\s+/g, ' ')
      .replace(/[^\u4e00-\u9fa5a-z0-9\s]/gi, ''); // 保留中英文数字
      .toLowerCase();
  }
}
```

#### 3.4 RAG知识检索

##### 3.4.1 知识库设计

```typescript
// RAG知识库设计
interface RAGKnowledgeBase {
  // 知识库结构
  structure: {
    healthKnowledge: {
      name: '健康知识库';
      size: 500+;  // 条目数量
      update: '每月更新';
      source: '权威医学机构';
    };
    productKnowledge: {
      name: '商品知识库';
      size: 1000+;
      update: '每周更新';
      source: '产品说明 + 用户反馈';
    };
    faq: {
      name: '常见问题库';
      size: 200+;
      update: '每周更新';
      source: '用户提问 + 整理';
    };
  };

  // 向量化配置
  embedding: {
    model: 'text-embedding-ada-002';
    dimensions: 1536;
    batchSize: 100;
  };

  // 检索配置
  retrieval: {
    method: 'similarity_search';
    topK: 5;
    threshold: 0.7;
    scoreType: 'cosine';
  };
}
```

##### 3.4.2 RAG实现

```typescript
// RAG服务实现
// modules/ai/services/rag.service.ts
import { Injectable } from '@nestjs/common';
import { ChromaClient } from 'chromadb';

@Injectable()
export class RAGService {
  private chroma: ChromaClient;
  private collection: any;

  async onModuleInit() {
    // 初始化Chroma客户端
    this.chroma = new ChromaClient({
      path: process.env.CHROMA_PATH || './chroma_db'
    });

    // 获取或创建集合
    this.collection = await this.chroma.getOrCreateCollection({
      name: 'hailan_knowledge',
      metadata: { hnsw: 'space' },
      embeddingFunction: this.embeddingFunction.bind(this)
    });

    // 如果集合为空，加载知识
    const count = await this.collection.count();
    if (count === 0) {
      await this.loadKnowledgeBase();
    }
  }

  /**
   * 相似度搜索
   */
  async search(query: string, topK: number = 5): Promise<KnowledgeResult[]> {
    // 查询向量化
    const queryEmbedding = await this.embeddingFunction(query);

    // 相似度搜索
    const results = await this.collection.query({
      queryEmbeddings: [queryEmbedding],
      nResults: topK,
      include: ['documents', 'metadatas', 'distances']
    });

    // 格式化结果
    return results.documents[0].map((doc: string, i: number) => ({
      text: doc,
      metadata: results.metadatas[0][i],
      score: 1 - results.distances[0][i], // 转换为相似度
      source: results.metadatas[0][i].source
    })).filter(r => r.score >= 0.7); // 过滤低分结果
  }

  /**
   * 向量化函数
   */
  private async embeddingFunction(texts: string[]): Promise<number[][]> {
    // 调用OpenAI Embedding API
    const response = await fetch('https://api.openai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        input: texts,
        model: 'text-embedding-ada-002'
      })
    });

    const data = await response.json();
    return data.data.map((item: any) => item.embedding);
  }

  /**
   * 加载知识库
   */
  private async loadKnowledgeBase(): Promise<void> {
    const documents = [
      // 加载健康知识
      ...await this.loadHealthKnowledge(),
      // 加载商品知识
      ...await this.loadProductKnowledge(),
      // 加载FAQ
      ...await this.loadFAQ()
    ];

    // 批量添加到向量数据库
    await this.collection.add({
      ids: documents.map(d => d.id),
      documents: documents.map(d => d.text),
      metadatas: documents.map(d => d.metadata)
    });

    console.log(`知识库加载完成，共 ${documents.length} 条`);
  }

  /**
   * 构建RAG提示词
   */
  buildRAGPrompt(query: string, context: KnowledgeResult[]): string {
    const contextText = context
      .map((c, i) => `[${i + 1}] ${c.text}\n来源: ${c.source}`)
      .join('\n\n');

    return `
你是海蓝的健康顾问AI助手，名字叫"小蓝"。

参考知识：
${contextText}

用户问题：${query}

请根据以上知识回答用户问题。如果参考知识中没有相关信息，请告知用户。

注意事项：
1. 回答要专业、准确、友好
2. 如果涉及医疗建议，请说明"仅供参考，建议咨询专业医生"
3. 不要编造信息
4. 保持温暖、贴心的语气

回答：
    `.trim();
  }
}
```

#### 3.5 响应生成设计

##### 3.5.1 流式响应实现

```typescript
// 流式响应服务
// modules/ai/services/stream-response.service.ts
import { Injectable } from '@nestjs/common';
import { OpenAI } from 'openai';
import { Observable } from 'rxjs';

@Injectable()
export class StreamResponseService {
  private openai: OpenAI;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  /**
   * 流式对话
   */
  async chatStream(messages: ChatMessage[]): Promise<Observable<string>> {
    return new Observable(subscriber => {
      const stream = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: messages,
        temperature: 0.7,
        max_tokens: 2000,
        stream: true
      });

      let fullResponse = '';

      for await (const chunk of stream) {
        const content = chunk.choices[0]?.delta?.content || '';
        if (content) {
          fullResponse += content;
          subscriber.next(content);
        }
      }

      subscriber.complete();
    });
  }

  /**
   * 普通对话
   */
  async chat(messages: ChatMessage[]): Promise<string> {
    const response = await this.openai.chat.completions.create({
      model: 'gpt-4',
      messages: messages,
      temperature: 0.7,
      max_tokens: 2000
    });

    return response.choices[0].message.content || '';
  }
}
```

#### 3.6 安全与合规

##### 3.6.1 内容过滤

```typescript
// 内容过滤服务
// modules/ai/services/content-filter.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class ContentFilterService {
  // 敏感词列表
  private sensitiveWords: string[] = [
    // 违法词汇
    // 色情词汇
    // 暴力词汇
  ];

  /**
   * 检查内容安全
   */
  async checkSafety(content: string): Promise<SafetyResult> {
    // 1. 敏感词检查
    const hasSensitiveWord = this.checkSensitiveWords(content);

    // 2. 内容长度检查
    const isTooLong = content.length > 1000;

    // 3. 特殊字符检查
    const hasTooManySpecialChars = /[^a-zA-Z0-9\u4e00-\u9fa5\s]/g.test(content)
      && (content.match(/[^a-zA-Z0-9\u4e00-\u9fa5\s]/g) || []).length > content.length * 0.3;

    return {
      safe: !hasSensitiveWord && !isTooLong && !hasTooManySpecialChars,
      issues: [
        hasSensitiveWord ? '包含敏感词汇' : null,
        isTooLong ? '内容过长' : null,
        hasTooManySpecialChars ? '特殊字符过多' : null
      ].filter(Boolean)
    };
  }

  /**
   * 过滤响应内容
   */
  filterResponse(content: string): string {
    // 替换敏感词
    let filtered = content;

    for (const word of this.sensitiveWords) {
      const regex = new RegExp(word, 'gi');
      filtered = filtered.replace(regex, '***');
    }

    return filtered;
  }

  /**
   * 添加医疗免责声明
   */
  addMedicalDisclaimer(content: string, hasMedicalAdvice: boolean): string {
    if (!hasMedicalAdvice) {
      return content;
    }

    return `${content}\n\n⚠️ **温馨提示**：以上建议仅供参考，不能替代专业医生的诊断和治疗。如有身体不适，请及时就医。`;
  }
}
```

---

## 附录

### A. 提示词模板库

### B. 对话场景示例

### C. API接口文档

### D. 术语表

| 术语 | 说明 |
|-----|------|
| **LLM** | Large Language Model，大语言模型 |
| **RAG** | Retrieval Augmented Generation，检索增强生成 |
| **Embedding** | 向量嵌入 |
| **Context** | 对话上下文 |

### E. 修订历史

| 版本 | 日期 | 修订人 | 修订内容 |
|-----|------|-------|---------|
| v1.0.0 | 2026-01-26 | YanYuCloudCube Team | 初始版本创建 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
