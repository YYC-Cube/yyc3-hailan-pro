---
file: 050-业务逻辑核心代码实现.md
description: HaiLan Pro 项目核心业务逻辑的代码实现与注释规范，保障逻辑正确性
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-详细设计,[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 050 业务逻辑核心代码实现

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-详细设计-业务逻辑核心代码实现相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范业务逻辑核心代码实现相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 业务逻辑核心代码实现

#### 3.1 用户认证模块

##### 3.1.1 用户注册逻辑

```typescript
// src/modules/auth/services/auth.service.ts
import { Injectable, ConflictException, UnauthorizedException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../entities/user.entity';
import { RegisterDto } from '../dto/register.dto';
import { LoginDto } from '../dto/login.dto';
import { JwtService } from '@nestjs/jwt';
import { HashUtil } from '@/shared/utils/hash.util';
import { EmailService } from '@/shared/services/email.service';

/**
 * 用户认证服务
 * 负责用户注册、登录、Token管理等核心认证逻辑
 */
@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    private readonly jwtService: JwtService,
    private readonly emailService: EmailService,
  ) {}

  /**
   * 用户注册
   * @param registerDto 注册信息
   * @returns 注册结果和Token
   */
  async register(registerDto: RegisterDto) {
    const { email, password, nickname, verificationCode } = registerDto;

    // 1. 验证验证码
    await this.verifyEmailCode(email, verificationCode);

    // 2. 检查邮箱是否已存在
    const existingUser = await this.userRepository.findOne({
      where: { email }
    });

    if (existingUser) {
      throw new ConflictException('该邮箱已被注册');
    }

    // 3. 对密码进行加密（使用bcrypt + 自定义盐值）
    const hashedPassword = await HashUtil.hash(password);

    // 4. 创建用户
    const user = this.userRepository.create({
      id: this.generateUserId(),
      email,
      password: hashedPassword,
      nickname: nickname || this.generateNickname(email),
      avatar: this.getDefaultAvatar(),
      privacyMode: true, // 默认开启隐私模式
      status: 'active'
    });

    // 5. 保存用户
    await this.userRepository.save(user);

    // 6. 生成Token
    const tokens = await this.generateTokens(user);

    // 7. 发送欢迎邮件（异步，不阻塞响应）
    this.emailService.sendWelcomeEmail(user.email, user.nickname).catch(err => {
      console.error('发送欢迎邮件失败:', err);
    });

    // 8. 返回结果
    return {
      user: this.sanitizeUser(user),
      ...tokens
    };
  }

  /**
   * 用户登录
   * @param loginDto 登录信息
   * @returns 登录结果和Token
   */
  async login(loginDto: LoginDto) {
    const { account, password } = loginDto;

    // 1. 查找用户（支持邮箱或手机号登录）
    const user = await this.userRepository.findOne({
      where: [
        { email: account },
        { phone: account }
      ]
    });

    if (!user) {
      throw new UnauthorizedException('账号或密码错误');
    }

    // 2. 验证密码
    const isPasswordValid = await HashUtil.compare(password, user.password);

    if (!isPasswordValid) {
      throw new UnauthorizedException('账号或密码错误');
    }

    // 3. 检查账户状态
    if (user.status === 'banned') {
      throw new UnauthorizedException('该账户已被禁用');
    }

    if (user.status === 'deleted') {
      throw new UnauthorizedException('该账户已被删除');
    }

    // 4. 更新最后登录时间
    user.lastLoginAt = new Date();
    user.lastLoginIp = ''; // 从请求上下文获取
    await this.userRepository.save(user);

    // 5. 生成Token
    const tokens = await this.generateTokens(user);

    // 6. 返回结果
    return {
      user: this.sanitizeUser(user),
      ...tokens
    };
  }

  /**
   * 刷新Token
   * @param refreshToken 刷新令牌
   * @returns 新的Token
   */
  async refreshAccessToken(refreshToken: string) {
    try {
      // 1. 验证刷新令牌
      const payload = this.jwtService.verify(refreshToken, {
        secret: process.env.JWT_REFRESH_SECRET
      });

      // 2. 检查Token类型
      if (payload.type !== 'refresh') {
        throw new UnauthorizedException('无效的刷新令牌');
      }

      // 3. 获取用户
      const user = await this.userRepository.findOne({
        where: { id: payload.sub }
      });

      if (!user) {
        throw new UnauthorizedException('用户不存在');
      }

      // 4. 生成新的Token
      return this.generateTokens(user);

    } catch (error) {
      throw new UnauthorizedException('刷新令牌已过期或无效');
    }
  }

  /**
   * 生成访问令牌和刷新令牌
   * @private
   */
  private async generateTokens(user: User) {
    const payload = {
      sub: user.id,
      email: user.email,
      type: 'access'
    };

    const accessPayload = { ...payload, type: 'access' as const };
    const refreshPayload = { ...payload, type: 'refresh' as const };

    const [accessToken, refreshToken] = await Promise.all([
      this.jwtService.signAsync(accessPayload, {
        expiresIn: process.env.JWT_ACCESS_EXPIRES_IN || '2h'
      }),
      this.jwtService.signAsync(refreshPayload, {
        secret: process.env.JWT_REFRESH_SECRET,
        expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d'
      })
    ]);

    return {
      accessToken,
      refreshToken,
      expiresIn: 7200 // 2小时
    };
  }

  /**
   * 验证邮箱验证码
   * @private
   */
  private async verifyEmailCode(email: string, code: string): Promise<void> {
    // 从Redis获取验证码
    const storedCode = await this.redisService.get(
      `email:code:${email}`
    );

    if (!storedCode || storedCode !== code) {
      throw new UnauthorizedException('验证码错误或已过期');
    }

    // 删除已使用的验证码
    await this.redisService.del(`email:code:${email}`);
  }

  /**
   * 生成用户ID
   * @private
   */
  private generateUserId(): string {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 10);
    return `user_${timestamp}${random}`;
  }

  /**
   * 从邮箱生成昵称
   * @private
   */
  private generateNickname(email: string): string {
    const prefix = email.split('@')[0];
    return `海蓝_${prefix.substring(0, 6)}`;
  }

  /**
   * 获取默认头像
   * @private
   */
  private getDefaultAvatar(): string {
    const random = Math.floor(Math.random() * 10);
    return `https://cdn.hailan.com/avatars/default/${random}.png`;
  }

  /**
   * 清理用户敏感信息
   * @private
   */
  private sanitizeUser(user: User): Partial<User> {
    const { password, ...sanitized } = user;
    return sanitized;
  }
}
```

##### 3.1.2 权限验证守卫

```typescript
// src/modules/auth/guards/jwt-auth.guard.ts
import { Injectable, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Reflector } from '@nestjs/core';
import { JwtService } from '@nestjs/jwt';
import { RedisService } from '@/shared/services/redis.service';

/**
 * JWT认证守卫
 * 验证请求中的Token有效性，并提取用户信息
 */
@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(
    private readonly reflector: Reflector,
    private readonly jwtService: JwtService,
    private readonly redisService: RedisService,
  ) {
    super();
  }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // 1. 检查是否允许公开访问
    const isPublic = this.reflector.getAllAndOverride<boolean>(
      'isPublic',
      [context.getHandler(), context.getClass()]
    );

    if (isPublic) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      throw new UnauthorizedException('未提供认证令牌');
    }

    try {
      // 2. 验证Token
      const payload = await this.jwtService.verifyAsync(token, {
        secret: process.env.JWT_SECRET
      });

      // 3. 检查Token类型
      if (payload.type !== 'access') {
        throw new UnauthorizedException('令牌类型错误');
      }

      // 4. 检查Token是否在黑名单中（用于登出）
      const isBlacklisted = await this.redisService.exists(
        `token:blacklist:${token}`
      );

      if (isBlacklisted) {
        throw new UnauthorizedException('令牌已失效');
      }

      // 5. 将用户信息附加到请求对象
      request.user = payload;

      return true;

    } catch (error) {
      throw new UnauthorizedException('令牌无效或已过期');
    }
  }

  /**
   * 从请求头提取Token
   * @private
   */
  private extractTokenFromHeader(request: any): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

#### 3.2 商品管理模块

##### 3.2.1 商品搜索与筛选

```typescript
// src/modules/product/services/product.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Like, Between, In } from 'typeorm';
import { Product } from '../entities/product.entity';
import { ProductQueryDto } from '../dto/product-query.dto';
import { PaginatedResponse, ResponseWrapper } from '@/common/response.wrapper';

/**
 * 商品服务
 * 负责商品搜索、筛选、排序等核心业务逻辑
 */
@Injectable()
export class ProductService {
  constructor(
    @InjectRepository(Product)
    private readonly productRepository: Repository<Product>,
    private readonly responseWrapper: ResponseWrapper,
  ) {}

  /**
   * 搜索商品
   * @param queryDto 查询参数
   * @returns 分页商品列表
   */
  async searchProducts(queryDto: ProductQueryDto) {
    const {
      keyword,
      category,
      minPrice,
      maxPrice,
      inStock,
      sortBy = 'createdAt',
      sortOrder = 'DESC',
      page = 1,
      pageSize = 20
    } = queryDto;

    // 构建查询条件
    const queryBuilder = this.productRepository.createQueryBuilder('product');

    // 关键词搜索（商品名称、描述）
    if (keyword) {
      queryBuilder.andWhere(
        '(product.name LIKE :keyword OR product.description LIKE :keyword)',
        { keyword: `%${keyword}%` }
      );
    }

    // 分类筛选
    if (category) {
      queryBuilder.andWhere('product.category = :category', { category });
    }

    // 价格范围筛选
    if (minPrice !== undefined || maxPrice !== undefined) {
      if (minPrice !== undefined && maxPrice !== undefined) {
        queryBuilder.andWhere('product.price BETWEEN :minPrice AND :maxPrice', {
          minPrice,
          maxPrice
        });
      } else if (minPrice !== undefined) {
        queryBuilder.andWhere('product.price >= :minPrice', { minPrice });
      } else if (maxPrice !== undefined) {
        queryBuilder.andWhere('product.price <= :maxPrice', { maxPrice });
      }
    }

    // 库存筛选
    if (inStock) {
      queryBuilder.andWhere('product.stock > 0');
    }

    // 排序
    const validSortFields = ['price', 'sales', 'rating', 'createdAt'];
    const sortField = validSortFields.includes(sortBy) ? sortBy : 'createdAt';
    const order: 'ASC' | 'DESC' = sortOrder.toUpperCase() === 'ASC' ? 'ASC' : 'DESC';

    queryBuilder.orderBy(`product.${sortField}`, order);

    // 分页
    const skip = (page - 1) * pageSize;
    queryBuilder.skip(skip).take(pageSize);

    // 只查询上架商品
    queryBuilder.andWhere('product.status = :status', { status: 'published' });

    // 执行查询
    const [items, total] = await queryBuilder.getManyAndCount();

    return this.responseWrapper.paginated(items, total, page, pageSize);
  }

  /**
   * 获取商品详情
   * @param id 商品ID
   */
  async getProductDetail(id: string) {
    const product = await this.productRepository.findOne({
      where: { id, status: 'published' as any },
      relations: ['skus', 'reviews']
    });

    if (!product) {
      throw new NotFoundException('商品不存在或已下架');
    }

    // 增加浏览次数
    await this.incrementViewCount(id);

    return this.responseWrapper.success(product);
  }

  /**
   * 增加商品浏览次数
   * @private
   */
  private async incrementViewCount(productId: string): Promise<void> {
    await this.productRepository.increment(
      { id: productId },
      'viewCount',
      1
    );
  }

  /**
   * 获取热门商品
   * @param limit 返回数量
   */
  async getHotProducts(limit = 10) {
    const products = await this.productRepository.find({
      where: { status: 'published' as any },
      order: { sales: 'DESC' },
      take: limit
    });

    return this.responseWrapper.success(products);
  }

  /**
   * 获取推荐商品
   * @param userId 用户ID（可选，用于个性化推荐）
   * @param limit 返回数量
   */
  async getRecommendedProducts(userId?: string, limit = 10) {
    let products: Product[];

    if (userId) {
      // 基于用户历史行为的个性化推荐
      products = await this.getPersonalizedRecommendations(userId, limit);
    } else {
      // 默认推荐：高分新品
      products = await this.productRepository.find({
        where: { status: 'published' as any },
        order: { rating: 'DESC', createdAt: 'DESC' },
        take: limit
      });
    }

    return this.responseWrapper.success(products);
  }

  /**
   * 获取个性化推荐
   * @private
   */
  private async getPersonalizedRecommendations(userId: string, limit: number): Promise<Product[]> {
    // TODO: 实现基于用户画像和协同过滤的推荐算法
    // 这里简化为返回高分商品
    return this.productRepository.find({
      where: { status: 'published' as any },
      order: { rating: 'DESC' },
      take: limit
    });
  }
}
```

#### 3.3 订单处理模块

##### 3.3.1 订单创建流程

```typescript
// src/modules/order/services/order.service.ts
import { Injectable, Transaction, TransactionRepository } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource } from 'typeorm';
import { Order } from '../entities/order.entity';
import { OrderItem } from '../entities/order-item.entity';
import { Product } from '@/modules/product/entities/product.entity';
import { CreateOrderDto } from '../dto/create-order.dto';
import { CartService } from '@/modules/cart/services/cart.service';
import { PaymentService } from '@/modules/payment/services/payment.service';
import { InventoryService } from '@/modules/inventory/services/inventory.service';
import { ResponseWrapper } from '@/common/response.wrapper';

/**
 * 订单服务
 * 负责订单创建、支付、发货等核心业务逻辑
 */
@Injectable()
export class OrderService {
  constructor(
    @InjectRepository(Order)
    private readonly orderRepository: Repository<Order>,
    @InjectRepository(OrderItem)
    private readonly orderItemRepository: Repository<OrderItem>,
    @InjectRepository(Product)
    private readonly productRepository: Repository<Product>,
    private readonly cartService: CartService,
    private readonly paymentService: PaymentService,
    private readonly inventoryService: InventoryService,
    private readonly responseWrapper: ResponseWrapper,
    private readonly dataSource: DataSource,
  ) {}

  /**
   * 创建订单
   * 使用事务确保数据一致性
   * @param userId 用户ID
   * @param createOrderDto 订单信息
   */
  @Transaction()
  async createOrder(userId: string, createOrderDto: CreateOrderDto) {
    const { items, shippingAddress, remark } = createOrderDto;

    // 开启事务
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // 1. 验证商品并计算价格
      const orderItems = await this.validateAndCalculateItems(items);
      const totalAmount = this.calculateTotalAmount(orderItems);

      // 2. 检查并锁定库存
      await this.inventoryService.lockInventory(
        orderItems.map(item => ({
          productId: item.productId,
          skuId: item.skuId,
          quantity: item.quantity
        })),
        queryRunner
      );

      // 3. 创建订单
      const order = queryRunner.manager.create(Order, {
        id: this.generateOrderId(),
        userId,
        orderNo: this.generateOrderNo(),
        totalAmount,
        discountAmount: 0,
        shippingAmount: 0,
        payableAmount: totalAmount,
        shippingAddress: JSON.stringify(shippingAddress),
        remark,
        status: 'pending',
        paymentStatus: 'unpaid',
        shippingStatus: 'unshipped'
      });

      const savedOrder = await queryRunner.manager.save(order);

      // 4. 创建订单明细
      const orderItemsEntities = orderItems.map(item => ({
        ...item,
        orderId: savedOrder.id,
        id: this.generateOrderItemId()
      }));

      await queryRunner.manager.save(OrderItem, orderItemsEntities);

      // 5. 清空购物车中的已购商品
      await this.cartService.removeItemsFromCart(
        userId,
        items.map(item => item.cartItemId)
      );

      // 提交事务
      await queryRunner.commitTransaction();

      // 6. 创建支付订单（异步，不阻塞）
      this.paymentService.createPaymentOrder(savedOrder.id, totalAmount).catch(err => {
        console.error('创建支付订单失败:', err);
      });

      return this.responseWrapper.success({
        orderId: savedOrder.id,
        orderNo: savedOrder.orderNo,
        totalAmount: savedOrder.payableAmount
      }, '订单创建成功');

    } catch (error) {
      // 回滚事务
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      // 释放查询运行器
      await queryRunner.release();
    }
  }

  /**
   * 验证商品并计算价格
   * @private
   */
  private async validateAndCalculateItems(items: CreateOrderDto['items']) {
    const orderItems: any[] = [];

    for (const item of items) {
      const product = await this.productRepository.findOne({
        where: { id: item.productId }
      });

      if (!product) {
        throw new BadRequestException(`商品 ${item.productId} 不存在`);
      }

      if (product.status !== 'published') {
        throw new BadRequestException(`商品 ${product.name} 已下架`);
      }

      if (product.stock < item.quantity) {
        throw new BadRequestException(`商品 ${product.name} 库存不足`);
      }

      orderItems.push({
        productId: product.id,
        skuId: item.skuId,
        productName: product.name,
        productImage: product.mainImage,
        skuSpecs: item.skuSpecs,
        price: product.price,
        quantity: item.quantity,
        totalAmount: product.price * item.quantity
      });
    }

    return orderItems;
  }

  /**
   * 计算订单总金额
   * @private
   */
  private calculateTotalAmount(items: any[]): number {
    return items.reduce((sum, item) => sum + item.totalAmount, 0);
  }

  /**
   * 生成订单ID
   * @private
   */
  private generateOrderId(): string {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 10);
    return `order_${timestamp}${random}`;
  }

  /**
   * 生成订单号
   * @private
   */
  private generateOrderNo(): string {
    const date = new Date();
    const dateStr = date.getFullYear().toString() +
      (date.getMonth() + 1).toString().padStart(2, '0') +
      date.getDate().toString().padStart(2, '0');
    const timeStr = Date.now().toString().slice(-6);
    const randomStr = Math.random().toString().substring(2, 6);
    return `HL${dateStr}${timeStr}${randomStr}`.toUpperCase();
  }

  /**
   * 取消订单
   */
  async cancelOrder(orderId: string, userId: string) {
    const order = await this.orderRepository.findOne({
      where: { id: orderId, userId }
    });

    if (!order) {
      throw new NotFoundException('订单不存在');
    }

    if (order.status === 'cancelled') {
      throw new BadRequestException('订单已取消');
    }

    if (order.paymentStatus === 'paid') {
      throw new BadRequestException('已支付订单不能直接取消，请申请退款');
    }

    // 开启事务
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // 更新订单状态
      order.status = 'cancelled';
      await queryRunner.manager.save(order);

      // 释放库存
      await this.inventoryService.releaseInventory(
        orderId,
        queryRunner
      );

      await queryRunner.commitTransaction();

      return this.responseWrapper.success(null, '订单已取消');

    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }
}
```

#### 3.4 AI对话模块

##### 3.4.1 对话上下文管理

```typescript
// src/modules/ai/services/conversation.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Conversation } from '../entities/conversation.entity';
import { Message } from '../entities/message.entity';
import { LLMService } from '@/shared/services/llm.service';
import { RAGService } from '@/shared/services/rag.service';

/**
 * 对话服务
 * 管理用户与AI的对话会话
 */
@Injectable()
export class ConversationService {
  constructor(
    @InjectRepository(Conversation)
    private readonly conversationRepository: Repository<Conversation>,
    @InjectRepository(Message)
    private readonly messageRepository: Repository<Message>,
    private readonly llmService: LLMService,
    private readonly ragService: RAGService,
  ) {}

  /**
   * 发送消息并获取AI回复
   * @param userId 用户ID
   * @param conversationId 会话ID
   * @param content 用户消息内容
   */
  async sendMessage(userId: string, conversationId: string, content: string) {
    // 1. 获取会话
    let conversation = await this.conversationRepository.findOne({
      where: { id: conversationId, userId }
    });

    if (!conversation) {
      throw new NotFoundException('会话不存在');
    }

    // 2. 保存用户消息
    const userMessage = this.messageRepository.create({
      id: this.generateMessageId(),
      conversationId,
      role: 'user',
      content
    });
    await this.messageRepository.save(userMessage);

    // 3. 获取历史上下文
    const history = await this.getConversationHistory(conversationId, 10);

    // 4. 获取相关知识（RAG）
    const relevantDocs = await this.ragService.search(content, {
      userId,
      category: conversation.category,
      limit: 3
    });

    // 5. 构建AI请求
    const systemPrompt = this.buildSystemPrompt(conversation);
    const messages = this.buildMessages(systemPrompt, history, content, relevantDocs);

    // 6. 调用LLM获取回复
    const aiResponse = await this.llmService.chat({
      messages,
      temperature: conversation.temperature || 0.7,
      maxTokens: 1000,
      stream: false
    });

    // 7. 保存AI消息
    const assistantMessage = this.messageRepository.create({
      id: this.generateMessageId(),
      conversationId,
      role: 'assistant',
      content: aiResponse.content
    });
    await this.messageRepository.save(assistantMessage);

    // 8. 更新会话信息
    conversation.lastMessageAt = new Date();
    conversation.messageCount += 2;
    await this.conversationRepository.save(conversation);

    return {
      messageId: assistantMessage.id,
      content: assistantMessage.content,
      createdAt: assistantMessage.createdAt
    };
  }

  /**
   * 构建系统提示词
   * @private
   */
  private buildSystemPrompt(conversation: Conversation): string {
    const basePrompt = `你是海蓝AI助手，是HaiLan Pro平台的智能陪伴顾问。

你的角色定位：
- 温柔体贴的情感陪伴者
- 专业私密的健康顾问
- 贴心周到的购物助手

对话原则：
1. 保持尊重和专业，避免任何不当内容
2. 保护用户隐私，不追问敏感个人信息
3. 提供准确、健康、积极的建议
4. 如遇到无法回答的问题，诚实说明并建议咨询专业医师`;

    const categoryPrompts = {
      'companion': '你现在是情感陪伴模式，重点关注用户的情感需求和心理健康。',
      'health': '你现在是健康咨询模式，提供专业的健康知识和建议。',
      'shopping': '你现在是购物助手模式，帮助用户了解商品信息和做出购买决策。',
      'general': basePrompt
    };

    return categoryPrompts[conversation.category] || basePrompt;
  }

  /**
   * 构建消息数组
   * @private
   */
  private buildMessages(
    systemPrompt: string,
    history: Message[],
    userContent: string,
    relevantDocs: any[]
  ): any[] {
    const messages: any[] = [
      { role: 'system', content: systemPrompt }
    ];

    // 添加历史对话
    for (const msg of history) {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    }

    // 添加当前用户消息
    let enhancedContent = userContent;

    // 如果有相关知识，添加到消息中
    if (relevantDocs.length > 0) {
      const contextInfo = relevantDocs.map(doc => `[参考信息] ${doc.content}`).join('\n');
      enhancedContent = `${contextInfo}\n\n用户问题：${userContent}`;
    }

    messages.push({
      role: 'user',
      content: enhancedContent
    });

    return messages;
  }

  /**
   * 获取对话历史
   * @private
   */
  private async getConversationHistory(conversationId: string, limit: number): Promise<Message[]> {
    return this.messageRepository.find({
      where: { conversationId },
      order: { createdAt: 'DESC' },
      take: limit
    }).then(messages => messages.reverse());
  }

  /**
   * 生成消息ID
   * @private
   */
  private generateMessageId(): string {
    return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
  }
}
```

### 4. 代码规范与注释

#### 4.1 TypeScript类型定义规范

```typescript
/**
 * 用户实体
 * @description 存储用户基本信息
 * @entity User
 */
@Entity('users')
export class User {
  /**
   * 用户唯一标识
   * @example "user_1706659200000abc123"
   */
  @PrimaryColumn({ type: 'varchar', length: 32 })
  id: string;

  /**
   * 用户邮箱
   * @format email
   */
  @Column({ type: 'varchar', length: 100, unique: true })
  email: string;

  /**
   * 加密后的密码
   * @visibility private (不在API响应中返回)
   */
  @Column({ type: 'varchar', length: 255, select: false })
  password: string;

  /**
   * 账户状态
   * @enum {string}
   */
  @Column({
    type: 'enum',
    enum: ['active', 'inactive', 'banned', 'deleted'],
    default: 'active'
  })
  status: UserStatus;

  // ... 其他字段
}
```

### 5. 附录

#### 5.1 错误码对照表

| 错误码 | 说明 | 处理建议 |
|--------|------|----------|
| AUTH_001 | Token无效或过期 | 引导用户重新登录 |
| AUTH_002 | 账户或密码错误 | 提示用户检查输入 |
| AUTH_003 | 账户已被禁用 | 显示禁用原因和申诉入口 |
| PRODUCT_001 | 商品不存在 | 返回商品列表页 |
| PRODUCT_002 | 商品库存不足 | 显示库存不足提示 |
| ORDER_001 | 订单不存在 | 返回订单列表页 |
| ORDER_002 | 订单状态不允许此操作 | 提示当前订单状态 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
