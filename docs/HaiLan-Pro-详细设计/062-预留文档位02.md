---
file: 062-预留文档位02.md
description: HaiLan Pro 详细设计类扩展文档预留位，全栈代码植入扩展使用
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-详细设计,[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 062 预留文档位02

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-详细设计-预留文档位02相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范预留文档位02相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 数据统计分析设计

#### 3.1 统计数据模型

```typescript
// src/modules/analytics/entities/metric.entity.ts
import { Entity, PrimaryColumn, Column, Index } from 'typeorm';

/**
 * 指标类型
 */
export enum MetricType {
  /** 用户指标 */
  USER = 'user',
  /** 订单指标 */
  ORDER = 'order',
  /** 商品指标 */
  PRODUCT = 'product',
  /** 收入指标 */
  REVENUE = 'revenue',
  /** 行为指标 */
  BEHAVIOR = 'behavior'
}

/**
 * 聚合粒度
 */
export enum Granularity {
  /** 小时 */
  HOUR = 'hour',
  /** 天 */
  DAY = 'day',
  /** 周 */
  WEEK = 'week',
  /** 月 */
  MONTH = 'month'
}

/**
 * 统计指标实体
 */
@Entity('analytics_metrics')
export class Metric {
  @PrimaryColumn({ type: 'varchar', length: 50 })
  id: string;

  @Column({ type: 'enum', enum: MetricType })
  @Index()
  type: MetricType;

  @Column({ type: 'varchar', length: 100 })
  @Index()
  name: string;

  @Column({ type: 'timestamp' })
  @Index()
  timestamp: Date;

  @Column({ type: 'enum', enum: Granularity })
  granularity: Granularity;

  @Column({ type: 'jsonb' })
  dimensions: Record<string, any>;

  @Column({ type: 'jsonb' })
  values: Record<string, number>;

  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  createdAt: Date;
}
```

#### 3.2 统计服务实现

```typescript
// src/modules/analytics/services/analytics.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between } from 'typeorm';
import { Metric, MetricType, Granularity } from '../entities/metric.entity';

/**
 * 统计查询参数
 */
interface AnalyticsQuery {
  /** 指标类型 */
  type?: MetricType;
  /** 指标名称 */
  name?: string;
  /** 时间范围 */
  startDate: Date;
  endDate: Date;
  /** 聚合粒度 */
  granularity?: Granularity;
  /** 维度过滤 */
  dimensions?: Record<string, any>;
}

/**
 * 统计数据点
 */
interface DataPoint {
  timestamp: string;
  value: number;
  dimensions?: Record<string, any>;
}

/**
 * 统计结果
 */
interface AnalyticsResult {
  name: string;
  data: DataPoint[];
  total: number;
  average: number;
  min: number;
  max: number;
}

/**
 * 统计分析服务
 */
@Injectable()
export class AnalyticsService {
  constructor(
    @InjectRepository(Metric)
    private readonly metricRepository: Repository<Metric>
  ) {}

  /**
   * 记录指标
   */
  async recordMetric(
    type: MetricType,
    name: string,
    values: Record<string, number>,
    dimensions: Record<string, any> = {},
    timestamp: Date = new Date(),
    granularity: Granularity = Granularity.DAY
  ): Promise<void> {
    const metric = this.metricRepository.create({
      id: this.generateMetricId(),
      type,
      name,
      timestamp,
      granularity,
      dimensions,
      values
    });

    await this.metricRepository.save(metric);
  }

  /**
   * 查询统计数据
   */
  async queryMetrics(query: AnalyticsQuery): Promise<AnalyticsResult[]> {
    const {
      type,
      name,
      startDate,
      endDate,
      granularity = Granularity.DAY,
      dimensions
    } = query;

    const queryBuilder = this.metricRepository
      .createQueryBuilder('m')
      .where('m.timestamp BETWEEN :startDate AND :endDate', {
        startDate,
        endDate
      })
      .andWhere('m.granularity = :granularity', { granularity })
      .orderBy('m.timestamp', 'ASC');

    if (type) {
      queryBuilder.andWhere('m.type = :type', { type });
    }

    if (name) {
      queryBuilder.andWhere('m.name = :name', { name });
    }

    // 维度过滤
    if (dimensions) {
      Object.entries(dimensions).forEach(([key, value]) => {
        queryBuilder.andWhere(`m.dimensions->>:${key} = :${key}Value`, {
          [`${key}Value`]: value
        });
      });
    }

    const metrics = await queryBuilder.getMany();

    // 按指标名称分组
    const grouped = this.groupByMetricName(metrics);

    // 生成统计结果
    return Object.entries(grouped).map(([name, items]) =>
      this.calculateResult(name, items)
    );
  }

  /**
   * 获取概览统计
   */
  async getOverview(date: Date = new Date()): Promise<Record<string, any>> {
    const startOfDay = new Date(date.setHours(0, 0, 0, 0));
    const endOfDay = new Date(date.setHours(23, 59, 59, 999));

    const [
      totalUsers,
      newUsers,
      totalOrders,
      todayOrders,
      totalRevenue,
      todayRevenue
    ] = await Promise.all([
      this.getUserCount(),
      this.getNewUserCount(startOfDay, endOfDay),
      this.getOrderCount(),
      this.getOrderCount(startOfDay, endOfDay),
      this.getTotalRevenue(),
      this.getRevenue(startOfDay, endOfDay)
    ]);

    return {
      users: {
        total: totalUsers,
        new: newUsers,
        growthRate: this.calculateGrowthRate(newUsers, totalUsers)
      },
      orders: {
        total: totalOrders,
        today: todayOrders,
        growthRate: this.calculateGrowthRate(todayOrders, totalOrders)
      },
      revenue: {
        total: totalRevenue,
        today: todayRevenue,
        growthRate: this.calculateGrowthRate(todayRevenue, totalRevenue)
      }
    };
  }

  /**
   * 用户活跃度分析
   */
  async getUserActivity(days: number = 30): Promise<any> {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    // TODO: 实现用户活跃度统计
    return {
      dailyActiveUsers: [],
      weeklyActiveUsers: 0,
      monthlyActiveUsers: 0,
      retentionRate: 0
    };
  }

  /**
   * 商品销售排行
   */
  async getProductSalesRanking(limit: number = 10, startDate?: Date, endDate?: Date): Promise<any[]> {
    // TODO: 实现商品销售排行
    return [];
  }

  /**
   * 收入趋势分析
   */
  async getRevenueTrend(
    startDate: Date,
    endDate: Date,
    granularity: Granularity = Granularity.DAY
  ): Promise<AnalyticsResult> {
    const result = await this.queryMetrics({
      type: MetricType.REVENUE,
      name: 'total_revenue',
      startDate,
      endDate,
      granularity
    });

    return result[0] || {
      name: 'total_revenue',
      data: [],
      total: 0,
      average: 0,
      min: 0,
      max: 0
    };
  }

  /**
   * 按指标名称分组
   * @private
   */
  private groupByMetricName(metrics: Metric[]): Record<string, Metric[]> {
    return metrics.reduce((result, metric) => {
      if (!result[metric.name]) {
        result[metric.name] = [];
      }
      result[metric.name].push(metric);
      return result;
    }, {} as Record<string, Metric[]>);
  }

  /**
   * 计算统计结果
   * @private
   */
  private calculateResult(name: string, metrics: Metric[]): AnalyticsResult {
    const data: DataPoint[] = metrics.map(m => ({
      timestamp: m.timestamp.toISOString(),
      value: m.values.value || 0,
      dimensions: m.dimensions
    }));

    const values = data.map(d => d.value);

    return {
      name,
      data,
      total: values.reduce((sum, v) => sum + v, 0),
      average: values.reduce((sum, v) => sum + v, 0) / values.length,
      min: Math.min(...values),
      max: Math.max(...values)
    };
  }

  /**
   * 计算增长率
   * @private
   */
  private calculateGrowthRate(current: number, total: number): number {
    if (total === 0) return 0;
    return ((current / total) * 100);
  }

  /**
   * 获取用户总数
   * @private
   */
  private async getUserCount(): Promise<number> {
    // TODO: 查询用户总数
    return 0;
  }

  /**
   * 获取新用户数
   * @private
   */
  private async getNewUserCount(startDate: Date, endDate: Date): Promise<number> {
    // TODO: 查询时间范围内新用户数
    return 0;
  }

  /**
   * 获取订单总数
   * @private
   */
  private async getOrderCount(startDate?: Date, endDate?: Date): Promise<number> {
    // TODO: 查询订单总数
    return 0;
  }

  /**
   * 获取总收入
   * @private
   */
  private async getTotalRevenue(): Promise<number> {
    // TODO: 查询总收入
    return 0;
  }

  /**
   * 获取时间范围内的收入
   * @private
   */
  private async getRevenue(startDate: Date, endDate: Date): Promise<number> {
    // TODO: 查询时间范围内收入
    return 0;
  }

  /**
   * 生成指标ID
   * @private
   */
  private generateMetricId(): string {
    return `metric_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
  }
}
```

#### 3.3 数据采集器

```typescript
// src/modules/analytics/collectors/metric.collector.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { AnalyticsService } from '../services/analytics.service';
import { MetricType, Granularity } from '../entities/metric.entity';

/**
 * 指标采集器
 * 定时采集和聚合统计数据
 */
@Injectable()
export class MetricCollector {
  constructor(
    private readonly analyticsService: AnalyticsService
  ) {}

  /**
   * 每小时采集一次数据
   */
  @Cron(CronExpression.EVERY_HOUR)
  async collectHourlyMetrics() {
    const now = new Date();
    const hourStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 0, 0);
    const hourEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 59, 59);

    await Promise.all([
      this.collectUserMetrics(hourStart, hourEnd),
      this.collectOrderMetrics(hourStart, hourEnd),
      this.collectRevenueMetrics(hourStart, hourEnd)
    ]);
  }

  /**
   * 每天凌晨聚合日数据
   */
  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async aggregateDailyMetrics() {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const dayStart = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 0, 0, 0);
    const dayEnd = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);

    await Promise.all([
      this.aggregateUserMetrics(dayStart, dayEnd),
      this.aggregateOrderMetrics(dayStart, dayEnd),
      this.aggregateRevenueMetrics(dayStart, dayEnd)
    ]);
  }

  /**
   * 采集用户指标
   * @private
   */
  private async collectUserMetrics(startDate: Date, endDate: Date) {
    // TODO: 实现用户指标采集
    const newUsers = 0;
    const activeUsers = 0;

    await this.analyticsService.recordMetric(
      MetricType.USER,
      'new_users',
      { value: newUsers },
      {},
      startDate,
      Granularity.HOUR
    );

    await this.analyticsService.recordMetric(
      MetricType.USER,
      'active_users',
      { value: activeUsers },
      {},
      startDate,
      Granularity.HOUR
    );
  }

  /**
   * 采集订单指标
   * @private
   */
  private async collectOrderMetrics(startDate: Date, endDate: Date) {
    // TODO: 实现订单指标采集
    const totalOrders = 0;
    const completedOrders = 0;

    await this.analyticsService.recordMetric(
      MetricType.ORDER,
      'total_orders',
      { value: totalOrders },
      {},
      startDate,
      Granularity.HOUR
    );

    await this.analyticsService.recordMetric(
      MetricType.ORDER,
      'completed_orders',
      { value: completedOrders },
      {},
      startDate,
      Granularity.HOUR
    );
  }

  /**
   * 采集收入指标
   * @private
   */
  private async collectRevenueMetrics(startDate: Date, endDate: Date) {
    // TODO: 实现收入指标采集
    const totalRevenue = 0;

    await this.analyticsService.recordMetric(
      MetricType.REVENUE,
      'total_revenue',
      { value: totalRevenue },
      {},
      startDate,
      Granularity.HOUR
    );
  }

  /**
   * 聚合用户指标
   * @private
   */
  private async aggregateUserMetrics(startDate: Date, endDate: Date) {
    // TODO: 从小时数据聚合天数据
  }

  /**
   * 聚合订单指标
   * @private
   */
  private async aggregateOrderMetrics(startDate: Date, endDate: Date) {
    // TODO: 从小时数据聚合天数据
  }

  /**
   * 聚合收入指标
   * @private
   */
  private async aggregateRevenueMetrics(startDate: Date, endDate: Date) {
    // TODO: 从小时数据聚合天数据
  }
}
```

#### 3.4 埋点数据收集

```typescript
// src/shared/analytics/tracker.ts
/**
 * 事件类型
 */
enum EventType {
  /** 页面浏览 */
  PAGE_VIEW = 'page_view',
  /** 元素点击 */
  CLICK = 'click',
  /** 表单提交 */
  FORM_SUBMIT = 'form_submit',
  /** 自定义事件 */
  CUSTOM = 'custom'
}

/**
 * 埋点数据
 */
interface TrackEvent {
  /** 事件ID */
  eventId: string;
  /** 用户ID */
  userId?: string;
  /** 会话ID */
  sessionId: string;
  /** 事件类型 */
  eventType: EventType;
  /** 事件名称 */
  eventName: string;
  /** 页面路径 */
  pagePath: string;
  /** 页面标题 */
  pageTitle: string;
  /** 事件属性 */
  properties?: Record<string, any>;
  /** 时间戳 */
  timestamp: number;
  /** 用户代理 */
  userAgent: string;
  /** 屏幕分辨率 */
  screenResolution?: string;
  /** 设备类型 */
  deviceType?: 'desktop' | 'mobile' | 'tablet';
}

/**
 * 前端埋点追踪器
 */
class AnalyticsTracker {
  private userId?: string;
  private sessionId: string;
  private queue: TrackEvent[] = [];
  private batchSize = 10;
  private flushInterval = 5000;

  constructor() {
    this.sessionId = this.generateSessionId();
    this.init();
  }

  /**
   * 初始化
   * @private
   */
  private init() {
    // 从本地存储恢复用户ID
    this.userId = localStorage.getItem('analytics_user_id') || undefined;

    // 定时上报
    setInterval(() => this.flush(), this.flushInterval);

    // 页面卸载时上报
    window.addEventListener('beforeunload', () => this.flush());

    // 页面可见性变化时上报
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.flush();
      }
    });
  }

  /**
   * 设置用户ID
   */
  setUserId(userId: string) {
    this.userId = userId;
    localStorage.setItem('analytics_user_id', userId);
  }

  /**
   * 清除用户ID
   */
  clearUserId() {
    this.userId = undefined;
    localStorage.removeItem('analytics_user_id');
  }

  /**
   * 页面浏览
   */
  trackPageView(pagePath?: string, pageTitle?: string) {
    this.track({
      eventType: EventType.PAGE_VIEW,
      eventName: 'page_view',
      pagePath: pagePath || window.location.pathname,
      pageTitle: pageTitle || document.title
    });
  }

  /**
   * 点击事件
   */
  trackClick(element: string, properties?: Record<string, any>) {
    this.track({
      eventType: EventType.CLICK,
      eventName: 'click',
      properties: { element, ...properties }
    });
  }

  /**
   * 表单提交
   */
  trackFormSubmit(formId: string, properties?: Record<string, any>) {
    this.track({
      eventType: EventType.FORM_SUBMIT,
      eventName: 'form_submit',
      properties: { formId, ...properties }
    });
  }

  /**
   * 自定义事件
   */
  trackCustom(eventName: string, properties?: Record<string, any>) {
    this.track({
      eventType: EventType.CUSTOM,
      eventName,
      properties
    });
  }

  /**
   * 追踪事件
   * @private
   */
  private track(data: Partial<TrackEvent>) {
    const event: TrackEvent = {
      eventId: this.generateEventId(),
      userId: this.userId,
      sessionId: this.sessionId,
      eventType: data.eventType || EventType.CUSTOM,
      eventName: data.eventName || 'unknown',
      pagePath: data.pagePath || window.location.pathname,
      pageTitle: data.pageTitle || document.title,
      properties: data.properties,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      screenResolution: `${window.screen.width}x${window.screen.height}`,
      deviceType: this.getDeviceType()
    };

    this.queue.push(event);

    // 达到批次大小时立即上报
    if (this.queue.length >= this.batchSize) {
      this.flush();
    }
  }

  /**
   * 上报数据
   * @private
   */
  private async flush() {
    if (this.queue.length === 0) return;

    const events = [...this.queue];
    this.queue = [];

    try {
      await fetch('/api/analytics/track', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ events }),
        keepalive: true // 确保页面卸载时也能发送
      });
    } catch (error) {
      console.error('埋点数据上报失败:', error);
      // 失败时重新入队
      this.queue.unshift(...events);
    }
  }

  /**
   * 获取设备类型
   * @private
   */
  private getDeviceType(): 'desktop' | 'mobile' | 'tablet' {
    const width = window.screen.width;
    if (width < 768) return 'mobile';
    if (width < 1024) return 'tablet';
    return 'desktop';
  }

  /**
   * 生成事件ID
   * @private
   */
  private generateEventId(): string {
    return `evt_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
  }

  /**
   * 生成会话ID
   * @private
   */
  private generateSessionId(): string {
    return `sess_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
  }
}

// 创建全局实例
export const tracker = new AnalyticsTracker();
```

### 4. 附录

#### 4.1 常用统计指标

| 类别 | 指标名称 | 说明 |
|------|----------|------|
| 用户 | DAU | 日活跃用户数 |
| | MAU | 月活跃用户数 |
| | 留存率 | 用户留存比例 |
| 订单 | 订单量 | 订单总数 |
| | 订单额 | 订单总金额 |
| | 客单价 | 平均订单金额 |
| | 转化率 | 访问转化比例 |
| 商品 | 销量 | 商品销售数量 |
| | 销额 | 商品销售金额 |
| | 购买率 | 商品购买转化率 |
| 收入 | GMV | 成交总额 |
| | 净收入 | 实际收入金额 |

#### 4.2 数据保留策略

| 数据类型 | 热数据 | 温数据 | 冷数据 |
|----------|--------|--------|--------|
| 原始埋点 | 7天 | 90天 | 1年 |
| 小时聚合 | 30天 | 1年 | - |
| 天聚合 | 1年 | 3年 | 永久 |
| 月聚合 | 永久 | - | - |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
