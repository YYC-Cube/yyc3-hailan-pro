---
@file: 056-性能优化代码方案.md
@description: HaiLan Pro 前端/后端代码性能优化的具体方案与实现，提升系统响应速度
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-详细设计],[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 056 性能优化代码方案

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-详细设计-性能优化代码方案相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范性能优化代码方案相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 性能优化代码方案

#### 3.1 前端性能优化

##### 3.1.1 代码分割与懒加载

```typescript
// 路由懒加载配置
// src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router';

const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('@/views/home/index.vue') // 懒加载
  },
  {
    path: '/mall',
    name: 'Mall',
    component: () => import('@/views/mall/index.vue')
  },
  {
    path: '/product/:id',
    name: 'ProductDetail',
    component: () => import('@/views/mall/product.vue')
  },
  {
    path: '/cart',
    name: 'Cart',
    component: () => import('@/views/mall/cart.vue')
  },
  {
    path: '/ai',
    name: 'AICompanion',
    component: () => import('@/views/ai/index.vue')
  }
];

// Vite打包优化配置
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        // 手动分包策略
        manualChunks: {
          // Vue核心框架
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          // UI组件库
          'ui-vendor': [],
          // 第三方库
          'vendor': ['axios', 'dayjs'],
          // 业务模块
          'mall': [
            'src/views/mall',
            'src/components/business/ProductCard',
            'src/components/business/OrderItem'
          ],
          'user': [
            'src/views/user',
            'src/components/business/UserAvatar'
          ],
          'ai': [
            'src/views/ai',
            'src/components/business/AIChat'
          ]
        }
      },
      },
      chunkSizeWarningLimit: 500 // 500KB警告阈值
    }
  }
});

// 组件懒加载
// 在组件中使用defineAsyncComponent
<script setup lang="ts">
import { defineAsyncComponent } from 'vue';

const HeavyComponent = defineAsyncComponent(() =>
  import('./HeavyComponent.vue')
);
</script>
```

##### 3.1.2 虚拟列表优化

```vue
<!-- 长列表虚拟滚动优化 -->
<!-- src/components/common/VirtualList.vue -->
<template>
  <div
    ref="container"
    class="virtual-list"
    :style="{ height: `${containerHeight}px` }"
    @scroll="onScroll"
  >
    <div
      class="virtual-list-content"
      :style="{ height: `${totalHeight}px` }"
    >
      <div
        v-for="item in visibleItems"
        :key="item.id"
        class="virtual-list-item"
        :style="{ height: `${itemHeight}px`, transform: `translateY(${getItemOffset(item.id)}px)` }"
      >
        <slot :item="item"></slot>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';

interface Props {
  items: any[];
  itemHeight: number;
  containerHeight: number;
}

const props = withDefaults(defineProps<Props>(), {
  itemHeight: 100,
  containerHeight: 600
});

// 可见项列表
const visibleItems = computed(() => {
  const start = Math.floor(scrollTop.value / props.itemHeight);
  const end = Math.ceil((scrollTop.value + props.containerHeight) / props.itemHeight);
  return props.items.slice(start, end);
});

// 滚动位置
const scrollTop = ref(0);

// 总高度
const totalHeight = computed(() => props.items.length * props.itemHeight);

// 滚动事件
function onScroll(event: Event) {
  const target = event.target as HTMLElement;
  scrollTop.value = target.scrollTop;
}

// 计算项位置
function getItemOffset(itemId: string): number {
  const index = props.items.findIndex(item => item.id === itemId);
  return index * props.itemHeight;
}
</script>

<style scoped>
.virtual-list {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.virtual-list-content {
  position: relative;
  width: 100%;
}

.virtual-list-item {
  position: absolute;
  left: 0;
  right: 0;
  will-change: transform;
}
</style>
```

#### 3.2 缓存优化

##### 3.2.1 客户端缓存策略

```typescript
// 缓存管理服务
// src/core/services/cache.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class CacheService {
  private memoryCache: Map<string, { value: any; expiry: number }> = new Map();

  /**
   * 设置缓存
   */
  set(key: string, value: any, ttl: number = 3600): void {
    const expiry = Date.now() + ttl * 1000;
    this.memoryCache.set(key, { value, expiry });
  }

  /**
   * 获取缓存
   */
  get<T = any>(key: string): T | null {
    const cached = this.memoryCache.get(key);

    if (!cached) {
      return null;
    }

    if (Date.now() > cached.expiry) {
      this.memoryCache.delete(key);
      return null;
    }

    return cached.value as T;
  }

  /**
   * 批量设置缓存
   */
  setMany(items: Array<{ key: string; value: any; ttl?: number }>): void {
    for (const item of items) {
      this.set(item.key, item.value, item.ttl);
    }
  }

  /**
   * 清除缓存
   */
  delete(key: string): boolean {
    return this.memoryCache.delete(key);
  }

  /**
   * 清除所有缓存
   */
  clear(): void {
    this.memoryCache.clear();
  }

  /**
   * 清除过期缓存
   */
  clearExpired(): void {
    const now = Date.now();
    for (const [key, cached] of this.memoryCache.entries()) {
      if (now > cached.expiry) {
        this.memoryCache.delete(key);
      }
    }
  }

  /**
   * 获取缓存统计
   */
  getStats(): CacheStats {
    return {
      size: this.memoryCache.size,
      keys: Array.from(this.memoryCache.keys())
    };
  }
}

// Vue组件缓存
// 使用KeepAlive缓存组件状态
<template>
  <router-view v-slot="{ Component }">
    <keep-alive :include="cachedComponents">
      <component :is="Component" :key="$route.fullPath" />
    </keep-alive>
  </router-view>
</template>

<script setup lang="ts">
const cachedComponents = ['Home', 'Mall', 'ProductDetail'];
</script>
```

##### 3.2.2 Redis缓存优化

```typescript
// 后端Redis缓存优化
// modules/cache/redis-cache.service.ts
import { Injectable } from '@nestjs/common';
import { Redis } from 'ioredis';

@Injectable()
export class RedisCacheService {
  constructor(private readonly redis: Redis) {
    // 定期清理过期缓存
    this.startCleanupTask();
  }

  /**
   * 设置缓存（支持序列化）
   */
  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    const serialized = JSON.stringify(value);

    if (ttl > 0) {
      await this.redis.setex(key, ttl, serialized);
    } else {
      await this.redis.set(key, serialized);
    }
  }

  /**
   * 获取缓存（支持反序列化）
   */
  async get<T = any>(key: string): Promise<T | null> {
    const data = await this.redis.get(key);

    if (!data) {
      return null;
    }

    try {
      return JSON.parse(data) as T;
    } catch {
      return data as T;
    }
  }

  /**
   * 批量设置缓存
   */
  async mset(items: Array<{ key: string; value: any; ttl?: number }>): Promise<void> {
    const pipeline = this.redis.pipeline();

    for (const item of items) {
      const serialized = JSON.stringify(item.value);

      if (item.ttl && item.ttl > 0) {
        pipeline.setex(item.key, item.ttl, serialized);
      } else {
        pipeline.set(item.key, serialized);
      }
    }

    await pipeline.exec();
  }

  /**
   * 批量获取缓存
   */
  async mget(keys: string[]): Promise<(string | null)[]> {
    const pipeline = this.redis.pipeline();
    keys.forEach(key => pipeline.get(key));

    const results = await pipeline.exec();
    return results[1]; // 返回所有值
  }

  /**
   * 缓存穿透保护
   */
  async getOrSet<T>(
    key: string,
    factory: () => Promise<T>,
    ttl: number = 3600
  ): Promise<T> {
    // 先尝试从缓存获取
    const cached = await this.get<T>(key);
    if (cached !== null) {
      return cached;
    }

    // 缓存未命中，执行factory函数
    const value = await factory();

    // 设置缓存
    await this.set(key, value, ttl);

    return value;
  }

  /**
   * 缓存雪崩保护
   */
  async preventCacheBreakdown(keys: string[]): Promise<void> {
    const pipeline = this.redis.pipeline();

    // 为所有key设置空值，TTL设置为5分钟
    for (const key of keys) {
      pipeline.setex(key, 300, '');
    }

    await pipeline.exec();
  }

  /**
   * 启动过期缓存清理任务
   */
  private startCleanupTask(): void {
    // 每小时清理一次过期缓存
    setInterval(() => {
      this.scanAndDeleteExpired();
    }, 3600000);
  }

  /**
   * 扫描并删除过期缓存
   */
  private async scanAndDeleteExpired(): Promise<void> {
    const cursor = '0';
    const pattern = 'cache:*';
    const count = 100;

    do {
      const result = await this.redis.scan(
        cursor,
        pattern,
        'COUNT',
        count
      );

      cursor = result[0];
      const keys = result[1];

      if (keys.length > 0) {
        // 检查并删除过期key
        const pipeline = this.redis.pipeline();
        for (const key of keys) {
          pipeline.expire(key); // 获取TTL
        }

        const results = await pipeline.exec();

        // 删除TTL为-1（已过期）的key
        const expiredKeys = [];
        for (let i = 0; i < results.length; i += 2) {
          if (results[i + 1] === -1) {
            expiredKeys.push(keys[i]);
          }
        }

        if (expiredKeys.length > 0) {
          await this.redis.del(...expiredKeys);
        }
      }
    } while (cursor !== '0');
  }
}
```

#### 3.3 数据库优化

##### 3.3.1 数据库索引优化

```sql
-- 数据库索引优化
-- 为常用查询字段创建索引

-- 用户表索引
CREATE INDEX CONCURRENTLY idx_users_phone_hash ON users(phone_hash) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_users_email_hash ON users(email_hash) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_users_status ON users(status) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_users_created_at ON users(created_at DESC) WHERE deleted_at IS NULL;

-- 商品表索引
CREATE INDEX CONCURRENTLY idx_products_category_id ON products(category_id) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_products_status ON products(status) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_products_sales ON products(sales DESC) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_products_rating ON products(rating DESC) WHERE status = 'active';
CREATE INDEX CONCURRENTLY idx_products_created_at ON products(created_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_products_price ON products(price) WHERE status = 'active';

-- 订单表索引
CREATE INDEX CONCURRENTLY idx_orders_user_id ON orders(user_id) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_orders_order_no ON orders(order_no) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_orders_status ON orders(status) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_orders_created_at ON orders(created_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_orders_payment_status ON orders(payment_status) WHERE deleted_at IS NULL;

-- 订单明细表索引
CREATE INDEX CONCURRENTLY idx_order_items_order_id ON order_items(order_id) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_order_items_product_id ON order_items(product_id) WHERE deleted_at IS NULL;

-- IoT设备表索引
CREATE INDEX CONCURRENTLY idx_iot_devices_user_id ON iot_devices(user_id) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_iot_devices_device_no ON iot_devices(device_no) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_iot_devices_status ON iot_devices(status) WHERE deleted_at IS NULL;
CREATE INDEX CONCURRENTLY idx_iot_devices_last_connected_at ON iot_devices(last_connected_at DESC);
```

##### 3.3.2 查询优化

```typescript
// 数据库查询优化
// modules/database/repositories/base.repository.ts
import { Injectable } from '@nestjs/common';
import { DataSource, SelectQueryBuilder } from 'typeorm';

@Injectable()
export class BaseRepository<T> {
  constructor(
    @Inject('DataSource') private readonly dataSource: DataSource
  ) {}

  /**
   * 分页查询优化
   */
  async paginate<T>(
    queryBuilder: SelectQueryBuilder<T>,
    page: number = 1,
    pageSize: number = 20
  ): Promise<{ items: T[]; total: number; page: number; pageSize: number; totalPages: number }> {
    const skip = (page - 1) * pageSize;

    // 执行查询
    const [items, total] = await queryBuilder
      .skip(skip)
      .take(pageSize)
      .getManyAndCount();

    // 计算总页数
    const totalPages = Math.ceil(total / pageSize);

    return {
      items,
      total,
      page,
      pageSize,
      totalPages
    };
  }

  /**
   * 批量插入优化
   */
  async batchInsert<T>(
    entity: new (...args: any[]) => T,
    items: any[],
    batchSize: number = 100
  ): Promise<void> {
    await this.dataSource
      .createQueryBuilder()
      .insert()
      .into(entity)
      .values(items)
      .execute();
  }

  /**
   * 查询优化 - 只查询需要的字段
   */
  async findById<T>(
    entity: new (...args: any[]) => T,
    id: string,
    select?: (keyof T)[]
  ): Promise<T | null> {
    const queryBuilder = this.dataSource
      .createQueryBuilder()
      .select(select || [])
      .from(entity)
      .where('id = :id');

    return queryBuilder.getRawOne() as Promise<T | null>;
  }
}
```

#### 3.4 API性能优化

##### 3.4.1 请求合并

```typescript
// 请求合并服务
// src/core/services/request-batcher.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class RequestBatcherService {
  private batchQueue: Map<string, BatchRequest> = new Map();
  private batchTimers: Map<string, NodeJS.Timeout> = new Map();
  private readonly BATCH_DELAY = 50; // 批量延迟时间(ms)

  /**
   * 批量请求
   */
  async batchRequest<T>(
    key: string,
    requestFn: () => Promise<T>,
    options?: { delay?: number }
  ): Promise<T> {
    const delay = options?.delay || this.BATCH_DELAY;

    // 如果已有批量队列，加入队列
    if (this.batchQueue.has(key)) {
      return new Promise((resolve, reject) => {
        this.batchQueue.get(key)!.push({ resolve, reject, requestFn });
      });
    }

    // 创建新的批量队列
    this.batchQueue.set(key, [{ requestFn }]);

    // 延迟执行
    const timer = setTimeout(async () => {
      const batch = this.batchQueue.get(key)!;
      this.batchQueue.delete(key);

      try {
        const result = await requestFn();
        batch.forEach(({ resolve }) => resolve(result));
      } catch (error) {
        batch.forEach(({ reject }) => reject(error));
      }
    }, delay);

    this.batchTimers.set(key, timer);

    // 执行单个请求
    return requestFn();
  }

  /**
   * GraphQL批量查询
   */
  async batchGraphQLRequest<T>(
    queries: Array<{
      key: string;
      query: string;
      variables?: any;
    }>
  ): Promise<Map<string, T>> {
    // 合并GraphQL查询
    const batchQuery = queries
      .map(q => `${q.key}: ${q.query}`)
      .join('\n');

    const response = await fetch('/graphql', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: `{ ${batchQuery} }`,
        variables: queries.reduce((acc, q) => ({ ...acc, [q.key]: q.variables }), {})
      })
    });

    const data = await response.json();

    return new Map(Object.entries(data.data));
  }
}
```

##### 3.4.2 连接池优化

```typescript
// 数据库连接池配置
// src/database/database.config.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PostgresConnectionOptions } from 'typeorm/driver/postgres/PostgresConnectionOptions';

@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      useFactory: () => ({
        type: 'postgres',
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '5432'),
        username: process.env.DB_USERNAME || 'postgres',
        password: process.env.DB_PASSWORD || 'postgres',
        database: process.env.DB_NAME || 'hailan_pro_db',
        entities: [__dirname + '/../**/*.entity{.ts,.js}'],
        synchronize: false,
        logging: process.env.NODE_ENV === 'development',

        // 连接池配置
        extra: {
          // 连接池最大连接数
          max: 100,
          // 连接池最小连接数
          min: 10,
          // 获取连接的超时时间
          connectionTimeoutMillis: 10000,
          // 空闲连接的超时时间
          idleTimeoutMillis: 30000,
          // 限制给定时间内连接的存活时间
          maxLifetime: 7200000, // 2小时
          // 允许慢查询
          allowGst: true,
          // 启用日志记录
          logging: true
        } as PostgresConnectionOptions
      })
    })
  ]
})
export class DatabaseModule {}
```

#### 3.5 异步处理优化

##### 3.5.1 消息队列配置

```typescript
// RabbitMQ消息队列配置
// src/modules/queue/queue.config.ts
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bull';
import { Queue } from 'bull';

@Module({
  imports: [
    BullModule.forRootAsync({
      useFactory: () => ({
        redis: {
          host: process.env.REDIS_HOST || 'localhost',
          port: parseInt(process.env.REDIS_PORT || '6379'),
          password: process.env.REDIS_PASSWORD || '',
          db: parseInt(process.env.REDIS_DB || '0'),
          options: {
            maxRetries: 3,
            retryDelay: 5000
          }
        },
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 5000,
            maxDelay: 60000
          },
          removeOnComplete: true,
          removeOnFail: true
        }
      })
    }),
    BullModule.registerQueue(
      {
        name: 'email',
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 5000,
            maxDelay: 60000
          }
        }
      },
      {
        name: 'push',
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 5000,
            maxDelay: 60000
          }
        }
      }
    )
  ]
})
export class QueueConfig {}
```

##### 3.5.2 异步任务处理

```typescript
// 异步任务处理器
// src/modules/queue/handlers/email.handler.ts
import { Processor, Process } from '@nestjs/bull';

@Processor('email')
export class EmailProcessor {
  constructor() {
    console.log('EmailProcessor initialized');
  }

  @Process('send-email')
  async handleSendEmail(job: Job) {
    const { to, subject, template, data } = job.data;

    console.log(`Sending email to ${to} with subject: ${subject}`);

    try {
      // 发送邮件逻辑
      await this.emailService.send({
        to,
        subject,
        template,
        data
      });

      console.log(`Email sent successfully to ${to}`);

      // 更新任务状态
      await job.update({
        progress: 100,
        result: { status: 'sent' }
      });
    } catch (error) {
      console.error(`Failed to send email to ${to}:`, error);

      // 标记任务失败
      await job.moveToFailed({
        message: error.message
      });
      throw error;
    }
  }

  @Process('send-welcome-email')
  async handleWelcomeEmail(job: Job) {
    const { userId, email } = job.data;

    try {
      await this.emailService.sendWelcomeEmail(email, userId);
      await job.update({ progress: 100 });
    } catch (error) {
      await job.moveToFailed({ message: error.message });
      throw error;
    }
  }
}
```

#### 3.6 性能监控

##### 3.6.1 性能指标监控

```typescript
// 性能监控服务
// src/modules/monitoring/performance.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class PerformanceMonitoringService {
  // 性能指标
  metrics = {
    // 响应时间
    responseTime: [] as number[],

    // 数据库查询时间
    dbQueryTime: [] as number[],

    // API调用量
    apiCallCount: new Map<string, number>(),

    // 错误率
    errorCount: new Map<string, number>()
  };

  /**
   * 记录响应时间
   */
  recordResponseTime(endpoint: string, duration: number): void {
    this.metrics.responseTime.push(duration);

    // 保持最近1000个记录
    if (this.metrics.responseTime.length > 1000) {
      this.metrics.responseTime.shift();
    }
  }

  /**
   * 获取性能统计
   */
  getStats(): PerformanceStats {
    const avgResponseTime = this.metrics.responseTime.length > 0
      ? this.metrics.responseTime.reduce((a, b) => a + b, 0) / this.metrics.responseTime.length
      : 0;

    const p50 = this.percentile(this.metrics.responseTime, 50);
    const p95 = this.percentile(this.metrics.responseTime, 95);
    const p99 = this.percentile(this.metrics.responseTime, 99);

    return {
      avgResponseTime,
      p50,
      p95,
      p99,
      totalRequests: Array.from(this.metrics.apiCallCount.values()).reduce((a, b) => a + b, 0),
      errorRate: this.calculateErrorRate()
    };
  }

  /**
   * 计算百分位数
   */
  private percentile(data: number[], p: number): number {
    const sorted = [...data].sort((a, b) => a - b);
    const index = Math.ceil(p / 100 * sorted.length);
    return sorted[index];
  }

  /**
   * 计算错误率
   */
  private calculateErrorRate(): number {
    const totalRequests = Array.from(this.metrics.apiCallCount.values()).reduce((a, b) => a + b, 0);
    const totalErrors = Array.from(this.metrics.errorCount.values()).reduce((a, b) => a + b, 0);

    return totalRequests > 0 ? totalErrors / totalRequests : 0;
  }

  /**
   * 性能告警
   */
  checkAlerts(): Alert[] {
    const stats = this.getStats();
    const alerts: Alert[] = [];

    // 响应时间告警
    if (stats.avgResponseTime > 1000) {
      alerts.push({
        type: 'response_time',
        level: 'warning',
        message: `平均响应时间过高: ${stats.avgResponseTime}ms`
      });
    }

    // 错误率告警
    if (stats.errorRate > 0.05) {
      alerts.push({
        type: 'error_rate',
        level: 'critical',
        message: `错误率过高: ${(stats.errorRate * 100).toFixed(2)}%`
      });
    }

    return alerts;
  }
}
```

---

## 附录

### A. 性能优化检查清单

### B. 监控指标定义

### C. 压力测试方案

### D. 术语表

| 术语 | 说明 |
|-----|------|
| **Lazy Loading** | 懒加载 |
| **Code Splitting** | 代码分割 |
| **Virtual Scroll** | 虚拟滚动 |
| **Connection Pool** | 连接池 |
| **Message Queue** | 消息队列 |

### E. 修订历史

| 版本 | 日期 | 修订人 | 修订内容 |
|-----|------|-------|---------|
| v1.0.0 | 2026-01-26 | YanYuCloudCube Team | 初始版本创建 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
