---
file: 055-第三方SDK集成代码文档.md
description: HaiLan Pro 第三方服务SDK的集成规范与代码实现，包含支付、短信、存储等
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-详细设计,[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 055 第三方SDK集成代码文档

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-详细设计-第三方SDK集成代码文档相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范第三方SDK集成代码文档相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 第三方SDK集成代码

#### 3.1 支付SDK集成

##### 3.1.1 微信支付

```typescript
// src/shared/integrations/payment/wechatpay.service.ts
import { Injectable } from '@nestjs/common';
import * as crypto from 'crypto';

/**
 * 微信支付配置
 */
interface WechatPayConfig {
  appId: string;
  mchId: string;
  apiKey: string;
  apiCertPath?: string;
  apiKeyPath?: string;
  notifyUrl: string;
}

/**
 * 微信支付订单
 */
interface WechatPayOrder {
  outTradeNo: string;
  totalFee: number;
  body: string;
  openid?: string;
  tradeType: 'JSAPI' | 'NATIVE' | 'APP' | 'MWEB';
}

/**
 * 微信支付服务
 */
@Injectable()
export class WechatPayService {
  private readonly config: WechatPayConfig;

  constructor() {
    this.config = {
      appId: process.env.WECHAT_PAY_APP_ID,
      mchId: process.env.WECHAT_PAY_MCH_ID,
      apiKey: process.env.WECHAT_PAY_API_KEY,
      notifyUrl: process.env.WECHAT_PAY_NOTIFY_URL
    };
  }

  /**
   * 创建支付订单
   */
  async createOrder(order: WechatPayOrder): Promise<any> {
    const params = {
      appid: this.config.appId,
      mch_id: this.config.mchId,
      nonce_str: this.generateNonceStr(),
      body: order.body,
      out_trade_no: order.outTradeNo,
      total_fee: order.totalFee,
      spbill_create_ip: await this.getClientIp(),
      notify_url: this.config.notifyUrl,
      trade_type: order.tradeType,
      ...(order.openid && { openid: order.openid })
    };

    // 签名
    params.sign = this.sign(params);

    // 发起请求
    const response = await this.request('pay/unifiedorder', params);

    return this.parseResponse(response, order.tradeType);
  }

  /**
   * 小程序支付
   */
  async miniProgramPay(orderId: string, amount: number, openid: string, description: string) {
    return this.createOrder({
      outTradeNo: orderId,
      totalFee: Math.round(amount * 100), // 转换为分
      body: description,
      openid,
      tradeType: 'JSAPI'
    });
  }

  /**
   * H5支付
   */
  async h5Pay(orderId: string, amount: number, description: string) {
    return this.createOrder({
      outTradeNo: orderId,
      totalFee: Math.round(amount * 100),
      body: description,
      tradeType: 'MWEB'
    });
  }

  /**
   * 扫码支付
   */
  async nativePay(orderId: string, amount: number, description: string) {
    return this.createOrder({
      outTradeNo: orderId,
      totalFee: Math.round(amount * 100),
      body: description,
      tradeType: 'NATIVE'
    });
  }

  /**
   * 验证回调签名
   */
  verifyNotify(data: any): boolean {
    const sign = data.sign;
    delete data.sign;

    const calculatedSign = this.sign(data);
    return sign === calculatedSign;
  }

  /**
   * 申请退款
   */
  async refund(orderId: string, refundId: string, amount: number, totalAmount: number) {
    const params = {
      appid: this.config.appId,
      mch_id: this.config.mchId,
      nonce_str: this.generateNonceStr(),
      out_trade_no: orderId,
      out_refund_no: refundId,
      total_fee: Math.round(totalAmount * 100),
      refund_fee: Math.round(amount * 100),
      notify_url: `${this.config.notifyUrl}/refund`
    };

    params.sign = this.sign(params);

    return this.request('secapi/pay/refund', params, true);
  }

  /**
   * 查询订单
   */
  async queryOrder(orderId: string) {
    const params = {
      appid: this.config.appId,
      mch_id: this.config.mchId,
      out_trade_no: orderId,
      nonce_str: this.generateNonceStr()
    };

    params.sign = this.sign(params);

    return this.request('pay/orderquery', params);
  }

  /**
   * 生成签名
   * @private
   */
  private sign(params: any): string {
    // 1. 参数排序
    const sortedKeys = Object.keys(params).sort();

    // 2. 拼接字符串
    const stringA = sortedKeys
      .filter(key => params[key] !== '' && key !== 'sign')
      .map(key => `${key}=${params[key]}`)
      .join('&');

    // 3. 拼接API密钥
    const stringSignTemp = `${stringA}&key=${this.config.apiKey}`;

    // 4. MD5加密并转大写
    return crypto
      .createHash('md5')
      .update(stringSignTemp, 'utf8')
      .digest('hex')
      .toUpperCase();
  }

  /**
   * 生成随机字符串
   * @private
   */
  private generateNonceStr(): string {
    return Math.random().toString(36).substring(2, 15) +
           Math.random().toString(36).substring(2, 15);
  }

  /**
   * 发起请求
   * @private
   */
  private async request(api: string, params: any, needCert = false) {
    // TODO: 实现XML请求和响应解析
    const xml = this.buildXml(params);
    // 发送HTTP请求...
    return {};
  }

  /**
   * 构建XML
   * @private
   */
  private buildXml(params: any): string {
    return Object.keys(params)
      .map(key => `<${key}><
![CDATA[${params[key]}]]></${key}>`)
      .join('');
  }

  /**
   * 解析响应
   * @private
   */
  private parseResponse(response: any, tradeType: string) {
    // 根据不同支付类型返回相应格式
    switch (tradeType) {
      case 'JSAPI':
        return {
          appId: response.appid,
          timeStamp: Math.floor(Date.now() / 1000).toString(),
          nonceStr: response.nonce_str,
          package: `prepay_id=${response.prepay_id}`,
          signType: 'MD5',
          paySign: this.sign(response)
        };
      case 'NATIVE':
        return {
          codeUrl: response.code_url
        };
      case 'MWEB':
        return {
          mwebUrl: response.mweb_url
        };
      default:
        return response;
    }
  }

  /**
   * 获取客户端IP
   * @private
   */
  private async getClientIp(): Promise<string> {
    // TODO: 从请求上下文获取IP
    return '127.0.0.1';
  }
}
```

##### 3.1.2 支付宝支付

```typescript
// src/shared/integrations/payment/alipay.service.ts
import { Injectable } from '@nestjs/common';
import * as crypto from 'crypto';

/**
 * 支付宝配置
 */
interface AlipayConfig {
  appId: string;
  privateKey: string;
  alipayPublicKey: string;
  gateway: string;
  notifyUrl: string;
}

/**
 * 支付宝服务
 */
@Injectable()
export class AlipayService {
  private readonly config: AlipayConfig;

  constructor() {
    this.config = {
      appId: process.env.ALIPAY_APP_ID,
      privateKey: process.env.ALIPAY_PRIVATE_KEY,
      alipayPublicKey: process.env.ALIPAY_PUBLIC_KEY,
      gateway: 'https://openapi.alipay.com/gateway.do',
      notifyUrl: process.env.ALIPAY_NOTIFY_URL
    };
  }

  /**
   * 创建支付订单（H5）
   */
  async createH5Pay(orderId: string, amount: number, subject: string, returnUrl: string) {
    const params = {
      app_id: this.config.appId,
      method: 'alipay.trade.page.pay',
      charset: 'utf-8',
      sign_type: 'RSA2',
      timestamp: this.getTimestamp(),
      version: '1.0',
      notify_url: this.config.notifyUrl,
      return_url: returnUrl,
      biz_content: JSON.stringify({
        out_trade_no: orderId,
        total_amount: amount.toFixed(2),
        subject,
        product_code: 'FAST_INSTANT_TRADE_PAY'
      })
    };

    params.sign = this.sign(params);

    return `${this.config.gateway}?${this.buildQuery(params)}`;
  }

  /**
   * 创建支付订单（APP）
   */
  async createAppPay(orderId: string, amount: number, subject: string) {
    const params = {
      app_id: this.config.appId,
      method: 'alipay.trade.app.pay',
      charset: 'utf-8',
      sign_type: 'RSA2',
      timestamp: this.getTimestamp(),
      version: '1.0',
      notify_url: this.config.notifyUrl,
      biz_content: JSON.stringify({
        out_trade_no: orderId,
        total_amount: amount.toFixed(2),
        subject,
        product_code: 'QUICK_MSECURITY_PAY'
      })
    };

    params.sign = this.sign(params);

    // 返回订单字符串，用于SDK调用
    return Object.keys(params)
      .map(key => `${key}=${encodeURIComponent(params[key])}`)
      .join('&');
  }

  /**
   * 验证回调签名
   */
  verifyNotify(data: any): boolean {
    const sign = data.sign;
    delete data.sign;
    delete data.sign_type;

    const sortedParams = Object.keys(data).sort();
    const stringA = sortedParams
      .map(key => `${key}=${data[key]}`)
      .join('&');

    const verify = crypto.createVerify('RSA-SHA256');
    verify.update(stringA, 'utf8');

    return verify.verify(this.config.alipayPublicKey, sign, 'base64');
  }

  /**
   * 申请退款
   */
  async refund(orderId: string, refundId: string, amount: number, reason?: string) {
    const params = {
      app_id: this.config.appId,
      method: 'alipay.trade.refund',
      charset: 'utf-8',
      sign_type: 'RSA2',
      timestamp: this.getTimestamp(),
      version: '1.0',
      biz_content: JSON.stringify({
        out_trade_no: orderId,
        out_request_no: refundId,
        refund_amount: amount.toFixed(2),
        refund_reason: reason || '正常退款'
      })
    };

    params.sign = this.sign(params);

    return this.request(params);
  }

  /**
   * 查询订单
   */
  async queryOrder(orderId: string) {
    const params = {
      app_id: this.config.appId,
      method: 'alipay.trade.query',
      charset: 'utf-8',
      sign_type: 'RSA2',
      timestamp: this.getTimestamp(),
      version: '1.0',
      biz_content: JSON.stringify({
        out_trade_no: orderId
      })
    };

    params.sign = this.sign(params);

    return this.request(params);
  }

  /**
   * 生成签名
   * @private
   */
  private sign(params: any): string {
    // 1. 过滤空值和sign
    const filtered = Object.keys(params)
      .filter(key => params[key] !== '' && key !== 'sign')
      .sort()
      .reduce((result, key) => {
        result[key] = params[key];
        return result;
      }, {} as any);

    // 2. 拼接字符串
    const stringA = Object.keys(filtered)
      .map(key => `${key}=${filtered[key]}`)
      .join('&');

    // 3. RSA2签名
    const sign = crypto
      .createSign('RSA-SHA256')
      .update(stringA, 'utf8')
      .sign(this.config.privateKey, 'base64');

    return sign;
  }

  /**
   * 发起请求
   * @private
   */
  private async request(params: any) {
    const formData = Object.keys(params)
      .map(key => `${key}=${encodeURIComponent(params[key])}`)
      .join('&');

    const response = await fetch(this.config.gateway, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: formData
    });

    return response.json();
  }

  /**
   * 构建查询字符串
   * @private
   */
  private buildQuery(params: any): string {
    return Object.keys(params)
      .map(key => `${key}=${encodeURIComponent(params[key])}`)
      .join('&');
  }

  /**
   * 获取时间戳
   * @private
   */
  private getTimestamp(): string {
    return new Date().toISOString().replace('T', ' ').substring(0, 19);
  }
}
```

#### 3.2 短信SDK集成

```typescript
// src/shared/integrations/sms/aliyun.service.ts
import { Injectable } from '@nestjs/common';
import RPCClient from '@alicloud/pop-core';

/**
 * 短信模板
 */
enum SmsTemplate {
  /** 验证码 */
  VERIFICATION_CODE = 'SMS_123456789',
  /** 登录通知 */
  LOGIN_NOTIFY = 'SMS_234567890',
  /** 订单通知 */
  ORDER_NOTIFY = 'SMS_345678901',
  /** 支付成功 */
  PAYMENT_SUCCESS = 'SMS_456789012'
}

/**
 * 阿里云短信服务
 */
@Injectable()
export class AliyunSmsService {
  private client: RPCClient;

  constructor() {
    this.client = new RPCClient({
      accessKeyId: process.env.ALIYUN_ACCESS_KEY_ID,
      accessKeySecret: process.env.ALIYUN_ACCESS_KEY_SECRET,
      endpoint: 'https://dysmsapi.aliyuncs.com',
      apiVersion: '2017-05-25'
    });
  }

  /**
   * 发送验证码短信
   */
  async sendVerificationCode(phone: string, code: string): Promise<boolean> {
    try {
      const result = await this.client.request('SendSms', {
        PhoneNumbers: phone,
        SignName: '海蓝健康',
        TemplateCode: SmsTemplate.VERIFICATION_CODE,
        TemplateParam: JSON.stringify({ code })
      });

      return result.Code === 'OK';
    } catch (error) {
      console.error('发送验证码短信失败:', error);
      return false;
    }
  }

  /**
   * 发送登录通知
   */
  async sendLoginNotify(phone: string, location: string): Promise<boolean> {
    try {
      const result = await this.client.request('SendSms', {
        PhoneNumbers: phone,
        SignName: '海蓝健康',
        TemplateCode: SmsTemplate.LOGIN_NOTIFY,
        TemplateParam: JSON.stringify({ location, time: new Date().toLocaleString() })
      });

      return result.Code === 'OK';
    } catch (error) {
      console.error('发送登录通知失败:', error);
      return false;
    }
  }

  /**
   * 发送订单通知
   */
  async sendOrderNotify(phone: string, orderNo: string): Promise<boolean> {
    try {
      const result = await this.client.request('SendSms', {
        PhoneNumbers: phone,
        SignName: '海蓝健康',
        TemplateCode: SmsTemplate.ORDER_NOTIFY,
        TemplateParam: JSON.stringify({ orderNo })
      });

      return result.Code === 'OK';
    } catch (error) {
      console.error('发送订单通知失败:', error);
      return false;
    }
  }

  /**
   * 批量发送短信
   */
  async sendBatch(phoneNumbers: string[], templateCode: SmsTemplate, params: Record<string, any>): Promise<any> {
    try {
      const result = await this.client.request('SendBatchSms', {
        PhoneNumberJson: JSON.stringify(phoneNumbers),
        SignNameJson: JSON.stringify(phoneNumbers.map(() => '海蓝健康')),
        TemplateCode: templateCode,
        TemplateParamJson: JSON.stringify(phoneNumbers.map(() => JSON.stringify(params)))
      });

      return result;
    } catch (error) {
      console.error('批量发送短信失败:', error);
      throw error;
    }
  }
}
```

#### 3.3 存储SDK集成

```typescript
// src/shared/integrations/storage/oss.service.ts
import { Injectable } from '@nestjs/common';
import * as OSS from 'ali-oss';
import { v4 as uuidv4 } from 'uuid';

/**
 * 文件上传结果
 */
interface UploadResult {
  url: string;
  name: string;
  size: number;
}

/**
 * 阿里云OSS服务
 */
@Injectable()
export class OssService {
  private client: OSS;

  constructor() {
    this.client = new OSS({
      region: process.env.OSS_REGION,
      accessKeyId: process.env.OSS_ACCESS_KEY_ID,
      accessKeySecret: process.env.OSS_ACCESS_KEY_SECRET,
      bucket: process.env.OSS_BUCKET
    });
  }

  /**
   * 上传文件
   */
  async uploadFile(
    file: Express.Multer.File,
    path: string = 'uploads'
  ): Promise<UploadResult> {
    const fileName = this.generateFileName(file.originalname);
    const objectKey = `${path}/${fileName}`;

    const result = await this.client.put(objectKey, file.buffer);

    return {
      url: result.url,
      name: fileName,
      size: file.size
    };
  }

  /**
   * 上传Base64图片
   */
  async uploadBase64(
    base64: string,
    path: string = 'images'
  ): Promise<UploadResult> {
    const buffer = Buffer.from(base64.replace(/^data:image\/\w+;base64,/, ''), 'base64');
    const fileName = this.generateFileName('image.png');
    const objectKey = `${path}/${fileName}`;

    const result = await this.client.put(objectKey, buffer);

    return {
      url: result.url,
      name: fileName,
      size: buffer.length
    };
  }

  /**
   * 批量上传
   */
  async uploadMultiple(
    files: Express.Multer.File[],
    path: string = 'uploads'
  ): Promise<UploadResult[]> {
    const uploadPromises = files.map(file => this.uploadFile(file, path));
    return Promise.all(uploadPromises);
  }

  /**
   * 删除文件
   */
  async deleteFile(objectKey: string): Promise<boolean> {
    try {
      await this.client.delete(objectKey);
      return true;
    } catch (error) {
      console.error('删除文件失败:', error);
      return false;
    }
  }

  /**
   * 批量删除
   */
  async deleteMultiple(objectKeys: string[]): Promise<boolean> {
    try {
      await this.client.deleteMulti(objectKeys);
      return true;
    } catch (error) {
      console.error('批量删除文件失败:', error);
      return false;
    }
  }

  /**
   * 获取临时访问URL（私有文件）
   */
  async getSignedUrl(objectKey: string, expires: number = 3600): Promise<string> {
    return this.client.signatureUrl(objectKey, { expires });
  }

  /**
   * 列出文件
   */
  async listFiles(prefix: string, maxKeys: number = 100): Promise<any[]> {
    const result = await this.client.list({
      prefix,
      'max-keys': maxKeys
    });

    return result.objects || [];
  }

  /**
   * 生成唯一文件名
   * @private
   */
  private generateFileName(originalName: string): string {
    const ext = originalName.split('.').pop();
    const uuid = uuidv4().replace(/-/g, '').substring(0, 16);
    const timestamp = Date.now();
    return `${uuid}_${timestamp}.${ext}`;
  }
}
```

#### 3.4 LLM SDK集成

```typescript
// src/shared/integrations/llm/openai.service.ts
import { Injectable } from '@nestjs/common';
import OpenAI from 'openai';

/**
 * LLM消息
 */
interface LLMMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

/**
 * LLM响应
 */
interface LLMResponse {
  content: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

/**
 * OpenAI服务
 */
@Injectable()
export class OpenaiService {
  private client: OpenAI;

  constructor() {
    this.client = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
      baseURL: process.env.OPENAI_BASE_URL // 支持中转API
    });
  }

  /**
   * 聊天对话
   */
  async chat(messages: LLMMessage[], options?: {
    model?: string;
    temperature?: number;
    maxTokens?: number;
  }): Promise<LLMResponse> {
    const {
      model = 'gpt-4',
      temperature = 0.7,
      maxTokens = 2000
    } = options || {};

    const response = await this.client.chat.completions.create({
      model,
      messages,
      temperature,
      max_tokens: maxTokens
    });

    return {
      content: response.choices[0].message.content || '',
      usage: {
        promptTokens: response.usage?.prompt_tokens || 0,
        completionTokens: response.usage?.completion_tokens || 0,
        totalTokens: response.usage?.total_tokens || 0
      }
    };
  }

  /**
   * 流式对话
   */
  async chatStream(
    messages: LLMMessage[],
    onChunk: (content: string) => void,
    options?: {
      model?: string;
      temperature?: number;
    }
  ): Promise<void> {
    const {
      model = 'gpt-4',
      temperature = 0.7
    } = options || {};

    const stream = await this.client.chat.completions.create({
      model,
      messages,
      temperature,
      stream: true
    });

    for await (const chunk of stream) {
      const content = chunk.choices[0]?.delta?.content || '';
      if (content) {
        onChunk(content);
      }
    }
  }

  /**
   * 文本Embedding
   */
  async embedding(text: string): Promise<number[]> {
    const response = await this.client.embeddings.create({
      model: 'text-embedding-ada-002',
      input: text
    });

    return response.data[0].embedding;
  }
}
```

#### 3.5 推送SDK集成

```typescript
// src/shared/integrations/push/push.service.ts
import { Injectable } from '@nestjs/common';
import * as admin from 'firebase-admin';

/**
 * 推送消息
 */
interface PushMessage {
  title: string;
  body: string;
  data?: Record<string, any>;
}

/**
 * FCM推送服务
 */
@Injectable()
export class PushService {
  private app: admin.app.App;

  constructor() {
    if (!admin.apps.length) {
      const serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
      this.app = admin.initializeApp({
        credential: admin.credential.cert(serviceAccount)
      });
    } else {
      this.app = admin.apps[0];
    }
  }

  /**
   * 发送推送
   */
  async sendToToken(token: string, message: PushMessage): Promise<boolean> {
    try {
      const response = await this.app.messaging().send({
        token,
        notification: {
          title: message.title,
          body: message.body
        },
        data: message.data
      });

      console.log('推送发送成功:', response);
      return true;
    } catch (error) {
      console.error('推送发送失败:', error);
      return false;
    }
  }

  /**
   * 批量发送
   */
  async sendMulticast(
    tokens: string[],
    message: PushMessage
  ): Promise<{ successCount: number; failureCount: number }> {
    try {
      const response = await this.app.messaging().sendMulticast({
        tokens,
        notification: {
          title: message.title,
          body: message.body
        },
        data: message.data
      });

      return {
        successCount: response.successCount,
        failureCount: response.failureCount
      };
    } catch (error) {
      console.error('批量推送失败:', error);
      return { successCount: 0, failureCount: tokens.length };
    }
  }

  /**
   * 发送给主题订阅者
   */
  async sendToTopic(topic: string, message: PushMessage): Promise<boolean> {
    try {
      const response = await this.app.messaging().send({
        topic,
        notification: {
          title: message.title,
          body: message.body
        },
        data: message.data
      });

      console.log('主题推送成功:', response);
      return true;
    } catch (error) {
      console.error('主题推送失败:', error);
      return false;
    }
  }

  /**
   * 订阅主题
   */
  async subscribeToTopic(tokens: string[], topic: string): Promise<boolean> {
    try {
      await this.app.messaging().subscribeToTopic(tokens, topic);
      return true;
    } catch (error) {
      console.error('订阅主题失败:', error);
      return false;
    }
  }
}
```

### 4. SDK管理器

```typescript
// src/shared/integrations/integration.manager.ts
import { Injectable } from '@nestjs/common';
import { WechatPayService } from './payment/wechatpay.service';
import { AlipayService } from './payment/alipay.service';
import { AliyunSmsService } from './sms/aliyun.service';
import { OssService } from './storage/oss.service';
import { OpenaiService } from './llm/openai.service';
import { PushService } from './push/push.service';

/**
 * 集成管理器
 * 统一管理所有第三方SDK
 */
@Injectable()
export class IntegrationManager {
  constructor(
    private readonly wechatPay: WechatPayService,
    private readonly alipay: AlipayService,
    private readonly sms: AliyunSmsService,
    private readonly oss: OssService,
    private readonly openai: OpenaiService,
    private readonly push: PushService
  ) {}

  get payment() {
    return {
      wechat: this.wechatPay,
      alipay: this.alipay
    };
  }

  get sms() {
    return this.sms;
  }

  get storage() {
    return this.oss;
  }

  get llm() {
    return this.openai;
  }

  get notification() {
    return this.push;
  }
}
```

### 5. 附录

#### 5.1 SDK配置清单

| SDK | 环境变量 | 说明 |
|-----|----------|------|
| 微信支付 | WECHAT_PAY_APP_ID | 应用ID |
| | WECHAT_PAY_MCH_ID | 商户号 |
| | WECHAT_PAY_API_KEY | API密钥 |
| 支付宝 | ALIPAY_APP_ID | 应用ID |
| | ALIPAY_PRIVATE_KEY | 应用私钥 |
| | ALIPAY_PUBLIC_KEY | 支付宝公钥 |
| 阿里云短信 | ALIYUN_ACCESS_KEY_ID | AccessKey ID |
| | ALIYUN_ACCESS_KEY_SECRET | AccessKey Secret |
| 阿里云OSS | OSS_BUCKET | 存储桶名称 |
| | OSS_REGION | 区域 |
| OpenAI | OPENAI_API_KEY | API密钥 |
| | OPENAI_BASE_URL | API地址（可选） |
| Firebase | FIREBASE_SERVICE_ACCOUNT | 服务账号JSON |

#### 5.2 错误处理建议

| 错误类型 | 处理策略 |
|----------|----------|
| 网络超时 | 重试3次，指数退避 |
| 签名错误 | 检查配置，记录告警 |
| 余额不足 | 通知管理员，降级服务 |
| API限流 | 排队处理，延迟重试 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
