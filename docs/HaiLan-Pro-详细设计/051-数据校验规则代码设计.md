---
@file: 051-数据校验规则代码设计.md
@description: HaiLan Pro 前后端数据校验规则的代码实现，包含参数、格式、业务规则校验
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-详细设计],[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 051 数据校验规则代码设计

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-详细设计-数据校验规则代码设计相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范数据校验规则代码设计相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 数据校验规则代码设计

#### 3.1 校验规则体系

```typescript
// src/shared/validation/index.ts
/**
 * 数据校验规则体系
 * - 基础类型校验：字符串、数字、布尔值等
 * - 格式校验：邮箱、手机号、身份证等
 * - 业务规则校验：年龄范围、金额限制等
 * - 组合校验：密码确认、时间段逻辑等
 */

/**
 * 校验结果
 */
interface ValidationResult {
  /** 是否通过 */
  valid: boolean;
  /** 错误信息 */
  errors?: ValidationError[];
}

/**
 * 校验错误详情
 */
interface ValidationError {
  /** 错误字段 */
  field: string;
  /** 错误消息 */
  message: string;
  /** 错误码 */
  code?: string;
  /** 无效值 */
  value?: any;
}
```

#### 3.2 前端校验实现

##### 3.2.1 表单校验规则

```typescript
// src/shared/validation/rules.ts
/**
 * 校验规则类型
 */
type ValidationRule = (value: any) => string | true;

/**
 * 通用校验规则集
 */
export const validationRules = {
  /**
   * 必填校验
   */
  required: (message = '此项为必填项'): ValidationRule => {
    return (value: any) => {
      if (value === null || value === undefined || value === '') {
        return message;
      }
      return true;
    };
  },

  /**
   * 邮箱格式校验
   */
  email: (message = '请输入有效的邮箱地址'): ValidationRule => {
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    return (value: string) => {
      if (!value) return true; // 空值由required规则处理
      if (!emailRegex.test(value)) {
        return message;
      }
      return true;
    };
  },

  /**
   * 手机号校验（中国大陆）
   */
  phone: (message = '请输入有效的手机号'): ValidationRule => {
    const phoneRegex = /^1[3-9]\d{9}$/;
    return (value: string) => {
      if (!value) return true;
      if (!phoneRegex.test(value)) {
        return message;
      }
      return true;
    };
  },

  /**
   * 密码强度校验
   * 至少8位，包含字母和数字
   */
  password: (message = '密码至少8位，需包含字母和数字'): ValidationRule => {
    const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d@$!%*#?&]{8,}$/;
    return (value: string) => {
      if (!value) return true;
      if (!passwordRegex.test(value)) {
        return message;
      }
      return true;
    };
  },

  /**
   * 密码确认校验
   */
  confirmPassword: (passwordField: string, message = '两次密码不一致'): ValidationRule => {
    return (value: string, formData: Record<string, any>) => {
      if (!value) return true;
      if (value !== formData[passwordField]) {
        return message;
      }
      return true;
    };
  },

  /**
   * 最小长度校验
   */
  minLength: (min: number, message?: string): ValidationRule => {
    const msg = message || `长度不能小于${min}位`;
    return (value: string) => {
      if (!value) return true;
      if (value.length < min) {
        return msg;
      }
      return true;
    };
  },

  /**
   * 最大长度校验
   */
  maxLength: (max: number, message?: string): ValidationRule => {
    const msg = message || `长度不能大于${max}位`;
    return (value: string) => {
      if (!value) return true;
      if (value.length > max) {
        return msg;
      }
      return true;
    };
  },

  /**
   * 数值范围校验
   */
  range: (min: number, max: number, message?: string): ValidationRule => {
    const msg = message || `请输入${min}到${max}之间的数值`;
    return (value: number) => {
      if (value === null || value === undefined) return true;
      if (value < min || value > max) {
        return msg;
      }
      return true;
    };
  },

  /**
   * URL格式校验
   */
  url: (message = '请输入有效的URL地址'): ValidationRule => {
    const urlRegex = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/;
    return (value: string) => {
      if (!value) return true;
      if (!urlRegex.test(value)) {
        return message;
      }
      return true;
    };
  },

  /**
   * 身份证号校验
   */
  idCard: (message = '请输入有效的身份证号'): ValidationRule => {
    const idCardRegex = /^[1-9]\d{5}(18|19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/;
    return (value: string) => {
      if (!value) return true;
      if (!idCardRegex.test(value)) {
        return message;
      }
      // 校验位验证
      return this.validateIdCardChecksum(value) ? true : message;
    };
  },

  /**
   * 年龄校验
   */
  age: (min: number = 0, max: number = 150, message?: string): ValidationRule => {
    const msg = message || `年龄必须在${min}到${max}岁之间`;
    return (value: number) => {
      if (value === null || value === undefined) return true;
      if (value < min || value > max) {
        return msg;
      }
      return true;
    };
  },

  /**
   * 自定义正则校验
   */
  pattern: (regex: RegExp, message = '格式不正确'): ValidationRule => {
    return (value: string) => {
      if (!value) return true;
      if (!regex.test(value)) {
        return message;
      }
      return true;
    };
  },

  /**
   * 身份证校验位验证
   * @private
   */
  validateIdCardChecksum(idCard: string): boolean {
    const weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
    const checkCodes = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];

    let sum = 0;
    for (let i = 0; i < 17; i++) {
      sum += parseInt(idCard[i]) * weights[i];
    }

    const checkCode = checkCodes[sum % 11];
    return checkCode === idCard[17].toUpperCase();
  }
};
```

##### 3.2.2 表单校验器

```typescript
// src/shared/validation/validator.ts
import { reactive, computed } from 'vue';

/**
 * 表单字段配置
 */
interface FieldConfig {
  /** 字段值 */
  value: any;
  /** 校验规则列表 */
  rules?: ValidationRule[];
  /** 是否触发过校验 */
  touched?: boolean;
  /** 错误消息 */
  error?: string;
}

/**
 * 表单校验器类
 */
export class FormValidator {
  private fields: Map<string, FieldConfig> = new Map();

  /**
   * 添加字段
   */
  addField(name: string, config: FieldConfig): void {
    this.fields.set(name, reactive({
      ...config,
      touched: false,
      error: ''
    }));
  }

  /**
   * 获取字段
   */
  getField(name: string): FieldConfig | undefined {
    return this.fields.get(name);
  }

  /**
   * 校验单个字段
   */
  async validateField(name: string): Promise<boolean> {
    const field = this.fields.get(name);
    if (!field) return false;

    field.touched = true;
    field.error = '';

    if (!field.rules || field.rules.length === 0) {
      return true;
    }

    for (const rule of field.rules) {
      const result = rule(field.value);
      if (result !== true) {
        field.error = result;
        return false;
      }
    }

    return true;
  }

  /**
   * 校验所有字段
   */
  async validateAll(): Promise<boolean> {
    let isValid = true;

    for (const [name] of this.fields) {
      const valid = await this.validateField(name);
      if (!valid) {
        isValid = false;
      }
    }

    return isValid;
  }

  /**
   * 重置表单
   */
  reset(): void {
    for (const field of this.fields.values()) {
      field.touched = false;
      field.error = '';
    }
  }

  /**
   * 清除所有错误
   */
  clearErrors(): void {
    for (const field of this.fields.values()) {
      field.error = '';
    }
  }

  /**
   * 获取表单数据
   */
  getFormData(): Record<string, any> {
    const data: Record<string, any> = {};
    for (const [name, field] of this.fields) {
      data[name] = field.value;
    }
    return data;
  }

  /**
   * 是否有错误
   */
  get hasErrors(): boolean {
    for (const field of this.fields.values()) {
      if (field.error) return true;
    }
    return false;
  }
}

/**
 * 创建表单校验器
 */
export function useFormValidator() {
  const validator = new FormValidator();

  const isValid = computed(() => !validator.hasErrors);

  return {
    validator,
    isValid
  };
}
```

##### 3.2.3 Vue组件中使用

```vue
<template>
  <form @submit.prevent="handleSubmit">
    <div class="form-group">
      <label>邮箱</label>
      <input
        v-model="formData.email"
        @blur="validator.validateField('email')"
      />
      <span v-if="getFieldError('email')" class="error">
        {{ getFieldError('email') }}
      </span>
    </div>

    <div class="form-group">
      <label>密码</label>
      <input
        v-model="formData.password"
        type="password"
        @blur="validator.validateField('password')"
      />
      <span v-if="getFieldError('password')" class="error">
        {{ getFieldError('password') }}
      </span>
    </div>

    <div class="form-group">
      <label>确认密码</label>
      <input
        v-model="formData.confirmPassword"
        type="password"
        @blur="validator.validateField('confirmPassword')"
      />
      <span v-if="getFieldError('confirmPassword')" class="error">
        {{ getFieldError('confirmPassword') }}
      </span>
    </div>

    <button type="submit" :disabled="!isValid">注册</button>
  </form>
</template>

<script setup lang="ts">
import { reactive, computed } from 'vue';
import { useFormValidator } from '@/shared/validation/validator';
import { validationRules } from '@/shared/validation/rules';

const formData = reactive({
  email: '',
  password: '',
  confirmPassword: ''
});

const { validator, isValid } = useFormValidator();

// 添加字段和校验规则
validator.addField('email', {
  value: computed(() => formData.email),
  rules: [
    validationRules.required('请输入邮箱'),
    validationRules.email()
  ]
});

validator.addField('password', {
  value: computed(() => formData.password),
  rules: [
    validationRules.required('请输入密码'),
    validationRules.password()
  ]
});

validator.addField('confirmPassword', {
  value: computed(() => formData.confirmPassword),
  rules: [
    validationRules.required('请确认密码'),
    validationRules.confirmPassword('password')
  ]
});

const getFieldError = (fieldName: string) => {
  return validator.getField(fieldName)?.error || '';
};

const handleSubmit = async () => {
  const valid = await validator.validateAll();
  if (valid) {
    console.log('表单提交:', formData);
  }
};
</script>
```

#### 3.3 后端校验实现

##### 3.3.1 DTO校验装饰器

```typescript
// src/shared/decorators/validation.decorator.ts
import {
  registerDecorator,
  ValidationOptions,
  ValidationArguments,
  ValidatorConstraint,
  ValidatorConstraintInterface
} from 'class-validator';

/**
 * 自定义校验装饰器 - 密码强度
 */
export function IsStrongPassword(validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isStrongPassword',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any) {
          if (!value) return true;
          const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d@$!%*#?&]{8,}$/;
          return passwordRegex.test(value);
        },
        defaultMessage(args: ValidationArguments) {
          return '密码至少8位，需包含字母和数字';
        }
      }
    });
  };
}

/**
 * 自定义校验装饰器 - 手机号
 */
export function IsPhone(validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isPhone',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any) {
          if (!value) return true;
          return /^1[3-9]\d{9}$/.test(value);
        },
        defaultMessage(args: ValidationArguments) {
          return '请输入有效的手机号';
        }
      }
    });
  };
}

/**
 * 自定义校验装饰器 - 用户昵称
 */
export function IsNickname(validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isNickname',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any) {
          if (!value) return true;
          // 2-20位，支持中文、字母、数字、下划线
          return /^[\u4e00-\u9fa5a-zA-Z0-9_]{2,20}$/.test(value);
        },
        defaultMessage(args: ValidationArguments) {
          return '昵称应为2-20位，支持中文、字母、数字、下划线';
        }
      }
    });
  };
}

/**
 * 条件校验装饰器
 * 当指定字段满足条件时才校验
 */
export function ValidateIf(
  condition: (object: any) => boolean,
  validationOptions?: ValidationOptions
) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'validateIf',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          if (!condition(args.object)) {
            return true;
          }
          return value !== null && value !== undefined && value !== '';
        },
        defaultMessage(args: ValidationArguments) {
          return '此字段为必填项';
        }
      }
    });
  };
}

/**
 * 字段匹配校验装饰器
 * 用于确认密码等场景
 */
export function MatchField(property: string, validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'matchField',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [property],
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          if (!value) return true;
          const relatedValue = (args.object as any)[property];
          return value === relatedValue;
        },
        defaultMessage(args: ValidationArguments) {
          return `必须与${args.constraints[0]}保持一致`;
        }
      }
    });
  };
}
```

##### 3.3.2 DTO定义示例

```typescript
// src/modules/auth/dto/register.dto.ts
import {
  IsEmail,
  IsNotEmpty,
  IsString,
  Length,
  IsOptional
} from 'class-validator';
import {
  IsStrongPassword,
  IsPhone,
  IsNickname
} from '@/shared/decorators/validation.decorator';
import { ApiProperty } from '@nestjs/swagger';

/**
 * 用户注册DTO
 */
export class RegisterDto {
  @ApiProperty({ description: '邮箱', example: 'user@example.com' })
  @IsNotEmpty({ message: '邮箱不能为空' })
  @IsEmail({}, { message: '请输入有效的邮箱地址' })
  email: string;

  @ApiProperty({ description: '密码', example: 'Pass1234' })
  @IsNotEmpty({ message: '密码不能为空' })
  @Length(8, 30, { message: '密码长度应为8-30位' })
  @IsStrongPassword()
  password: string;

  @ApiProperty({ description: '确认密码', example: 'Pass1234' })
  @IsNotEmpty({ message: '请确认密码' })
  @MatchField('password')
  confirmPassword: string;

  @ApiProperty({
    description: '昵称',
    example: '海蓝用户',
    required: false
  })
  @IsOptional()
  @IsNickname()
  nickname?: string;

  @ApiProperty({
    description: '手机号',
    example: '13800138000',
    required: false
  })
  @IsOptional()
  @IsPhone()
  phone?: string;

  @ApiProperty({ description: '邮箱验证码', example: '123456' })
  @IsNotEmpty({ message: '验证码不能为空' })
  @IsString()
  @Length(6, 6, { message: '验证码应为6位' })
  verificationCode: string;
}

/**
 * 用户登录DTO
 */
export class LoginDto {
  @ApiProperty({
    description: '账号（邮箱或手机号）',
    example: 'user@example.com'
  })
  @IsNotEmpty({ message: '账号不能为空' })
  @IsString()
  account: string;

  @ApiProperty({ description: '密码', example: 'Pass1234' })
  @IsNotEmpty({ message: '密码不能为空' })
  @IsString()
  password: string;

  @ApiProperty({
    description: '图形验证码',
    example: 'abcd',
    required: false
  })
  @IsOptional()
  @IsString()
  captchaCode?: string;
}
```

##### 3.3.3 全局校验管道

```typescript
// src/shared/pipes/validation.pipe.ts
import {
  PipeTransform,
  Injectable,
  ArgumentMetadata,
  BadRequestException
} from '@nestjs/common';
import { validate } from 'class-validator';
import { plainToClass } from 'class-transformer';

/**
 * 全局校验管道
 * 自动校验所有DTO
 */
@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }

    const object = plainToClass(metatype, value);
    const errors = await validate(object);

    if (errors.length > 0) {
      const messages = this.formatErrors(errors);
      throw new BadRequestException({
        code: 'VALIDATION_ERROR',
        message: '数据校验失败',
        details: messages
      });
    }

    return object;
  }

  /**
   * 判断是否需要校验
   * @private
   */
  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object];
    return !types.includes(metatype);
  }

  /**
   * 格式化错误信息
   * @private
   */
  private formatErrors(errors: any[]): Record<string, string[]> {
    const messages: Record<string, string[]> = {};

    for (const error of errors) {
      const field = error.property;
      const constraints = error.constraints;

      messages[field] = Object.values(constraints);
    }

    return messages;
  }
}

// 在main.ts中启用
// app.useGlobalPipes(new ValidationPipe());
```

#### 3.4 业务规则校验

```typescript
// src/shared/validation/business-rules.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '@/modules/user/entities/user.entity';
import { Product } from '@/modules/product/entities/product.entity';

/**
 * 业务规则校验服务
 */
@Injectable()
export class BusinessRuleValidator {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(Product)
    private readonly productRepository: Repository<Product>,
  ) {}

  /**
   * 校验用户年龄限制
   * 情趣健康类商品要求用户年满18岁
   */
  async validateUserAge(userId: string): Promise<boolean> {
    const user = await this.userRepository.findOne({
      where: { id: userId }
    });

    if (!user || !user.birthDate) {
      throw new BadRequestException('用户信息不完整');
    }

    const age = this.calculateAge(user.birthDate);
    if (age < 18) {
      throw new BadRequestException('根据相关法律法规，您未满18岁，无法使用此服务');
    }

    return true;
  }

  /**
   * 校验商品库存
   */
  async validateProductStock(productId: string, quantity: number): Promise<boolean> {
    const product = await this.productRepository.findOne({
      where: { id: productId }
    });

    if (!product) {
      throw new NotFoundException('商品不存在');
    }

    if (product.stock < quantity) {
      throw new BadRequestException(`商品库存不足，当前库存：${product.stock}`);
    }

    return true;
  }

  /**
   * 校验订单金额限制
   */
  validateOrderAmount(amount: number): boolean {
    const minAmount = 1; // 最低1元
    const maxAmount = 50000; // 最高5万元

    if (amount < minAmount) {
      throw new BadRequestException('订单金额不能低于1元');
    }

    if (amount > maxAmount) {
      throw new BadRequestException('订单金额不能超过5万元');
    }

    return true;
  }

  /**
   * 校验用户每日下单次数
   */
  async validateDailyOrderLimit(userId: string): Promise<boolean> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const orderCount = await this.orderRepository.count({
      where: {
        userId,
        createdAt: { $gte: today, $lt: tomorrow }
      }
    });

    const dailyLimit = 20;
    if (orderCount >= dailyLimit) {
      throw new BadRequestException('今日下单次数已达上限');
    }

    return true;
  }

  /**
   * 计算年龄
   * @private
   */
  private calculateAge(birthDate: Date): number {
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();

    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }

    return age;
  }
}
```

### 4. 附录

#### 4.1 常用正则表达式

| 用途 | 正则表达式 | 说明 |
|------|-----------|------|
| 邮箱 | `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$` | 标准邮箱格式 |
| 手机号 | `^1[3-9]\d{9}$` | 中国大陆手机号 |
| 身份证 | `^[1-9]\d{5}(18\|19\|20)\d{2}(0[1-9]\|1[0-2])(0[1-9]\|[12]\d\|3[01])\d{3}[\dXx]$` | 18位身份证 |
| 密码 | `^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d@$!%*#?&]{8,}$` | 至少8位，含字母数字 |
| URL | `^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}` | HTTP/HTTPS地址 |
| 昵称 | `^[\u4e00-\u9fa5a-zA-Z0-9_]{2,20}$` | 2-20位中英文数字下划线 |
| 验证码 | `^\d{6}$` | 6位数字验证码 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
