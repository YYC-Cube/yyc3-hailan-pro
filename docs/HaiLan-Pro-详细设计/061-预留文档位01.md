---
file: 061-预留文档位01.md
description: HaiLan Pro 详细设计类扩展文档预留位，全栈代码植入扩展使用
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-详细设计,[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 061 预留文档位01

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-详细设计-预留文档位01相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范预留文档位01相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 通知中心设计

#### 3.1 通知系统架构

```typescript
// src/modules/notification/entities/notification.entity.ts
import { Entity, PrimaryColumn, Column } from 'typeorm';

/**
 * 通知类型
 */
export enum NotificationType {
  /** 系统通知 */
  SYSTEM = 'system',
  /** 订单通知 */
  ORDER = 'order',
  /** 物流通知 */
  SHIPPING = 'shipping',
  /** 活动通知 */
  PROMOTION = 'promotion',
  /** 社交通知 */
  SOCIAL = 'social'
}

/**
 * 通知状态
 */
export enum NotificationStatus {
  /** 未读 */
  UNREAD = 'unread',
  /** 已读 */
  READ = 'read',
  /** 已删除 */
  DELETED = 'deleted'
}

/**
 * 通知实体
 */
@Entity('notifications')
export class Notification {
  @PrimaryColumn({ type: 'varchar', length: 32 })
  id: string;

  @Column({ type: 'varchar', length: 32 })
  userId: string;

  @Column({ type: 'enum', enum: NotificationType })
  type: NotificationType;

  @Column({ type: 'varchar', length: 200 })
  title: string;

  @Column({ type: 'text' })
  content: string;

  @Column({ type: 'jsonb', nullable: true })
  data?: Record<string, any>;

  @Column({ type: 'enum', enum: NotificationStatus, default: NotificationStatus.UNREAD })
  status: NotificationStatus;

  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  createdAt: Date;

  @Column({ type: 'timestamp', nullable: true })
  readAt?: Date;

  @Column({ type: 'varchar', length: 100', nullable: true })
  actionUrl?: string;

  @Column({ type: 'varchar', length: 50', nullable: true })
  actionText?: string;
}
```

#### 3.2 通知服务实现

```typescript
// src/modules/notification/services/notification.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Notification, NotificationType, NotificationStatus } from '../entities/notification.entity';
import { PushService } from '@/shared/integrations/push/push.service';

/**
 * 创建通知参数
 */
interface CreateNotificationDto {
  userId: string;
  type: NotificationType;
  title: string;
  content: string;
  data?: Record<string, any>;
  actionUrl?: string;
  actionText?: string;
}

/**
 * 批量创建通知参数
 */
interface CreateBatchNotificationDto {
  userIds: string[];
  type: NotificationType;
  title: string;
  content: string;
  data?: Record<string, any>;
  actionUrl?: string;
  actionText?: string;
}

/**
 * 通知服务
 */
@Injectable()
export class NotificationService {
  constructor(
    @InjectRepository(Notification)
    private readonly notificationRepository: Repository<Notification>,
    private readonly pushService: PushService
  ) {}

  /**
   * 创建通知
   */
  async create(dto: CreateNotificationDto): Promise<Notification> {
    const notification = this.notificationRepository.create({
      id: this.generateNotificationId(),
      ...dto
    });

    const saved = await this.notificationRepository.save(notification);

    // 发送推送通知
    this.sendPushNotification(dto.userId, dto.title, dto.content, dto.data).catch(err => {
      console.error('发送推送失败:', err);
    });

    return saved;
  }

  /**
   * 批量创建通知
   */
  async createBatch(dto: CreateBatchNotificationDto): Promise<Notification[]> {
    const notifications = dto.userIds.map(userId =>
      this.notificationRepository.create({
        id: this.generateNotificationId(),
        userId,
        type: dto.type,
        title: dto.title,
        content: dto.content,
        data: dto.data,
        actionUrl: dto.actionUrl,
        actionText: dto.actionText
      })
    );

    const saved = await this.notificationRepository.save(notifications);

    // 批量发送推送
    this.sendBatchPushNotifications(dto.userIds, dto.title, dto.content).catch(err => {
      console.error('批量推送失败:', err);
    });

    return saved;
  }

  /**
   * 获取用户通知列表
   */
  async getUserNotifications(
    userId: string,
    options: {
      status?: NotificationStatus;
      type?: NotificationType;
      page?: number;
      pageSize?: number;
    } = {}
  ) {
    const { status, type, page = 1, pageSize = 20 } = options;

    const queryBuilder = this.notificationRepository
      .createQueryBuilder('n')
      .where('n.userId = :userId', { userId })
      .andWhere('n.status != :deleted', { deleted: NotificationStatus.DELETED })
      .orderBy('n.createdAt', 'DESC');

    if (status) {
      queryBuilder.andWhere('n.status = :status', { status });
    }

    if (type) {
      queryBuilder.andWhere('n.type = :type', { type });
    }

    const [items, total] = await queryBuilder
      .skip((page - 1) * pageSize)
      .take(pageSize)
      .getManyAndCount();

    return { items, total, page, pageSize, totalPages: Math.ceil(total / pageSize) };
  }

  /**
   * 标记为已读
   */
  async markAsRead(notificationId: string, userId: string): Promise<void> {
    await this.notificationRepository.update(
      { id: notificationId, userId },
      { status: NotificationStatus.READ, readAt: new Date() }
    );
  }

  /**
   * 全部标记为已读
   */
  async markAllAsRead(userId: string): Promise<void> {
    await this.notificationRepository.update(
      { userId, status: NotificationStatus.UNREAD },
      { status: NotificationStatus.READ, readAt: new Date() }
    );
  }

  /**
   * 删除通知
   */
  async delete(notificationId: string, userId: string): Promise<void> {
    await this.notificationRepository.update(
      { id: notificationId, userId },
      { status: NotificationStatus.DELETED }
    );
  }

  /**
   * 获取未读数量
   */
  async getUnreadCount(userId: string): Promise<number> {
    return this.notificationRepository.count({
      where: { userId, status: NotificationStatus.UNREAD }
    });
  }

  /**
   * 发送推送通知
   * @private
   */
  private async sendPushNotification(
    userId: string,
    title: string,
    body: string,
    data?: Record<string, any>
  ): Promise<void> {
    // 获取用户推送Token
    const tokens = await this.getUserPushTokens(userId);

    for (const token of tokens) {
      await this.pushService.sendToToken(token, { title, body, data });
    }
  }

  /**
   * 批量发送推送
   * @private
   */
  private async sendBatchPushNotifications(
    userIds: string[],
    title: string,
    body: string
  ): Promise<void> {
    // 获取所有用户的推送Token
    const tokens = await this.getUsersPushTokens(userIds);

    await this.pushService.sendMulticast(tokens, { title, body });
  }

  /**
   * 获取用户推送Token
   * @private
   */
  private async getUserPushTokens(userId: string): Promise<string[]> {
    // TODO: 从数据库获取用户的推送Token
    return [];
  }

  /**
   * 批量获取推送Token
   * @private
   */
  private async getUsersPushTokens(userIds: string[]): Promise<string[]> {
    // TODO: 批量获取推送Token
    return [];
  }

  /**
   * 生成通知ID
   * @private
   */
  private generateNotificationId(): string {
    return `notif_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
  }
}
```

#### 3.3 模板通知

```typescript
// src/modules-notification/services/template.service.ts
import { Injectable } from '@nestjs/common';
import { NotificationService } from './notification.service';
import { NotificationType } from '../entities/notification.entity';

/**
 * 模板通知服务
 * 提供常用通知模板
 */
@Injectable()
export class NotificationTemplateService {
  constructor(
    private readonly notificationService: NotificationService
  ) {}

  /**
   * 订单创建通知
   */
  async orderCreated(userId: string, orderNo: string, amount: number) {
    return this.notificationService.create({
      userId,
      type: NotificationType.ORDER,
      title: '订单创建成功',
      content: `您的订单 ${orderNo} 已创建成功，金额 ¥${amount.toFixed(2)}`,
      data: { orderNo, amount },
      actionUrl: `/orders/${orderNo}`,
      actionText: '查看订单'
    });
  }

  /**
   * 订单支付成功通知
   */
  async orderPaid(userId: string, orderNo: string, amount: number) {
    return this.notificationService.create({
      userId,
      type: NotificationType.ORDER,
      title: '订单支付成功',
      content: `您的订单 ${orderNo} 已支付成功，金额 ¥${amount.toFixed(2)}`,
      data: { orderNo, amount },
      actionUrl: `/orders/${orderNo}`,
      actionText: '查看订单'
    });
  }

  /**
   * 订单发货通知
   */
  async orderShipped(userId: string, orderNo: string, logisticsCompany: string, trackingNo: string) {
    return this.notificationService.create({
      userId,
      type: NotificationType.SHIPPING,
      title: '订单已发货',
      content: `您的订单 ${orderNo} 已发货，物流公司：${logisticsCompany}，运单号：${trackingNo}`,
      data: { orderNo, logisticsCompany, trackingNo },
      actionUrl: `/orders/${orderNo}/logistics`,
      actionText: '查看物流'
    });
  }

  /**
   * 促销活动通知
   */
  async promotion(userIds: string[], title: string, content: string, imageUrl?: string) {
    return this.notificationService.createBatch({
      userIds,
      type: NotificationType.PROMOTION,
      title,
      content,
      data: { imageUrl },
      actionUrl: '/promotions',
      actionText: '查看活动'
    });
  }

  /**
   * 系统公告
   */
  async systemAnnouncement(userIds: string[], title: string, content: string) {
    return this.notificationService.createBatch({
      userIds,
      type: NotificationType.SYSTEM,
      title: '系统公告',
      content: title + '\n' + content,
      data: {},
      actionUrl: '/announcements',
      actionText: '查看详情'
    });
  }

  /**
   * 欢迎通知
   */
  async welcome(userId: string, nickname: string) {
    return this.notificationService.create({
      userId,
      type: NotificationType.SYSTEM,
      title: '欢迎加入海蓝',
      content: `亲爱的${nickname}，欢迎来到海蓝健康！开始您的健康生活之旅吧。`,
      data: {},
      actionUrl: '/guide',
      actionText: '新手引导'
    });
  }
}
```

### 4. 实时通知

#### 4.1 WebSocket推送

```typescript
// src/modules/websocket/gateway/notification.gateway.ts
import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  OnGatewayConnection,
  OnGatewayDisconnect
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';

/**
 * 通知网关
 * 实时推送通知到客户端
 */
@WebSocketGateway({
  cors: { origin: '*' },
  namespace: '/notifications'
})
export class NotificationGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  /** 用户ID到Socket ID的映射 */
  private userSockets: Map<string, Set<string>> = new Map();
  /** Socket ID到用户ID的映射 */
  private socketUsers: Map<string, string> = new Map();

  /**
   * 连接建立
   */
  handleConnection(client: Socket) {
    const userId = this.getUserId(client);

    if (userId) {
      this.addUserSocket(userId, client.id);
      client.join(`user:${userId}`);

      console.log(`用户 ${userId} 连接成功，Socket ID: ${client.id}`);

      // 发送未读数量
      this.sendUnreadCount(userId);
    }
  }

  /**
   * 连接断开
   */
  handleDisconnect(client: Socket) {
    const userId = this.socketUsers.get(client.id);

    if (userId) {
      this.removeUserSocket(userId, client.id);
      console.log(`用户 ${userId} 断开连接，Socket ID: ${client.id}`);
    }

    this.socketUsers.delete(client.id);
  }

  /**
   * 订阅通知
   */
  @SubscribeMessage('subscribe')
  handleSubscribe(client: Socket) {
    const userId = this.getUserId(client);
    if (userId) {
      client.join(`user:${userId}`);
      console.log(`用户 ${userId} 订阅通知`);
    }
  }

  /**
   * 推送通知给用户
   */
  pushToUser(userId: string, notification: any) {
    this.server.to(`user:${userId}`).emit('notification', notification);
  }

  /**
   * 推送未读数量
   */
  pushUnreadCount(userId: string, count: number) {
    this.server.to(`user:${userId}`).emit('unread_count', { count });
  }

  /**
   * 获取用户ID
   * @private
   */
  private getUserId(client: Socket): string | null {
    // 从认证信息中获取用户ID
    return client.handshake.auth?.userId || null;
  }

  /**
   * 添加用户Socket映射
   * @private
   */
  private addUserSocket(userId: string, socketId: string) {
    if (!this.userSockets.has(userId)) {
      this.userSockets.set(userId, new Set());
    }
    this.userSockets.get(userId).add(socketId);
    this.socketUsers.set(socketId, userId);
  }

  /**
   * 移除用户Socket映射
   * @private
   */
  private removeUserSocket(userId: string, socketId: string) {
    const sockets = this.userSockets.get(userId);
    if (sockets) {
      sockets.delete(socketId);
      if (sockets.size === 0) {
        this.userSockets.delete(userId);
      }
    }
  }

  /**
   * 发送未读数量
   * @private
   */
  private async sendUnreadCount(userId: string) {
    // TODO: 获取未读数量
    const count = 0;
    this.pushUnreadCount(userId, count);
  }
}
```

### 5. 附录

#### 5.1 通知类型与模板

| 类型 | 场景 | 推送 | 站内信 |
|------|------|------|--------|
| ORDER | 订单状态变更 | ✓ | ✓ |
| SHIPPING | 物流状态更新 | ✓ | ✓ |
| PROMOTION | 促销活动 | ✓ | ✓ |
| SYSTEM | 系统公告 | - | ✓ |
| SOCIAL | 社交互动 | ✓ | ✓ |

#### 5.2 通知优先级

| 优先级 | 类型 | 说明 |
|--------|------|------|
| 高 | ORDER, SHIPPING | 订单物流类 |
| 中 | SYSTEM | 系统公告 |
| 低 | PROMOTION, SOCIAL | 营销社交类 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
