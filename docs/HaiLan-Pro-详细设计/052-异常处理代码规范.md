---
file: 052-异常处理代码规范.md
description: HaiLan Pro 系统全局异常、业务异常、技术异常的处理规范与代码实现
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-详细设计,[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 052 异常处理代码规范

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-详细设计-异常处理代码规范相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范异常处理代码规范相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 异常处理代码规范

#### 3.1 异常体系设计

```typescript
// src/shared/exceptions/index.ts
/**
 * 异常分类体系
 * - 系统异常：网络、数据库、消息队列等基础设施问题
 * - 业务异常：业务规则校验失败、资源不存在等
 * - 安全异常：认证失败、权限不足等
 */

/**
 * 基础异常类
 */
export abstract class BaseException extends Error {
  /**
   * 错误码
   */
  readonly code: string;

  /**
   * HTTP状态码
   */
  readonly statusCode: number;

  /**
   * 错误详情
   */
  readonly details?: any;

  constructor(
    code: string,
    message: string,
    statusCode: number = 500,
    details?: any
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.details = details;
    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * 转换为响应格式
   */
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      details: this.details,
      timestamp: Date.now()
    };
  }
}
```

#### 3.2 系统异常定义

```typescript
// src/shared/exceptions/system.exception.ts
import { BaseException } from './index';

/**
 * 网络异常
 */
export class NetworkException extends BaseException {
  constructor(message = '网络连接失败', details?: any) {
    super('NETWORK_ERROR', message, 503, details);
  }
}

/**
 * 数据库异常
 */
export class DatabaseException extends BaseException {
  constructor(message = '数据库操作失败', details?: any) {
    super('DATABASE_ERROR', message, 500, details);
  }
}

/**
 * 缓存异常
 */
export class CacheException extends BaseException {
  constructor(message = '缓存服务异常', details?: any) {
    super('CACHE_ERROR', message, 500, details);
  }
}

/**
 * 消息队列异常
 */
export class QueueException extends BaseException {
  constructor(message = '消息队列异常', details?: any) {
    super('QUEUE_ERROR', message, 500, details);
  }
}

/**
 * 外部服务异常
 */
export class ExternalServiceException extends BaseException {
  constructor(service: string, message?: string, details?: any) {
    super(
      'EXTERNAL_SERVICE_ERROR',
      message || `外部服务${service}调用失败`,
      503,
      { service, ...details }
    );
  }
}

/**
 * 文件处理异常
 */
export class FileException extends BaseException {
  constructor(message = '文件处理失败', details?: any) {
    super('FILE_ERROR', message, 500, details);
  }
}

/**
 * 配置异常
 */
export class ConfigException extends BaseException {
  constructor(message = '配置错误', details?: any) {
    super('CONFIG_ERROR', message, 500, details);
  }
}
```

#### 3.3 业务异常定义

```typescript
// src/shared/exceptions/business.exception.ts
import { BaseException } from './index';
import { HttpStatus } from '@nestjs/common';

/**
 * 资源未找到异常
 */
export class NotFoundException extends BaseException {
  constructor(resource: string, identifier?: string) {
    const message = identifier
      ? `${resource} [${identifier}] 不存在`
      : `${resource} 不存在`;
    super('NOT_FOUND', message, HttpStatus.NOT_FOUND, { resource, identifier });
  }
}

/**
 * 资源已存在异常
 */
export class ConflictException extends BaseException {
  constructor(resource: string, identifier?: string) {
    const message = identifier
      ? `${resource} [${identifier}] 已存在`
      : `${resource} 已存在`;
    super('CONFLICT', message, HttpStatus.CONFLICT, { resource, identifier });
  }
}

/**
 * 参数校验异常
 */
export class ValidationException extends BaseException {
  constructor(errors: Record<string, string[]>) {
    super(
      'VALIDATION_ERROR',
      '参数校验失败',
      HttpStatus.BAD_REQUEST,
      { errors }
    );
  }
}

/**
 * 业务规则异常
 */
export class BusinessException extends BaseException {
  constructor(message: string, code = 'BUSINESS_ERROR', details?: any) {
    super(code, message, HttpStatus.BAD_REQUEST, details);
  }
}

/**
 * 库存不足异常
 */
export class InsufficientStockException extends BusinessException {
  constructor(productName: string, requested: number, available: number) {
    super(
      `商品 ${productName} 库存不足，需要 ${requested} 件，仅剩 ${available} 件`,
      'INSUFFICIENT_STOCK',
      { productName, requested, available }
    );
  }
}

/**
 * 订单状态异常
 */
export class OrderStatusException extends BusinessException {
  constructor(orderId: string, currentStatus: string, action: string) {
    super(
      `订单 ${orderId} 当前状态为 ${currentStatus}，无法执行 ${action} 操作`,
      'INVALID_ORDER_STATUS',
      { orderId, currentStatus, action }
    );
  }
}

/**
 * 支付异常
 */
export class PaymentException extends BusinessException {
  constructor(message: string, details?: any) {
    super(message, 'PAYMENT_ERROR', details);
  }
}

/**
 * 支付金额不匹配异常
 */
export class PaymentAmountMismatchException extends PaymentException {
  constructor(expected: number, actual: number) {
    super(
      `支付金额不匹配，预期 ${expected} 元，实际 ${actual} 元`,
      { expected, actual }
    );
  }
}
```

#### 3.4 安全异常定义

```typescript
// src/shared/exceptions/security.exception.ts
import { BaseException } from './index';
import { HttpStatus } from '@nestjs/common';

/**
 * 未认证异常
 */
export class UnauthorizedException extends BaseException {
  constructor(message = '未认证或认证已失效') {
    super('UNAUTHORIZED', message, HttpStatus.UNAUTHORIZED);
  }
}

/**
 * Token无效异常
 */
export class InvalidTokenException extends UnauthorizedException {
  constructor() {
    super('Token无效或已过期，请重新登录');
  }
}

/**
 * 权限不足异常
 */
export class ForbiddenException extends BaseException {
  constructor(resource?: string, action?: string) {
    const message = resource && action
      ? `您没有权限对 ${resource} 执行 ${action} 操作`
      : '权限不足';
    super('FORBIDDEN', message, HttpStatus.FORBIDDEN, { resource, action });
  }
}

/**
 * 验证码错误异常
 */
export class CaptchaException extends BaseException {
  constructor(message = '验证码错误') {
    super('CAPTCHA_ERROR', message, HttpStatus.BAD_REQUEST);
  }
}

/**
 * 频率限制异常
 */
export class RateLimitException extends BaseException {
  constructor(limit: number, window: string) {
    super(
      'RATE_LIMIT_EXCEEDED',
      `请求过于频繁，${window}内最多请求 ${limit} 次`,
      HttpStatus.TOO_MANY_REQUESTS,
      { limit, window }
    );
  }
}

/**
 * 敏感操作异常
 */
export class SensitiveOperationException extends BaseException {
  constructor(operation: string) {
    super(
      'SENSITIVE_OPERATION',
      `操作 ${operation} 需要额外验证`,
      HttpStatus.FORBIDDEN,
      { operation }
    );
  }
}

/**
 * 年龄限制异常
 */
export class AgeRestrictionException extends BaseException {
  constructor(requiredAge: number, actualAge?: number) {
    const message = actualAge
      ? `根据相关法律法规，您未满 ${requiredAge} 岁，无法使用此服务`
      : `根据相关法律法规，您需要年满 ${requiredAge} 岁才能使用此服务`;
    super(
      'AGE_RESTRICTION',
      message,
      HttpStatus.FORBIDDEN,
      { requiredAge, actualAge }
    );
  }
}
```

#### 3.5 全局异常过滤器

```typescript
// src/shared/filters/global-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger
} from '@nestjs/common';
import { Request, Response } from 'express';
import { BaseException } from '../exceptions';
import { ConfigService } from '@nestjs/config';

/**
 * 全局异常过滤器
 * 统一处理所有异常并返回标准格式
 */
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(GlobalExceptionFilter.name);

  constructor(private readonly configService: ConfigService) {}

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // 获取请求ID
    const requestId = request.headers['x-request-id'] as string || this.generateRequestId();

    // 处理异常
    const errorResponse = this.handleException(exception, request);

    // 记录日志
    this.logError(exception, request, requestId);

    // 返回响应
    response.status(errorResponse.statusCode).json({
      ...errorResponse.body,
      requestId,
      path: request.url,
      method: request.method,
      timestamp: Date.now()
    });
  }

  /**
   * 处理异常并返回标准响应
   * @private
   */
  private handleException(exception: unknown, request: Request) {
    // 基础响应体
    const baseResponse = {
      code: 'INTERNAL_ERROR',
      message: '服务器内部错误',
      statusCode: HttpStatus.INTERNAL_SERVER_ERROR
    };

    // 处理自定义异常
    if (exception instanceof BaseException) {
      return {
        body: exception.toJSON(),
        statusCode: exception.statusCode
      };
    }

    // 处理HTTP异常
    if (exception instanceof HttpException) {
      const status = exception.getStatus();
      const exceptionResponse = exception.getResponse();

      if (typeof exceptionResponse === 'string') {
        return {
          body: {
            code: this.getErrorCodeFromStatus(status),
            message: exceptionResponse
          },
          statusCode: status
        };
      }

      return {
        body: exceptionResponse as any,
        statusCode: status
      };
    }

    // 处理未知错误
    return baseResponse;
  }

  /**
   * 记录错误日志
   * @private
   */
  private logError(exception: unknown, request: Request, requestId: string): void {
    const isDevelopment = this.configService.get('NODE_ENV') === 'development';

    const logData = {
      requestId,
      method: request.method,
      url: request.url,
      userAgent: request.headers['user-agent'],
      ip: request.ip,
      exception: exception instanceof Error ? {
        name: exception.name,
        message: exception.message,
        stack: isDevelopment ? exception.stack : undefined
      } : exception
    };

    // 根据异常类型选择日志级别
    if (exception instanceof BaseException) {
      if (exception.statusCode >= 500) {
        this.logger.error(JSON.stringify(logData));
      } else {
        this.logger.warn(JSON.stringify(logData));
      }
    } else {
      this.logger.error(JSON.stringify(logData));
    }
  }

  /**
   * 根据HTTP状态码生成错误码
   * @private
   */
  private getErrorCodeFromStatus(status: number): string {
    const errorCodes: Record<number, string> = {
      400: 'BAD_REQUEST',
      401: 'UNAUTHORIZED',
      403: 'FORBIDDEN',
      404: 'NOT_FOUND',
      409: 'CONFLICT',
      422: 'UNPROCESSABLE_ENTITY',
      429: 'TOO_MANY_REQUESTS',
      500: 'INTERNAL_SERVER_ERROR',
      502: 'BAD_GATEWAY',
      503: 'SERVICE_UNAVAILABLE'
    };

    return errorCodes[status] || 'UNKNOWN_ERROR';
  }

  /**
   * 生成请求ID
   * @private
   */
  private generateRequestId(): string {
    return `${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
  }
}
```

#### 3.6 前端错误处理

```typescript
// src/shared/error/handler.ts
/**
 * 错误类型
 */
export enum ErrorType {
  NETWORK = 'NETWORK',
  VALIDATION = 'VALIDATION',
  AUTH = 'AUTH',
  PERMISSION = 'PERMISSION',
  BUSINESS = 'BUSINESS',
  UNKNOWN = 'UNKNOWN'
}

/**
 * API错误响应
 */
export interface ApiError {
  code: string;
  message: string;
  details?: any;
  requestId?: string;
}

/**
 * 错误处理类
 */
export class ErrorHandler {
  /**
   * 处理API错误
   */
  static handleApiError(error: any): { type: ErrorType; message: string } {
    // 网络错误
    if (!error.response) {
      return {
        type: ErrorType.NETWORK,
        message: '网络连接失败，请检查网络设置'
      };
    }

    const { status, data } = error.response;

    // 401 未认证
    if (status === 401) {
      // 清除token并跳转登录
      localStorage.removeItem('access_token');
      window.location.href = '/login';

      return {
        type: ErrorType.AUTH,
        message: data.message || '登录已过期，请重新登录'
      };
    }

    // 403 权限不足
    if (status === 403) {
      return {
        type: ErrorType.PERMISSION,
        message: data.message || '您没有权限执行此操作'
      };
    }

    // 422 校验错误
    if (status === 422) {
      return {
        type: ErrorType.VALIDATION,
        message: data.message || '数据校验失败',
        details: data.details
      };
    }

    // 429 请求过于频繁
    if (status === 429) {
      return {
        type: ErrorType.BUSINESS,
        message: data.message || '请求过于频繁，请稍后再试'
      };
    }

    // 500 服务器错误
    if (status >= 500) {
      return {
        type: ErrorType.UNKNOWN,
        message: data.message || '服务器错误，请稍后重试'
      };
    }

    // 其他错误
    return {
      type: ErrorType.BUSINESS,
      message: data.message || '请求失败，请稍后重试'
    };
  }

  /**
   * 显示错误提示
   */
  static showError(error: any): void {
    const { type, message } = this.handleApiError(error);

    // 根据错误类型选择不同的提示方式
    switch (type) {
      case ErrorType.AUTH:
        // 跳转到登录页，不显示提示
        break;
      case ErrorType.VALIDATION:
        // 显示表单错误
        console.warn('表单校验错误:', error);
        break;
      default:
        // 使用Toast显示错误
        // showToast({ type: 'error', message });
        console.error('操作失败:', message);
    }
  }

  /**
   * 上报错误到监控系统
   */
  static reportError(error: any, context?: Record<string, any>): void {
    // TODO: 集成错误监控系统（如Sentry）
    const errorInfo = {
      message: error.message || String(error),
      stack: error.stack,
      context,
      userAgent: navigator.userAgent,
      url: window.location.href,
      timestamp: new Date().toISOString()
    };

    console.error('[Error Report]', errorInfo);
  }
}
```

#### 3.7 异常重试机制

```typescript
// src/shared/utils/retry.ts
/**
 * 重试配置
 */
export interface RetryConfig {
  /** 最大重试次数 */
  maxRetries?: number;
  /** 重试延迟（毫秒） */
  delay?: number;
  /** 延迟倍数（指数退避） */
  backoffMultiplier?: number;
  /** 最大延迟（毫秒） */
  maxDelay?: number;
  /** 是否应该重试的判断函数 */
  shouldRetry?: (error: any) => boolean;
}

/**
 * 带重试的异步函数执行
 */
export async function withRetry<T>(
  fn: () => Promise<T>,
  config: RetryConfig = {}
): Promise<T> {
  const {
    maxRetries = 3,
    delay = 1000,
    backoffMultiplier = 2,
    maxDelay = 10000,
    shouldRetry = defaultShouldRetry
  } = config;

  let lastError: any;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;

      // 最后一次尝试或不应重试，直接抛出错误
      if (attempt === maxRetries || !shouldRetry(error)) {
        throw error;
      }

      // 计算延迟时间（指数退避）
      const currentDelay = Math.min(
        delay * Math.pow(backoffMultiplier, attempt),
        maxDelay
      );

      console.warn(`操作失败，${currentDelay}ms 后重试 (${attempt + 1}/${maxRetries})`);

      await sleep(currentDelay);
    }
  }

  throw lastError;
}

/**
 * 默认重试判断
 * 网络错误、5xx错误重试
 */
function defaultShouldRetry(error: any): boolean {
  // 网络错误
  if (!error.response) return true;

  // 5xx 服务器错误
  const status = error.response?.status;
  return status >= 500 && status < 600;
}

/**
 * 延迟函数
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

### 4. 附录

#### 4.1 HTTP状态码使用规范

| 状态码 | 使用场景 | 对应异常类 |
|--------|----------|-----------|
| 200 | 请求成功 | - |
| 201 | 创建成功 | - |
| 204 | 删除成功 | - |
| 400 | 参数错误 | ValidationException |
| 401 | 未认证 | UnauthorizedException |
| 403 | 无权限 | ForbiddenException |
| 404 | 资源不存在 | NotFoundException |
| 409 | 资源冲突 | ConflictException |
| 422 | 业务校验失败 | BusinessException |
| 429 | 请求频率限制 | RateLimitException |
| 500 | 服务器错误 | DatabaseException等 |
| 502 | 网关错误 | NetworkException |
| 503 | 服务不可用 | ExternalServiceException |

#### 4.2 错误码命名规范

| 前缀 | 说明 | 示例 |
|------|------|------|
| AUTH_ | 认证相关 | AUTH_INVALID_TOKEN |
| PERM_ | 权限相关 | PERM_INSUFFICIENT |
| VALID_ | 校验相关 | VALID_EMAIL_FORMAT |
| NOT_FOUND_ | 资源不存在 | NOT_FOUND_USER |
| CONFLICT_ | 资源冲突 | CONFLICT_EMAIL_EXISTS |
| BUSINESS_ | 业务逻辑 | BUSINESS_INSUFFICIENT_STOCK |
| PAYMENT_ | 支付相关 | PAYMENT_AMOUNT_MISMATCH |
| NETWORK_ | 网络相关 | NETWORK_TIMEOUT |
| DATABASE_ | 数据库相关 | DATABASE_CONNECTION_FAILED |
| EXTERNAL_ | 外部服务 | EXTERNAL_AI_SERVICE_DOWN |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
