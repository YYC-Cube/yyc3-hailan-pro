---
@file: 046-后端微服务模块代码设计.md
@description: HaiLan Pro 后端微服务模块的代码结构、接口实现、业务逻辑的规范设计
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-详细设计],[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 046 后端微服务模块代码设计

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-详细设计-后端微服务模块代码设计相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范后端微服务模块代码设计相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 后端微服务模块代码设计

#### 3.1 微服务架构设计

##### 3.1.1 服务划分

```typescript
// 微服务架构定义
interface MicroservicesArchitecture {
  // 网关服务
  gateway: {
    name: 'hailan-gateway';
    port: 3000;
    framework: 'NestJS + @nestjs/microservices';
    responsibilities: [
      '请求路由',
      '负载均衡',
      '限流控制',
      '统一鉴权',
      'API版本管理',
      '请求/响应日志'
    ];
  };

  // 用户服务
  userService: {
    name: 'hailan-user-service';
    port: 3001;
    database: 'PostgreSQL';
    cache: 'Redis';
    features: [
      '用户注册/登录',
      '用户信息管理',
      '实名认证',
      '生物识别',
      '权限管理',
      '设备管理'
    ];
  };

  // 商城服务
  mallService: {
    name: 'hailan-mall-service';
    port: 3002;
    database: 'PostgreSQL + MongoDB';
    cache: 'Redis';
    features: [
      '商品管理',
      '分类管理',
      '购物车',
      '订单管理',
      '支付集成',
      '智能推荐'
    ];
  };

  // 隐私服务
  privacyService: {
    name: 'hailan-privacy-service';
    port: 3003;
    database: 'PostgreSQL';
    cache: 'Redis';
    features: [
      '数据加密/解密',
      '数据脱敏',
      '隐私模式管理',
      '应用伪装',
      '数据清理'
    ];
  };

  // AI服务
  aiService: {
    name: 'hailan-ai-service';
    port: 3004;
    database: 'MongoDB + Chroma';
    cache: 'Redis';
    features: [
      'AI对话',
      '智能推荐',
      '知识问答',
      '情感分析'
    ];
  };

  // IoT服务
  iotService: {
    name: 'hailan-iot-service';
    port: 3005;
    database: 'MongoDB + TimescaleDB';
    cache: 'Redis';
    features: [
      '设备管理',
      '设备控制',
      '数据采集',
      '固件升级',
      '数据同步'
    ];
  };
}
```

##### 3.1.2 服务通信架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        API Gateway                              │
│                    (hailan-gateway:3000)                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ 负载均衡     │  │ 限流控制     │  │ 统一鉴权     │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Service Mesh (可选)                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ 服务发现     │  │ 熔断降级     │  │ 链路追踪     │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
└─────────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        ▼                     ▼                     ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│ User Service  │   │ Mall Service  │   │Privacy Service│
│  (port:3001)  │   │  (port:3002)  │   │  (port:3003)  │
├───────────────┤   ├───────────────┤   ├───────────────┤
│- 用户管理     │   │- 商品管理     │   │- 数据加密     │
│- 认证授权     │   │- 订单管理     │   │- 隐私模式     │
│- 权限控制     │   │- 购物车       │   │- 数据脱敏     │
└───────────────┘   └───────────────┘   └───────────────┘
        │                     │                     │
        ▼                     ▼                     ▼
┌───────────────┐   ┌───────────────┐   ┌───────────────┐
│   AI Service  │   │  IoT Service  │   │   PostgreSQL  │
│  (port:3004)  │   │  (port:3005)  │   │   MongoDB     │
├───────────────┤   ├───────────────┤   │    Redis      │
│- AI对话       │   │- 设备管理     │   │  RabbitMQ     │
│- 智能推荐     │   │- 设备控制     │   │               │
│- 知识问答     │   │- 数据采集     │   │               │
└───────────────┘   └───────────────┘   └───────────────┘
```

#### 3.2 项目目录结构

##### 3.2.1 单体服务目录结构

```typescript
// NestJS微服务目录结构
interface NestJSServiceStructure {
  // 根目录
  root: {
    files: [
      'main.ts',              // 应用入口
      'app.module.ts',        // 根模块
      'app.controller.ts',    // 根控制器
      'app.service.ts',       // 根服务
      '.env',                 // 环境变量
      'nest-cli.json'         // CLI配置
    ];
  };

  // src目录结构
  src: {
    // 模块目录
    modules: {
      user: '用户模块',
      mall: '商城模块',
      privacy: '隐私模块',
      ai: 'AI模块',
      iot: 'IoT模块'
    };

    // 公共目录
    common: {
      decorators: '装饰器',
      dto: '数据传输对象',
      entities: '实体定义',
      exceptions: '异常处理',
      filters: '异常过滤器',
      guards: '守卫',
      interceptors: '拦截器',
      middlewares: '中间件',
      pipes: '管道',
      interfaces: '接口定义'
    };

    // 配置目录
    config: {
      env: '环境配置',
      database: '数据库配置',
      redis: 'Redis配置',
      jwt: 'JWT配置'
    };

    // 工具目录
    utils: {
      logger: '日志工具',
      encryption: '加密工具',
      validation: '验证工具',
      format: '格式化工具'
    };
  };
}
```

##### 3.2.2 完整目录树

```
src/
├── main.ts                   # 应用入口
├── app.module.ts             # 根模块
├── main.hmr.ts               # HMR热更新
│
├── modules/                  # 业务模块
│   ├── user/                 # 用户模块
│   │   ├── user.module.ts    # 模块定义
│   │   ├── user.controller.ts
│   │   ├── user.service.ts
│   │   ├── user.resolver.ts  # GraphQL Resolver
│   │   ├── dto/              # 数据传输对象
│   │   │   ├── register.dto.ts
│   │   │   ├── login.dto.ts
│   │   │   └── update-user.dto.ts
│   │   ├── entities/         # 实体
│   │   │   └── user.entity.ts
│   │   └── repositories/     # 数据访问
│   │       └── user.repository.ts
│   │
│   ├── mall/                 # 商城模块
│   │   ├── mall.module.ts
│   │   ├── controllers/      # 控制器
│   │   │   ├── product.controller.ts
│   │   │   ├── order.controller.ts
│   │   │   └── cart.controller.ts
│   │   ├── services/         # 服务
│   │   │   ├── product.service.ts
│   │   │   ├── order.service.ts
│   │   │   └── recommendation.service.ts
│   │   ├── dto/
│   │   ├── entities/
│   │   └── repositories/
│   │
│   ├── privacy/              # 隐私模块
│   │   ├── privacy.module.ts
│   │   ├── privacy.service.ts
│   │   ├── encryption.service.ts
│   │   └── dto/
│   │
│   ├── ai/                   # AI模块
│   │   ├── ai.module.ts
│   │   ├── ai.gateway.ts     # 微服务网关
│   │   ├── chat.service.ts
│   │   ├── recommendation.service.ts
│   │   └── dto/
│   │
│   └── iot/                  # IoT模块
│       ├── iot.module.ts
│       ├── iot.gateway.ts
│       ├── device.service.ts
│       ├── data.service.ts
│       └── dto/
│
├── common/                   # 公共模块
│   ├── decorators/           # 装饰器
│   │   ├── current-user.decorator.ts
│   │   └── roles.decorator.ts
│   ├── dto/                  # 通用DTO
│   │   ├── pagination.dto.ts
│   │   └── response.dto.ts
│   ├── entities/             # 基础实体
│   │   └── base.entity.ts
│   ├── exceptions/           # 异常
│   │   └── business.exception.ts
│   ├── filters/              # 异常过滤器
│   │   └── http-exception.filter.ts
│   ├── guards/               # 守卫
│   │   ├── auth.guard.ts
│   │   ├── roles.guard.ts
│   │   └── throttle.guard.ts
│   ├── interceptors/         # 拦截器
│   │   ├── logging.interceptor.ts
│   │   ├── transform.interceptor.ts
│   │   └── cache.interceptor.ts
│   ├── middlewares/          # 中间件
│   │   └── logger.middleware.ts
│   ├── pipes/                # 管道
│   │   └── validation.pipe.ts
│   └── interfaces/           # 接口
│       └──
│
├── config/                   # 配置
│   ├── env.config.ts         # 环境配置
│   ├── database.config.ts    # 数据库配置
│   ├── redis.config.ts       # Redis配置
│   └── jwt.config.ts         # JWT配置
│
├── database/                 # 数据库
│   ├── migrations/           # 迁移
│   └── seeds/                # 种子数据
│
└── utils/                    # 工具
    ├── logger.ts             # 日志
    ├── encryption.ts         # 加密
    ├── validation.ts         # 验证
    └── format.ts             # 格式化
```

#### 3.3 用户服务实现

##### 3.3.1 用户模块代码

```typescript
// modules/user/user.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { UserController } from './user.controller';
import { UserService } from './user.service';
import { UserRepository } from './repositories/user.repository';
import { UserEntity } from './entities/user.entity';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';
import { MailService } from '../mail/mail.service';

@Module({
  imports: [
    TypeOrmModule.forFeature([UserEntity]),
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get('JWT_EXPIRES_IN', '2h')
        }
      }),
      inject: [ConfigService]
    })
  ],
  controllers: [UserController],
  providers: [
    UserService,
    UserRepository,
    JwtStrategy,
    LocalStrategy,
    MailService
  ],
  exports: [UserService, UserRepository]
})
export class UserModule {}

// modules/user/user.service.ts
import { Injectable, BadRequestException, UnauthorizedException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import * as bcrypt from 'bcrypt';
import { UserEntity } from './entities/user.entity';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { MailService } from '../mail/mail.service';

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(UserEntity)
    private readonly userRepository: Repository<UserEntity>,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly mailService: MailService
  ) {}

  /**
   * 用户注册
   */
  async register(registerDto: RegisterDto): Promise<AuthResponse> {
    const { phone, email, password, code } = registerDto;

    // 1. 验证验证码
    await this.verifyCode(phone || email, code);

    // 2. 检查用户是否存在
    const existingUser = await this.userRepository.findOne({
      where: [
        { phone: this.hashPhone(phone) },
        { email: this.hashEmail(email) }
      ]
    });

    if (existingUser) {
      throw new BadRequestException('用户已存在');
    }

    // 3. 创建用户
    const user = this.userRepository.create({
      userId: this.generateUserId(),
      userNo: this.generateUserNo(),
      phone: phone ? this.encrypt(phone) : null,
      phoneHash: phone ? this.hashPhone(phone) : null,
      email: email ? this.encrypt(email) : null,
      emailHash: email ? this.hashEmail(email) : null,
      passwordHash: await this.hashPassword(password),
      salt: bcrypt.genSaltSync(10),
      status: 'active',
      privacyLevel: 'standard'
    });

    await this.userRepository.save(user);

    // 4. 生成Token
    const tokens = await this.generateTokens(user);

    // 5. 发送欢迎邮件
    if (email) {
      await this.mailService.sendWelcomeEmail(email);
    }

    return {
      success: true,
      userId: user.userId,
      token: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresIn: this.configService.get('JWT_EXPIRES_IN', 7200),
      user: this.toUserProfile(user)
    };
  }

  /**
   * 用户登录
   */
  async login(loginDto: LoginDto): Promise<AuthResponse> {
    const { type, phone, email, password, code } = loginDto;

    let user: UserEntity;

    if (type === 'phone' || type === 'email') {
      // 密码登录
      if (!password) {
        throw new BadRequestException('请输入密码');
      }

      user = await this.userRepository.findOne({
        where: phone
          ? { phoneHash: this.hashPhone(phone) }
          : { emailHash: this.hashEmail(email) }
      });

      if (!user) {
        throw new UnauthorizedException('用户不存在');
      }

      const isValid = await this.validatePassword(password, user.passwordHash, user.salt);
      if (!isValid) {
        throw new UnauthorizedException('密码错误');
      }
    } else if (type === 'code') {
      // 验证码登录
      await this.verifyCode(phone || email, code);

      user = await this.userRepository.findOne({
        where: phone
          ? { phoneHash: this.hashPhone(phone) }
          : { emailHash: this.hashEmail(email) }
      });

      if (!user) {
        // 自动注册
        return this.register({
          phone,
          email,
          code,
          password: this.generateRandomPassword()
        });
      }
    } else {
      throw new BadRequestException('登录类型不支持');
    }

    // 更新最后登录时间
    user.lastLoginAt = new Date();
    await this.userRepository.save(user);

    // 生成Token
    const tokens = await this.generateTokens(user);

    return {
      success: true,
      userId: user.userId,
      token: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresIn: this.configService.get('JWT_EXPIRES_IN', 7200),
      user: this.toUserProfile(user)
    };
  }

  /**
   * 获取用户信息
   */
  async getUserProfile(userId: string): Promise<UserProfile> {
    const user = await this.userRepository.findOne({
      where: { userId }
    });

    if (!user) {
      throw new BadRequestException('用户不存在');
    }

    return this.toUserProfile(user);
  }

  /**
   * 更新用户信息
   */
  async updateProfile(userId: string, updateDto: UpdateUserDto): Promise<UserProfile> {
    const user = await this.userRepository.findOne({
      where: { userId }
    });

    if (!user) {
      throw new BadRequestException('用户不存在');
    }

    // 更新允许的字段
    if (updateDto.nickname) user.nickname = updateDto.nickname;
    if (updateDto.avatar) user.avatarUrl = updateDto.avatar;
    if (updateDto.gender) user.gender = updateDto.gender;

    await this.userRepository.save(user);

    return this.toUserProfile(user);
  }

  // ========== 私有方法 ==========

  private async generateTokens(user: UserEntity): Promise<TokenPair> {
    const payload = {
      sub: user.userId,
      userNo: user.userNo,
      privacyLevel: user.privacyLevel
    };

    const accessToken = this.jwtService.sign(payload);
    const refreshToken = this.jwtService.sign(payload, {
      expiresIn: this.configService.get('JWT_REFRESH_EXPIRES_IN', '7d')
    });

    // 存储Refresh Token到Redis
    await this.cacheManager.set(
      `refresh_token:${user.userId}`,
      refreshToken,
      { ttl: 604800 } // 7天
    );

    return { accessToken, refreshToken };
  }

  private async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, 10);
  }

  private async validatePassword(
    password: string,
    hash: string,
    salt: string
  ): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  private hashPhone(phone: string): string {
    return crypto.createHash('sha256').update(phone).digest('hex');
  }

  private hashEmail(email: string): string {
    return crypto.createHash('sha256').update(email.toLowerCase()).digest('hex');
  }

  private toUserProfile(user: UserEntity): UserProfile {
    return {
      userId: user.userId,
      userNo: user.userNo,
      nickname: user.nickname,
      avatarUrl: user.avatarUrl,
      phone: user.phone ? this.maskPhone(user.phone) : null,
      email: user.email ? this.maskEmail(user.email) : null,
      gender: user.gender,
      memberLevel: user.memberLevel,
      privacyLevel: user.privacyLevel,
      createdAt: user.createdAt
    };
  }
}
```

##### 3.3.2 用户控制器

```typescript
// modules/user/user.controller.ts
import { Controller, Get, Post, Put, Body, UseGuards, Req } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { ThrottlerGuard } from '@nestjs/throttler';
import { UserService } from './user.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { CurrentUser } from '../common/decorators/current-user.decorator';
import { Roles } from '../common/decorators/roles.decorator';
import { RolesGuard } from '../common/guards/roles.guard';
import { Throttle } from '../common/decorators/throttle.decorator';

@Controller('api/v1/users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  /**
   * 用户注册
   * @POST /api/v1/users/register
   */
  @Post('register')
  @UseGuards(ThrottlerGuard)
  @Throttle(5, 60) // 5次/分钟
  async register(@Body() registerDto: RegisterDto) {
    return this.userService.register(registerDto);
  }

  /**
   * 用户登录
   * @POST /api/v1/users/login
   */
  @Post('login')
  @UseGuards(ThrottlerGuard)
  @Throttle(10, 60) // 10次/分钟
  async login(@Body() loginDto: LoginDto) {
    return this.userService.login(loginDto);
  }

  /**
   * 刷新Token
   * @POST /api/v1/users/refresh
   */
  @Post('refresh')
  async refresh(@Body('refreshToken') refreshToken: string) {
    return this.userService.refreshToken(refreshToken);
  }

  /**
   * 登出
   * @POST /api/v1/users/logout
   */
  @Post('logout')
  @UseGuards(AuthGuard('jwt'))
  async logout(@CurrentUser() user: UserPayload) {
    return this.userService.logout(user.sub);
  }

  /**
   * 获取当前用户信息
   * @GET /api/v1/users/me
   */
  @Get('me')
  @UseGuards(AuthGuard('jwt'))
  async getProfile(@CurrentUser() user: UserPayload) {
    return this.userService.getUserProfile(user.sub);
  }

  /**
   * 更新用户信息
   * @PUT /api/v1/users/me
   */
  @Put('me')
  @UseGuards(AuthGuard('jwt'))
  async updateProfile(
    @CurrentUser() user: UserPayload,
    @Body() updateDto: UpdateUserDto
  ) {
    return this.userService.updateProfile(user.sub, updateDto);
  }

  /**
   * 第三方登录
   * @POST /api/v1/users/oauth/:provider
   */
  @Post('oauth/:provider')
  @UseGuards(ThrottlerGuard)
  async oauthLogin(
    @Param('provider') provider: string,
    @Body('code') code: string
  ) {
    return this.userService.oauthLogin(provider, code);
  }
}
```

#### 3.4 商城服务实现

##### 3.4.1 商品服务代码

```typescript
// modules/mall/services/product.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ConfigService } from '@nestjs/config';
import { ProductEntity } from '../entities/product.entity';
import { CategoryEntity } from '../entities/category.entity';
import { ProductQueryDto } from '../dto/product-query.dto';
import { CreateProductDto } from '../dto/create-product.dto';
import { UpdateProductDto } from '../dto/update-product.dto';
import { CacheService } from '../../cache/cache.service';
import { RecommendationService } from './recommendation.service';

@Injectable()
export class ProductService {
  constructor(
    @InjectRepository(ProductEntity)
    private readonly productRepository: Repository<ProductEntity>,
    @InjectRepository(CategoryEntity)
    private readonly categoryRepository: Repository<CategoryEntity>,
    private readonly configService: ConfigService,
    private readonly cacheService: CacheService,
    private readonly recommendationService: RecommendationService
  ) {}

  /**
   * 获取商品列表
   */
  async getProducts(queryDto: ProductQueryDto): Promise<PageResult<Product>> {
    const {
      page = 1,
      pageSize = 20,
      category,
      scenario,
      keyword,
      sortBy = 'createdAt',
      sortOrder = 'DESC'
    } = queryDto;

    // 构建查询
    const queryBuilder = this.productRepository
      .createQueryBuilder('product')
      .leftJoinAndSelect('product.category', 'category')
      .where('product.status = :status', { status: 'active' });

    // 分类筛选
    if (category) {
      queryBuilder.andWhere('product.categoryId = :categoryId', { categoryId: category });
    }

    // 场景筛选
    if (scenario) {
      queryBuilder.andWhere('category.scenario = :scenario', { scenario });
    }

    // 关键词搜索
    if (keyword) {
      queryBuilder.andWhere(
        '(product.productName LIKE :keyword OR product.description LIKE :keyword)',
        { keyword: `%${keyword}%` }
      );
    }

    // 排序
    queryBuilder.orderBy(`product.${sortBy}`, sortOrder);

    // 分页
    queryBuilder.skip((page - 1) * pageSize).take(pageSize);

    const [items, total] = await queryBuilder.getManyAndCount();

    return {
      items,
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize)
    };
  }

  /**
   * 获取商品详情
   */
  async getProductDetail(productId: string): Promise<ProductDetail> {
    // 尝试从缓存获取
    const cacheKey = `product:${productId}`;
    const cached = await this.cacheService.get<ProductDetail>(cacheKey);
    if (cached) {
      return cached;
    }

    const product = await this.productRepository
      .createQueryBuilder('product')
      .leftJoinAndSelect('product.category', 'category')
      .leftJoinAndSelect('product.specifications', 'specifications')
      .leftJoinAndSelect('product.images', 'images')
      .where('product.productId = :productId', { productId })
      .andWhere('product.status = :status', { status: 'active' })
      .getOne();

    if (!product) {
      throw new NotFoundException('商品不存在');
    }

    const detail: ProductDetail = {
      ...product,
      relatedProducts: await this.getRelatedProducts(product, 4),
      recommendations: await this.recommendationService.getProductRecommendations(productId, 4)
    };

    // 缓存1小时
    await this.cacheService.set(cacheKey, detail, 3600);

    return detail;
  }

  /**
   * 创建商品
   */
  async createProduct(createDto: CreateProductDto): Promise<Product> {
    const category = await this.categoryRepository.findOne({
      where: { categoryId: createDto.categoryId }
    });

    if (!category) {
      throw new NotFoundException('分类不存在');
    }

    const product = this.productRepository.create({
      ...createDto,
      productId: this.generateProductId(),
      productNo: this.generateProductNo(category.categoryCode),
      status: 'draft'
    });

    const saved = await this.productRepository.save(product);

    // 清除相关缓存
    await this.clearProductCache();

    return saved;
  }

  /**
   * 更新商品
   */
  async updateProduct(productId: string, updateDto: UpdateProductDto): Promise<Product> {
    const product = await this.productRepository.findOne({
      where: { productId }
    });

    if (!product) {
      throw new NotFoundException('商品不存在');
    }

    Object.assign(product, updateDto);
    const saved = await this.productRepository.save(product);

    // 清除缓存
    await this.cacheService.del(`product:${productId}`);
    await this.clearProductCache();

    return saved;
  }

  /**
   * 删除商品
   */
  async deleteProduct(productId: string): Promise<void> {
    const product = await this.productRepository.findOne({
      where: { productId }
    });

    if (!product) {
      throw new NotFoundException('商品不存在');
    }

    // 软删除
    product.status = 'inactive';
    await this.productRepository.save(product);

    // 清除缓存
    await this.cacheService.del(`product:${productId}`);
    await this.clearProductCache();
  }

  /**
   * 更新库存
   */
  async updateStock(productId: string, quantity: number): Promise<void> {
    await this.productRepository
      .createQueryBuilder()
      .update(ProductEntity)
      .set({
        stock: () => `stock - ${quantity}`,
        sales: () => `sales + ${quantity}`
      })
      .where('productId = :productId', { productId })
      .andWhere('stock >= :quantity', { quantity })
      .execute();

    // 清除缓存
    await this.cacheService.del(`product:${productId}`);
  }

  // ========== 私有方法 ==========

  private async getRelatedProducts(product: Product, limit: number): Promise<Product[]> {
    return this.productRepository
      .createQueryBuilder('product')
      .where('product.categoryId = :categoryId', { categoryId: product.categoryId })
      .andWhere('product.productId != :productId', { productId: product.productId })
      .andWhere('product.status = :status', { status: 'active' })
      .orderBy('product.sales', 'DESC')
      .limit(limit)
      .getMany();
  }

  private async clearProductCache(): Promise<void> {
    // 清除商品列表缓存
    await this.cacheService.delByPattern('product:list:*');
  }

  private generateProductId(): string {
    return `prod_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateProductNo(categoryCode: string): string {
    const timestamp = Date.now().toString().slice(-8);
    const random = Math.random().toString().slice(-4);
    return `HL${categoryCode}${timestamp}${random}`.toUpperCase();
  }
}
```

#### 3.5 隐私服务实现

##### 3.5.1 加密服务代码

```typescript
// modules/privacy/services/encryption.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as crypto from 'crypto';

@Injectable()
export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyLength = 32;
  private readonly ivLength = 12;
  private readonly authTagLength = 16;
  private readonly masterKey: Buffer;

  constructor(private readonly configService: ConfigService) {
    // 从KMS获取主密钥(生产环境)
    this.masterKey = Buffer.from(
      this.configService.get('ENCRYPTION_MASTER_KEY'),
      'hex'
    );
  }

  /**
   * 加密数据
   */
  async encrypt(data: string, userId?: string): Promise<EncryptedData> {
    // 生成数据加密密钥(DEK)
    const dek = crypto.randomBytes(this.keyLength);

    // 使用主密钥加密DEK
    const encryptedDek = crypto.publicEncrypt(
      this.masterKey,
      dek
    );

    // 生成IV
    const iv = crypto.randomBytes(this.ivLength);

    // 创建加密器
    const cipher = crypto.createCipheriv(this.algorithm, dek, iv);

    // 加密数据
    let ciphertext = cipher.update(data, 'utf8', 'hex');
    ciphertext += cipher.final('hex');

    // 获取认证标签
    const authTag = cipher.getAuthTag();

    return {
      algorithm: this.algorithm,
      iv: iv.toString('hex'),
      ciphertext,
      authTag: authTag.toString('hex'),
      keyId: this.getKeyId(),
      timestamp: Date.now()
    };
  }

  /**
   * 解密数据
   */
  async decrypt(encryptedData: EncryptedData, userId?: string): Promise<string> {
    const { iv, ciphertext, authTag, keyId } = encryptedData;

    // 从KMS获取DEK
    const dek = await this.getDataKey(keyId);

    // 创建解密器
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      dek,
      Buffer.from(iv, 'hex')
    );

    // 设置认证标签
    decipher.setAuthTag(Buffer.from(authTag, 'hex'));

    // 解密数据
    let decrypted = decipher.update(ciphertext, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  /**
   * 批量加密对象字段
   */
  async encryptObject<T extends Record<string, any>>(
    obj: T,
    fields: (keyof T)[],
    userId?: string
  ): Promise<T> {
    const result = { ...obj };

    for (const field of fields) {
      if (result[field]) {
        const encrypted = await this.encrypt(String(result[field]), userId);
        result[field] = JSON.stringify(encrypted) as any;
      }
    }

    return result;
  }

  /**
   * 批量解密对象字段
   */
  async decryptObject<T extends Record<string, any>>(
    obj: T,
    fields: (keyof T)[],
    userId?: string
  ): Promise<T> {
    const result = { ...obj };

    for (const field of fields) {
      if (result[field]) {
        try {
          const encrypted = JSON.parse(String(result[field]));
          result[field] = await this.decrypt(encrypted, userId) as any;
        } catch {
          // 如果解密失败，保持原值
        }
      }
    }

    return result;
  }

  /**
   * 生成哈希值(用于查询)
   */
  hash(data: string): string {
    return crypto
      .createHash('sha256')
      .update(data)
      .digest('hex');
  }

  /**
   * 数据脱敏
   */
  mask(data: string, type: 'phone' | 'email' | 'idcard' | 'name'): string {
    switch (type) {
      case 'phone':
        return data.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
      case 'email':
        return data.replace(/(.{2}).*(@.*)/, '$1***$2');
      case 'idcard':
        return data.replace(/(.{6}).*(.{4})/, '$1********$2');
      case 'name':
        return data.length > 2
          ? data.substring(0, 1) + '*'.repeat(data.length - 2) + data.substring(data.length - 1)
          : data.substring(0, 1) + '*';
      default:
        return data;
    }
  }

  // ========== 私有方法 ==========

  private async getDataKey(keyId: string): Promise<Buffer> {
    // 从KMS获取数据密钥
    // 实际实现应调用KMS API
    return crypto.randomBytes(this.keyLength);
  }

  private getKeyId(): string {
    return `key_${Date.now()}`;
  }
}
```

#### 3.6 公共模块实现

##### 3.6.1 认证守卫

```typescript
// common/guards/auth.guard.ts
import { Injectable, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Reflector } from '@nestjs/core';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    // 检查是否跳过认证
    const isPublic = this.reflector.get<boolean>(
      'isPublic',
      context.getHandler()
    );

    if (isPublic) {
      return true;
    }

    return super.canActivate(context);
  }

  handleRequest(err: any, user: any, info: any) {
    if (err || !user) {
      throw err || new UnauthorizedException('请先登录');
    }
    return user;
  }
}

// common/guards/roles.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.get<string[]>(
      'roles',
      context.getHandler()
    );

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();

    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}
```

##### 3.6.2 响应拦截器

```typescript
// common/interceptors/transform.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  success: boolean;
  code: number;
  message: string;
  data: T;
  timestamp: number;
}

@Injectable()
export class TransformInterceptor<T> implements NestInterceptor<T, Response<T>> {
  intercept(context: ExecutionContext, next: CallHandler): Observable<Response<T>> {
    return next.handle().pipe(
      map(data => ({
        success: true,
        code: 0,
        message: 'success',
        data,
        timestamp: Date.now()
      }))
    );
  }
}
```

##### 3.6.3 全局异常过滤器

```typescript
// common/filters/http-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus
} from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const status = exception.getStatus();
    const exceptionResponse = exception.getResponse();

    const errorResponse = {
      success: false,
      code: status,
      message: exceptionResponse['message'] || exception.message || 'Internal server error',
      error: exceptionResponse['error'] || 'Error',
      timestamp: Date.now()
    };

    // 记录错误日志
    console.error('HTTP Exception:', {
      status,
      error: errorResponse,
      timestamp: new Date().toISOString()
    });

    response.status(status).json(errorResponse);
  }
}

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();

    const status = exception instanceof HttpException
      ? exception.getStatus()
      : HttpStatus.INTERNAL_SERVER_ERROR;

    const errorResponse = {
      success: false,
      code: status,
      message: 'Internal server error',
      error: 'Internal Server Error',
      timestamp: Date.now()
    };

    // 记录错误日志
    console.error('Unhandled Exception:', exception);

    response.status(status).json(errorResponse);
  }
}
```

---

## 附录

### A. 完整API列表

### B. 数据库迁移脚本

### C. Docker部署配置

### D. 术语表

| 术语 | 说明 |
|-----|------|
| **NestJS** | Node.js企业级框架 |
| **Microservices** | 微服务架构 |
| **JWT** | JSON Web Token |
| **TypeORM** | TypeScript ORM框架 |

### E. 修订历史

| 版本 | 日期 | 修订人 | 修订内容 |
|-----|------|-------|---------|
| v1.0.0 | 2026-01-26 | YanYuCloudCube Team | 初始版本创建 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
