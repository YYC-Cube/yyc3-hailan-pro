---
file: 123-集成测试规范.md
description: HaiLan Pro 集成测试规范，包含接口测试、服务集成测试、数据流测试
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-审核测试,[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 123 集成测试规范

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-审核测试-集成测试规范相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范集成测试规范相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 集成测试规范

#### 3.1 测试范围

集成测试主要验证系统各模块之间的接口交互、数据流转和业务协同。涵盖以下测试领域：

```yaml
集成测试范围:
  API接口集成:
    - RESTful API接口测试
    - GraphQL接口测试
    - WebSocket连接测试
    - 第三方服务集成测试

  数据库集成:
    - PostgreSQL数据持久化测试
    - MongoDB文档存储测试
    - Redis缓存同步测试
    - 数据一致性验证

  服务间集成:
    - NestJS微服务通信测试
    - RabbitMQ消息队列测试
    - AI服务集成测试
    - IoT设备集成测试

  前后端集成:
    - Vue3组件与API集成测试
    - PWA Service Worker集成测试
    - 状态管理集成测试
    - 隐私模式集成测试
```

#### 3.2 API接口集成测试

```typescript
// __tests__/integration/auth-api.integration.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'bun:test';
import { NestJSApplication } from '@nestjs/platform-express';
import { Test } from '@nestjs/testing';
import { AppModule } from '@/app.module';

describe('Authentication API Integration', () => {
  let app: NestJSApplication;
  let authToken: string;

  beforeAll(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('POST /api/auth/register', () => {
    it('should register a new user with encrypted data', async () => {
      const response = await fetch('http://localhost:3000/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@hailan.pro',
          password: 'SecurePassword123!',
          privacyLevel: 'STANDARD',
        }),
      });

      const data = await response.json();

      expect(response.status).toBe(201);
      expect(data.userId).toBeDefined();
      expect(data.accessToken).toBeDefined();
      expect(data.privacyLevel).toBe('STANDARD');
    });

    it('should reject duplicate email registration', async () => {
      const response = await fetch('http://localhost:3000/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@hailan.pro',
          password: 'SecurePassword123!',
        }),
      });

      expect(response.status).toBe(409);
      expect(response.statusText).toContain('Conflict');
    });
  });

  describe('POST /api/auth/login', () => {
    it('should authenticate user and return tokens', async () => {
      const response = await fetch('http://localhost:3000/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@hailan.pro',
          password: 'SecurePassword123!',
        }),
      });

      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.accessToken).toBeDefined();
      expect(data.refreshToken).toBeDefined();
      expect(data.user.privacyLevel).toBeDefined();

      authToken = data.accessToken;
    });

    it('should reject invalid credentials', async () => {
      const response = await fetch('http://localhost:3000/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@hailan.pro',
          password: 'WrongPassword',
        }),
      });

      expect(response.status).toBe(401);
    });
  });

  describe('GET /api/auth/verify', () => {
    it('should verify valid JWT token', async () => {
      const response = await fetch('http://localhost:3000/api/auth/verify', {
        headers: {
          'Authorization': `Bearer ${authToken}`,
        },
      });

      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.valid).toBe(true);
      expect(data.userId).toBeDefined();
    });

    it('should reject expired token', async () => {
      const expiredToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.expired';
      const response = await fetch('http://localhost:3000/api/auth/verify', {
        headers: {
          'Authorization': `Bearer ${expiredToken}`,
        },
      });

      expect(response.status).toBe(401);
    });
  });
});
```

#### 3.3 数据库集成测试

```typescript
// __tests__/integration/database.integration.test.ts
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'bun:test';
import { PrismaClient } from '@prisma/client';

describe('Database Integration Tests', () => {
  let prisma: PrismaClient;
  let testUserId: string;

  beforeAll(() => {
    prisma = new PrismaClient({
      datasources: {
        db: {
          url: process.env.TEST_DATABASE_URL,
        },
      },
    });
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  beforeEach(async () => {
    // 清理测试数据
    await prisma.user.deleteMany({
      where: { email: { contains: 'integration-test' } },
    });
  });

  describe('User Data Persistence', () => {
    it('should create and retrieve user with encrypted data', async () => {
      const createdUser = await prisma.user.create({
        data: {
          email: 'integration-test@hailan.pro',
          encryptedPassword: await bcrypt.hash('password123', 10),
          privacyLevel: 'STEALTH',
          profile: {
            create: {
              nickname: 'TestUser',
              avatar: 'https://cdn.hailan.pro/default.png',
            },
          },
        },
        include: { profile: true },
      });

      expect(createdUser.id).toBeDefined();
      expect(createdUser.privacyLevel).toBe('STEALTH');
      expect(createdUser.profile).toBeDefined();

      const retrievedUser = await prisma.user.findUnique({
        where: { id: createdUser.id },
        include: { profile: true },
      });

      expect(retrievedUser).not.toBeNull();
      expect(retrievedUser.email).toBe('integration-test@hailan.pro');
      expect(retrievedUser.privacyLevel).toBe('STEALTH');
    });

    it('should update privacy level and verify data masking', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'privacy-test@hailan.pro',
          encryptedPassword: await bcrypt.hash('password123', 10),
          privacyLevel: 'STANDARD',
          phoneNumber: '+8613800138000',
        },
      });

      // 切换到隐身模式
      const updatedUser = await prisma.user.update({
        where: { id: user.id },
        data: { privacyLevel: 'STEALTH' },
      });

      expect(updatedUser.privacyLevel).toBe('STEALTH');
    });

    it('should maintain referential integrity', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'integrity-test@hailan.pro',
          encryptedPassword: await bcrypt.hash('password123', 10),
          privacyLevel: 'STANDARD',
        },
      });

      const order = await prisma.order.create({
        data: {
          userId: user.id,
          status: 'PENDING',
          totalAmount: 299.00,
          items: {
            create: {
              productId: 'prod-001',
              quantity: 1,
              price: 299.00,
            },
          },
        },
      });

      expect(order.userId).toBe(user.id);

      // 尝试删除用户，应该失败（如果有订单）
      await expect(
        prisma.user.delete({ where: { id: user.id } })
      ).rejects.toThrow();
    });
  });

  describe('MongoDB Document Storage', () => {
    it('should store and retrieve AI conversation history', async () => {
      const conversationId = `conv-${Date.now()}`;
      const conversation = {
        _id: conversationId,
        userId: testUserId,
        messages: [
          {
            role: 'user',
            content: '你好，我想咨询一些健康问题',
            timestamp: new Date(),
          },
          {
            role: 'assistant',
            content: '您好！我是海蓝的健康顾问，请问有什么可以帮您的？',
            timestamp: new Date(),
          },
        ],
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      await mongoClient
        .db('hailan-pro')
        .collection('conversations')
        .insertOne(conversation);

      const retrieved = await mongoClient
        .db('hailan-pro')
        .collection('conversations')
        .findOne({ _id: conversationId });

      expect(retrieved).not.toBeNull();
      expect(retrieved.messages).toHaveLength(2);
    });
  });

  describe('Redis Cache Integration', () => {
    it('should cache user session data', async () => {
      const sessionKey = `session:${testUserId}`;
      const sessionData = {
        userId: testUserId,
        privacyLevel: 'DISGUISE',
        lastActive: new Date().toISOString(),
      };

      await redis.set(sessionKey, JSON.stringify(sessionData), 'EX', 3600);

      const cached = await redis.get(sessionKey);
      expect(cached).not.toBeNull();

      const parsed = JSON.parse(cached as string);
      expect(parsed.userId).toBe(testUserId);
      expect(parsed.privacyLevel).toBe('DISGUISE');
    });

    it('should invalidate cache on privacy level change', async () => {
      const cacheKey = `user:${testUserId}:profile`;
      await redis.set(cacheKey, JSON.stringify({ privacyLevel: 'STANDARD' }));

      // 更新数据库
      await prisma.user.update({
        where: { id: testUserId },
        data: { privacyLevel: 'STEALTH' },
      });

      // 删除缓存
      await redis.del(cacheKey);

      const cached = await redis.get(cacheKey);
      expect(cached).toBeNull();
    });
  });
});
```

#### 3.4 服务间集成测试

```typescript
// __tests__/integration/microservices.integration.test.ts
import { describe, it, expect } from 'bun:test';
import { ClientProxy, ClientProxyFactory, Transport } from '@nestjs/microservices';

describe('Microservices Integration Tests', () => {
  let aiServiceClient: ClientProxy;
  let notificationClient: ClientProxy;

  beforeAll(() => {
    aiServiceClient = ClientProxyFactory.create({
      transport: Transport.RMQ,
      options: {
        urls: [process.env.RABBITMQ_URL || 'amqp://localhost:5672'],
        queue: 'ai_service_queue',
        queueOptions: { durable: false },
      },
    });

    notificationClient = ClientProxyFactory.create({
      transport: Transport.RMQ,
      options: {
        urls: [process.env.RABBITMQ_URL || 'amqp://localhost:5672'],
        queue: 'notification_queue',
        queueOptions: { durable: false },
      },
    });
  });

  describe('AI Service Integration', () => {
    it('should send message to AI service and receive response', async () => {
      const pattern = { cmd: 'ai_chat' };
      const data = {
        userId: 'user-123',
        message: '我最近睡眠质量不太好',
        context: {
          privacyLevel: 'STANDARD',
        },
      };

      const response = await aiServiceClient
        .send(pattern, data)
        .toPromise();

      expect(response).toBeDefined();
      expect(response.reply).toBeDefined();
      expect(response.reply).toContain('睡眠');
    }, 10000);

    it('should handle AI service timeout gracefully', async () => {
      const pattern = { cmd: 'ai_analyze' };
      const data = {
        userId: 'user-456',
        healthData: { /* complex data */ },
      };

      await expect(
        aiServiceClient.send(pattern, data).toPromise()
      ).rejects.toThrow('Timeout');
    }, 5000);
  });

  describe('Notification Service Integration', () => {
    it('should send push notification', async () => {
      const pattern = { cmd: 'send_push' };
      const data = {
        userId: 'user-789',
        title: '订单状态更新',
        body: '您的订单已发货',
        data: { orderId: 'ORD-12345' },
      };

      const response = await notificationClient
        .send(pattern, data)
        .toPromise();

      expect(response.success).toBe(true);
      expect(response.sentAt).toBeDefined();
    });

    it('should respect privacy mode for notifications', async () => {
      const pattern = { cmd: 'send_push' };
      const data = {
        userId: 'user-stealth',
        privacyLevel: 'STEALTH',
        title: '敏感内容通知',
        body: '包含敏感信息',
      };

      const response = await notificationClient
        .send(pattern, data)
        .toPromise();

      expect(response.masked).toBe(true);
      expect(response.content).toContain('***');
    });
  });

  describe('Message Queue Reliability', () => {
    it('should persist messages during service restart', async () => {
      const message = {
        userId: 'user-restart-test',
        event: 'ORDER_CREATED',
        payload: { orderId: 'ORD-99999' },
      };

      // 发送消息到持久化队列
      await aiServiceClient.emit('order_event', message).toPromise();

      // 验证消息已存储
      const queueStats = await aiServiceClient
        .send({ cmd: 'queue_stats' }, {})
        .toPromise();

      expect(queueStats.messageCount).toBeGreaterThan(0);
    });
  });
});
```

#### 3.5 IoT设备集成测试

```typescript
// __tests__/integration/iot.integration.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'bun:test';
import { BluetoothDevice } from '@/services/bluetooth.service';

describe('IoT Device Integration Tests', () => {
  let mockDevice: BluetoothDevice;

  beforeAll(() => {
    // 初始化蓝牙模拟器
    mockDevice = {
      id: 'device-mock-001',
      name: 'HaiLan Smart Device',
      connect: async () => true,
      disconnect: async () => true,
      readCharacteristic: async () => new Uint8Array([0x01, 0x02, 0x03]),
      writeCharacteristic: async (data) => true,
    };
  });

  describe('Bluetooth Device Connection', () => {
    it('should connect to IoT device successfully', async () => {
      const connected = await mockDevice.connect();
      expect(connected).toBe(true);
    });

    it('should read device data', async () => {
      await mockDevice.connect();
      const data = await mockDevice.readCharacteristic();

      expect(data).toBeInstanceOf(Uint8Array);
      expect(data.length).toBeGreaterThan(0);
    });

    it('should write control commands to device', async () => {
      await mockDevice.connect();
      const command = new Uint8Array([0xAA, 0x55, 0x01]);

      const written = await mockDevice.writeCharacteristic(command);
      expect(written).toBe(true);
    });

    it('should handle disconnection gracefully', async () => {
      await mockDevice.connect();
      const disconnected = await mockDevice.disconnect();

      expect(disconnected).toBe(true);
    });
  });

  describe('Device Data Sync', () => {
    it('should sync device data to cloud', async () => {
      const deviceData = {
        deviceId: 'device-001',
        userId: 'user-123',
        timestamp: new Date().toISOString(),
        metrics: {
          battery: 85,
          temperature: 36.5,
          usage: 120, // minutes
        },
      };

      const response = await fetch('http://localhost:3000/api/iot/sync', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authToken}`,
        },
        body: JSON.stringify(deviceData),
      });

      const result = await response.json();
      expect(response.status).toBe(200);
      expect(result.synced).toBe(true);
    });

    it('should respect privacy mode when syncing', async () => {
      const deviceData = {
        deviceId: 'device-001',
        userId: 'user-stealth',
        privacyLevel: 'STEALTH',
        metrics: { /* sensitive data */ },
      };

      const response = await fetch('http://localhost:3000/api/iot/sync', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${stealthAuthToken}`,
        },
        body: JSON.stringify(deviceData),
      });

      expect(response.status).toBe(200);
    });
  });
});
```

#### 3.6 前后端集成测试

```typescript
// __tests__/integration/frontend-backend.integration.test.ts
import { describe, it, expect } from 'bun:test';
import { mount } from '@vue/test-utils';
import { createPinia } from 'pinia';
import PrivacyDashboard from '@/components/PrivacyDashboard.vue';

describe('Frontend-Backend Integration Tests', () => {
  let pinia: any;

  beforeEach(() => {
    pinia = createPinia();
  });

  describe('Privacy Level Switching', () => {
    it('should update privacy level via API and reflect in UI', async () => {
      const wrapper = mount(PrivacyDashboard, {
        global: { plugins: [pinia] },
        props: {
          currentLevel: 'STANDARD',
        },
      });

      // 触发隐私等级切换
      await wrapper.vm.switchPrivacyLevel('STEALTH');

      // 验证API调用
      expect(fetch).toHaveBeenCalledWith(
        '/api/user/privacy-level',
        expect.objectContaining({
          method: 'PATCH',
          body: expect.stringContaining('STEALTH'),
        })
      );

      // 验证UI更新
      expect(wrapper.vm.currentLevel).toBe('STEALTH');
    });
  });

  describe('Real-time Data Updates', () => {
    it('should update order status in real-time via WebSocket', (done) => {
      const wrapper = mount(PrivacyDashboard, {
        global: { plugins: [pinia] },
      });

      // 模拟WebSocket消息
      const mockWs = {
        send: (data: string) => {
          const message = JSON.parse(data);
          expect(message.type).toBe('subscribe');
          expect(message.channel).toBe('order_updates');
        },
      };

      wrapper.vm.connectWebSocket(mockWs);

      // 模拟服务器推送
      setTimeout(() => {
        wrapper.vm.handleWebSocketMessage({
          type: 'order_update',
          data: { orderId: 'ORD-123', status: 'SHIPPED' },
        });

        expect(wrapper.vm.latestOrderStatus).toBe('SHIPPED');
        done();
      }, 100);
    });
  });
});
```

#### 3.7 测试数据管理

```yaml
集成测试数据管理:

  测试数据策略:
    - 使用独立测试数据库
    - 每次测试前清理测试数据
    - 使用事务回滚保证隔离性
    - 使用工厂模式生成测试数据

  Mock服务:
    - Mock外部AI服务
    - Mock支付网关
    - Mock短信/邮件服务
    - MockIoT设备API

  测试配置:
    test_database_url: "postgresql://test:test@localhost:5432/hailan_test"
    test_redis_url: "redis://localhost:6379/1"
    test_mongo_url: "mongodb://localhost:27017/hailan_test"
    test_rabbitmq_url: "amqp://guest:guest@localhost:5672"
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
