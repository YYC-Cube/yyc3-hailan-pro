---
file: 130-安全测试方案.md
description: HaiLan Pro 安全测试方案，包含漏洞扫描、渗透测试、安全审计
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-审核测试,[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 130 安全测试方案

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-审核测试-安全测试方案相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范安全测试方案相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 安全测试方案

#### 3.1 安全测试范围

HaiLan Pro 作为情趣健康管理平台，安全性是核心要求。安全测试覆盖以下领域：

```yaml
安全测试范围:

  认证与授权:
    - JWT令牌安全测试
    - 会话管理安全测试
    - 权限控制测试
    - 多因素认证测试

  数据保护:
    - 敏感数据加密测试
    - 数据脱敏测试
    - 数据传输加密测试
    - 数据存储安全测试

  隐私安全:
    - 隐私等级切换测试
    - 浏览历史清理测试
    - 伪装发货机制测试
    - 虚拟地址测试

  API安全:
    - SQL注入测试
    - XSS攻击测试
    - CSRF攻击测试
    - SSRF攻击测试
    - API限流测试

  业务逻辑安全:
    - 订单篡改测试
    - 支付安全测试
    - 优惠券滥用测试
    - 越权访问测试
```

#### 3.2 认证安全测试

```typescript
// __tests__/security/auth-security.test.ts
import { describe, it, expect } from 'bun:test';
import { AuthService } from '@/services/auth.service';
import { TokenService } from '@/services/token.service';

describe('认证安全测试', () => {
  let authService: AuthService;
  let tokenService: TokenService;

  beforeEach(() => {
    authService = new AuthService();
    tokenService = new TokenService();
  });

  describe('JWT令牌安全', () => {
    it('应该拒绝过期令牌', async () => {
      const expiredToken = tokenService.generateToken({ userId: 'user-123' }, { expiresIn: -1 });

      const result = await authService.validateToken(expiredToken);
      expect(result.valid).toBe(false);
      expect(result.error).toContain('expired');
    });

    it('应该拒绝被篡改的令牌', async () => {
      const validToken = tokenService.generateToken({ userId: 'user-123' });
      const tamperedToken = validToken.slice(0, -10) + 'tampered';

      const result = await authService.validateToken(tamperedToken);
      expect(result.valid).toBe(false);
    });

    it('应该正确刷新令牌', async () => {
      const refreshToken = tokenService.generateRefreshToken({ userId: 'user-123' });
      const newTokens = await authService.refreshTokens(refreshToken);

      expect(newTokens.accessToken).toBeDefined();
      expect(newTokens.refreshToken).toBeDefined();
      expect(newTokens.refreshToken).not.toBe(refreshToken);
    });

    it('应该使旧令牌在刷新后失效', async () => {
      const refreshToken = tokenService.generateRefreshToken({ userId: 'user-123' });

      // 第一次刷新
      await authService.refreshTokens(refreshToken);

      // 尝试再次使用旧refresh token
      const result = await authService.refreshTokens(refreshToken);
      expect(result.valid).toBe(false);
    });

    it('应该限制令牌刷新频率', async () => {
      const refreshToken = tokenService.generateRefreshToken({ userId: 'user-123' });

      // 快速连续刷新
      await authService.refreshTokens(refreshToken);
      const secondRefresh = await authService.refreshTokens(refreshToken);

      expect(secondRefresh.valid).toBe(false);
      expect(secondRefresh.error).toContain('rate limit');
    });
  });

  describe('密码安全', () => {
    it('应该拒绝弱密码', async () => {
      const weakPasswords = [
        '123456',
        'password',
        'abc123',
        'qwerty',
      ];

      for (const password of weakPasswords) {
        const result = await authService.validatePasswordStrength(password);
        expect(result.strong).toBe(false);
        expect(result.reason).toBeDefined();
      }
    });

    it('应该要求密码包含大小写字母、数字和特殊字符', async () => {
      const result = await authService.validatePasswordStrength('SecurePass123!');
      expect(result.strong).toBe(true);
    });

    it('应该正确哈希密码', async () => {
      const plainPassword = 'SecurePass123!';
      const hashed = await authService.hashPassword(plainPassword);

      expect(hashed).not.toBe(plainPassword);
      expect(hashed.length).toBeGreaterThan(50); // bcrypt哈希长度
      expect(hashed).toMatch(/^\$2[aby]\$/); // bcrypt格式
    });

    it('应该验证密码正确性', async () => {
      const plainPassword = 'SecurePass123!';
      const hashed = await authService.hashPassword(plainPassword);

      const isValid = await authService.verifyPassword(plainPassword, hashed);
      expect(isValid).toBe(true);

      const isInvalid = await authService.verifyPassword('WrongPassword', hashed);
      expect(isInvalid).toBe(false);
    });

    it('应该限制登录尝试次数', async () => {
      const email = 'test@hailan.pro';
      const wrongPassword = 'WrongPassword';

      // 多次失败登录
      for (let i = 0; i < 5; i++) {
        await authService.login(email, wrongPassword);
      }

      // 第6次应该被锁定
      const result = await authService.login(email, wrongPassword);
      expect(result.success).toBe(false);
      expect(result.locked).toBe(true);
      expect(result.remainingTime).toBeGreaterThan(0);
    });
  });

  describe('会话安全', () => {
    it('应该检测会话劫持', async () => {
      const session = await authService.createSession('user-123', {
        ip: '192.168.1.1',
        userAgent: 'Mozilla/5.0...',
      });

      // 尝试从不同IP访问
      const hijackedSession = await authService.validateSession(session.id, {
        ip: '10.0.0.1', // 不同IP
        userAgent: 'Mozilla/5.0...',
      });

      expect(hijackedSession.valid).toBe(false);
      expect(hijackedSession.reason).toContain('IP mismatch');
    });

    it('应该自动清理过期会话', async () => {
      // 创建过期会话
      await authService.createSession('user-123', {}, { expiresIn: -1 });

      // 清理过期会话
      await authService.cleanExpiredSessions();

      // 验证已清理
      const sessions = await authService.getActiveSessions('user-123');
      expect(sessions).toHaveLength(0);
    });
  });
});
```

#### 3.3 注入攻击测试

```typescript
// __tests__/security/injection-attacks.test.ts
import { describe, it, expect } from 'bun:test';
import { ProductController } from '@/controllers/product.controller';
import { SearchController } from '@/controllers/search.controller';

describe('注入攻击防护测试', () => {
  describe('SQL注入防护', () => {
    it('应该防御SQL注入攻击', async () => {
      const maliciousInputs = [
        "1' OR '1'='1",
        "1'; DROP TABLE users--",
        "1' UNION SELECT * FROM users--",
        "admin'--",
        "admin'/*",
        "1' AND 1=1--",
      ];

      const productController = new ProductController();

      for (const input of maliciousInputs) {
        const result = await productController.getProductById(input);
        // 应该返回错误或空结果，而不是泄露数据库信息
        expect(result.success).toBe(false);
        expect(result.error).not.toContain('SQL');
        expect(result.error).not.toContain('syntax');
      }
    });

    it('应该防御搜索SQL注入', async () => {
      const searchController = new SearchController();

      const maliciousQuery = "'; DROP TABLE products; --";
      const result = await searchController.searchProducts(maliciousQuery);

      expect(result.success).toBe(true);
      expect(result.data).toBeInstanceOf(Array);
      // 应该没有结果，但不应该报错
    });
  });

  describe('XSS防护', () => {
    it('应该过滤用户输入中的XSS脚本', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        '<svg onload=alert("XSS")>',
        'javascript:alert("XSS")',
        '<iframe src="javascript:alert(XSS)">',
      ];

      for (const payload of xssPayloads) {
        const sanitized = sanitizeHtml(payload);
        expect(sanitized).not.toContain('<script>');
        expect(sanitized).not.toContain('javascript:');
        expect(sanitized).not.toContain('onerror=');
        expect(sanitized).not.toContain('onload=');
      }
    });

    it('应该转义输出内容', async () => {
      const userInput = '<script>alert("XSS")</script>';
      const escaped = escapeHtml(userInput);

      expect(escaped).toBe('&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;');
    });
  });

  describe('CSRF防护', () => {
    it('应该验证CSRF令牌', async () => {
      const csrfToken = generateCSRFToken();

      const result = await submitForm({
        csrfToken,
        formData: { /* 表单数据 */ },
      });

      expect(result.success).toBe(true);
    });

    it('应该拒绝无效的CSRF令牌', async () => {
      const result = await submitForm({
        csrfToken: 'invalid-token',
        formData: { /* 表单数据 */ },
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('CSRF');
    });

    it('应该拒绝缺失的CSRF令牌', async () => {
      const result = await submitForm({
        formData: { /* 表单数据 */ },
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('CSRF token required');
    });
  });

  describe('SSRF防护', () => {
    it('应该阻止内网URL访问', async () => {
      const internalUrls = [
        'http://localhost/admin',
        'http://127.0.0.1/config',
        'http://192.168.1.1/api',
        'http://169.254.169.254/latest/meta-data/', // AWS metadata
        'file:///etc/passwd',
      ];

      for (const url of internalUrls) {
        const result = await fetchExternalResource(url);
        expect(result.success).toBe(false);
        expect(result.error).toContain('forbidden');
      }
    });

    it('应该验证DNS重绑定攻击', async () => {
      // 模拟DNS重绑定：第一次解析为合法IP，第二次解析为内网IP
      const result = await fetchExternalResource('http://malicious.com');

      expect(result.validated).toBe(true);
      expect(result.ip).not.toMatch(/^(127\.|192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[01])\.)/);
    });
  });
});
```

#### 3.4 隐私安全测试

```typescript
// __tests__/security/privacy-security.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { PrivacyService } from '@/services/privacy.service';
import { PrivacyLevel } from '@/types/privacy.types';

describe('隐私安全测试', () => {
  let privacyService: PrivacyService;
  let testUserId: string;

  beforeEach(() => {
    privacyService = new PrivacyService();
    testUserId = 'user-privacy-test';
  });

  describe('隐私等级切换安全', () => {
    it('应该在切换到隐身模式时脱敏数据', async () => {
      await privacyService.setPrivacyLevel(testUserId, PrivacyLevel.STEALTH);

      const userProfile = await privacyService.getUserProfile(testUserId);
      expect(userProfile.email).toMatch(/\*{2,}@.+/); // 邮箱脱敏
      expect(userProfile.phone).toMatch(/\d{3}\*{4}\d{4}/); // 手机脱敏
    });

    it('应该在切换到伪装模式时虚拟化数据', async () => {
      await privacyService.setPrivacyLevel(testUserId, PrivacyLevel.DISGUISE);

      const orderHistory = await privacyService.getOrderHistory(testUserId);
      expect(orderHistory.items[0].productName).not.toBe('真实商品名称');
      expect(orderHistory.items[0].productName).toContain('虚拟');
    });

    it('应该清除浏览历史', async () => {
      // 先添加浏览记录
      await privacyService.recordPageView(testUserId, '/products/prod-001');

      // 切换到隐身模式
      await privacyService.setPrivacyLevel(testUserId, PrivacyLevel.STEALTH);

      // 验证浏览历史已清除
      const history = await privacyService.getBrowsingHistory(testUserId);
      expect(history).toHaveLength(0);
    });

    it('应该记录隐私切换日志', async () => {
      await privacyService.setPrivacyLevel(testUserId, PrivacyLevel.STEALTH);

      const logs = await privacyService.getPrivacyChangeLogs(testUserId);
      expect(logs).toHaveLength(1);
      expect(logs[0].fromLevel).toBe('STANDARD');
      expect(logs[0].toLevel).toBe('STEALTH');
      expect(logs[0].timestamp).toBeDefined();
    });
  });

  describe('数据加密', () => {
    it('应该加密敏感字段', async () => {
      const sensitiveData = {
        userId: testUserId,
        realName: '张三',
        idCard: '110101199001011234',
        phone: '13800138000',
      };

      await privacyService.saveSensitiveData(sensitiveData);

      // 从数据库读取应该是加密的
      const dbRecord = await db.sensitiveData.findUnique({
        where: { userId: testUserId },
      });

      expect(dbRecord.realName).not.toBe('张三');
      expect(dbRecord.idCard).not.toBe('110101199001011234');
      expect(dbRecord.phone).not.toBe('13800138000');
    });

    it('应该正确解密数据', async () => {
      const encrypted = privacyService.encrypt('Sensitive Data');
      const decrypted = privacyService.decrypt(encrypted);

      expect(decrypted).toBe('Sensitive Data');
    });

    it('应该使用不同密钥加密不同用户数据', async () => {
      const data1 = privacyService.encryptUserSpecificData('user-1', 'data');
      const data2 = privacyService.encryptUserSpecificData('user-2', 'data');

      expect(data1).not.toBe(data2);
    });
  });

  describe('伪装发货机制', () => {
    it('应该在伪装模式下生成虚拟发货信息', async () => {
      await privacyService.setPrivacyLevel(testUserId, PrivacyLevel.DISGUISE);

      const order = await createOrder(testUserId, {
        items: [{ productId: 'prod-001', quantity: 1 }],
      });

      const shippingInfo = await privacyService.getShippingInfo(order.id);

      expect(shippingInfo.sender).not.toBe('海蓝官方');
      expect(shippingInfo.packageDescription).toContain('日用品');
      expect(shippingInfo.trackingUrl).not.toContain('hailan');
    });

    it('应该保护真实发货信息不被泄露', async () => {
      await privacyService.setPrivacyLevel(testUserId, PrivacyLevel.DISGUISE);

      const realShippingInfo = await db.shippingInfo.findUnique({
        where: { userId: testUserId },
      });

      const publicInfo = await privacyService.getPublicShippingInfo(testUserId);

      expect(publicInfo).not.toEqual(realShippingInfo);
    });
  });
});
```

#### 3.5 API安全测试

```typescript
// __tests__/security/api-security.test.ts
import { describe, it, expect } from 'bun:test';
import { request } from 'supertest';
import { app } from '@/app';

describe('API安全测试', () => {
  let authToken: string;

  beforeAll(async () => {
    // 获取测试token
    const res = await request(app)
      .post('/api/auth/login')
      .send({ email: 'test@hailan.pro', password: 'password123' });
    authToken = res.body.accessToken;
  });

  describe('认证测试', () => {
    it('应该拒绝未认证的请求', async () => {
      const res = await request(app)
        .get('/api/user/profile');

      expect(res.status).toBe(401);
    });

    it('应该拒绝无效的token', async () => {
      const res = await request(app)
        .get('/api/user/profile')
        .set('Authorization', 'Bearer invalid-token');

      expect(res.status).toBe(401);
    });

    it('应该接受有效的token', async () => {
      const res = await request(app)
        .get('/api/user/profile')
        .set('Authorization', `Bearer ${authToken}`);

      expect(res.status).toBe(200);
    });
  });

  describe('授权测试', () => {
    it('应该拒绝用户访问他人数据', async () => {
      const res = await request(app)
        .get('/api/user/user-999/profile')
        .set('Authorization', `Bearer ${authToken}`);

      expect(res.status).toBe(403);
    });

    it('应该拒绝普通用户访问管理员接口', async () => {
      const res = await request(app)
        .get('/api/admin/users')
        .set('Authorization', `Bearer ${authToken}`);

      expect(res.status).toBe(403);
    });
  });

  describe('输入验证', () => {
    it('应该拒绝无效的邮箱格式', async () => {
      const res = await request(app)
        .post('/api/auth/register')
        .send({
          email: 'invalid-email',
          password: 'SecurePass123!',
        });

      expect(res.status).toBe(400);
      expect(res.body.errors).toContain('email');
    });

    it('应该限制字符串长度', async () => {
      const longString = 'a'.repeat(10000);

      const res = await request(app)
        .post('/api/products')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          name: longString,
        });

      expect(res.status).toBe(400);
    });
  });

  describe('速率限制', () => {
    it('应该限制API请求频率', async () => {
      const requests = [];

      // 快速发送100个请求
      for (let i = 0; i < 100; i++) {
        requests.push(
          request(app)
            .get('/api/products')
            .set('Authorization', `Bearer ${authToken}`)
        );
      }

      const responses = await Promise.all(requests);
      const rateLimited = responses.filter(r => r.status === 429);

      expect(rateLimited.length).toBeGreaterThan(0);
    });
  });

  describe('敏感数据泄露防护', () => {
    it('不应在错误响应中泄露敏感信息', async () => {
      const res = await request(app)
        .get('/api/user/non-existent')
        .set('Authorization', `Bearer ${authToken}`);

      expect(res.status).toBe(404);
      expect(res.body.message).not.toContain('SQL');
      expect(res.body.message).not.toContain('database');
      expect(res.body.stack).toBeUndefined();
    });

    it('不应在响应中返回密码哈希', async () => {
      const res = await request(app)
        .get('/api/user/profile')
        .set('Authorization', `Bearer ${authToken}`);

      expect(res.body.password).toBeUndefined();
      expect(res.body.passwordHash).toBeUndefined();
    });
  });
});
```

#### 3.6 依赖安全扫描

```yaml
依赖安全扫描配置:

  工具:
    - npm audit
    - yarn audit
    - Snyk
    - OWASP Dependency-Check
    - GitHub Dependabot

  扫描策略:
    frequency: "weekly"
    auto_fix: true
    severity_threshold: "high"

  允许的漏洞:
    - devDependencies下的低风险漏洞
    - 无外部攻击面的内部依赖

  禁止的漏洞类型:
    - 远程代码执行(RCE)
    - SQL注入
    - XSS
    - CSRF
    - 敏感信息泄露

  报告要求:
    - 生成扫描报告
    - 自动创建issue
    - 分配给相关负责人
    - 设置修复期限
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
