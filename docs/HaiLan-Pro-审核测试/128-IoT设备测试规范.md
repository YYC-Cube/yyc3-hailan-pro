---
@file: 128-IoT设备测试规范.md
@description: HaiLan Pro 智能硬件设备测试规范，包含连接测试、控制测试、数据同步测试
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-审核测试],[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 128 IoT设备测试规范

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-审核测试-IoT设备测试规范相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范IoT设备测试规范相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. IoT设备测试规范

#### 3.1 设备连接测试

测试智能设备与 PWA 应用的蓝牙连接稳定性与兼容性。

```typescript
// __tests__/iot/bluetooth-connection.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'bun:test';
import { BluetoothService } from '@/services/bluetooth.service';
import { BluetoothDevice } from '@/types/iot.types';

describe('IoT 设备蓝牙连接测试', () => {
  let bluetoothService: BluetoothService;
  let mockDevice: BluetoothDevice;

  beforeEach(() => {
    bluetoothService = new BluetoothService();
    mockDevice = {
      id: 'test-device-001',
      name: 'HaiLan Smart Device Pro',
      services: ['battery_service', 'custom_service'],
      characteristics: {
        battery_level: '00002a19-0000-1000-8000-00805f9b34fb',
        control_command: '0000xxx1-0000-1000-8000-00805f9b34fb',
        data_stream: '0000xxx2-0000-1000-8000-00805f9b34fb',
      },
    };
  });

  afterEach(async () => {
    if (bluetoothService.isConnected) {
      await bluetoothService.disconnect();
    }
  });

  describe('设备发现与配对', () => {
    it('应该发现附近的 HaiLan 设备', async () => {
      const devices = await bluetoothService.scanDevices({
        filters: [
          { services: ['custom_service'] },
          { namePrefix: 'HaiLan' },
        ],
        optionalServices: ['battery_service'],
      });

      expect(devices.length).toBeGreaterThan(0);
      expect(devices[0].name).toContain('HaiLan');
    });

    it('应该成功连接到设备', async () => {
      const connected = await bluetoothService.connect(mockDevice.id);
      expect(connected).toBe(true);
      expect(bluetoothService.isConnected).toBe(true);
    });

    it('应该在连接超时时抛出错误', async () => {
      await expect(
        bluetoothService.connect('invalid-device-id', { timeout: 5000 })
      ).rejects.toThrow('Connection timeout');
    });

    it('应该正确处理设备配对请求', async () => {
      const pairingRequest = await bluetoothService.requestPairing(mockDevice);
      expect(pairingRequest.status).toBe('pending');

      // 模拟用户确认配对
      const pairingResult = await bluetoothService.confirmPairing(mockDevice.id, true);
      expect(pairingResult.paired).toBe(true);
    });
  });

  describe('蓝牙服务发现', () => {
    beforeEach(async () => {
      await bluetoothService.connect(mockDevice.id);
    });

    it('应该发现所有必需的服务', async () => {
      const services = await bluetoothService.getServices();
      expect(services).toContain('battery_service');
      expect(services).toContain('custom_service');
    });

    it('应该读取设备特征值', async () => {
      const characteristics = await bluetoothService.getCharacteristics('custom_service');
      expect(characteristics).toHaveProperty('control_command');
      expect(characteristics).toHaveProperty('data_stream');
    });
  });
});
```

#### 3.2 设备控制测试

```typescript
// __tests__/iot/device-control.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { DeviceController } from '@/services/device-controller.service';
import { CommandType, DeviceMode } from '@/types/iot.types';

describe('IoT 设备控制测试', () => {
  let controller: DeviceController;
  let deviceId: string;

  beforeEach(async () => {
    controller = new DeviceController();
    deviceId = 'test-device-001';
    await controller.connect(deviceId);
  });

  describe('基础控制命令', () => {
    it('应该成功发送开机命令', async () => {
      const result = await controller.sendCommand(deviceId, {
        type: CommandType.POWER_ON,
        parameters: {},
      });

      expect(result.success).toBe(true);
      expect(result.acknowledged).toBe(true);
    });

    it('应该成功设置设备模式', async () => {
      const result = await controller.setDeviceMode(deviceId, DeviceMode.INTENSE);
      expect(result.success).toBe(true);
      expect(result.currentMode).toBe(DeviceMode.INTENSE);
    });

    it('应该成功调节强度等级', async () => {
      const result = await controller.setIntensity(deviceId, 5); // 1-10
      expect(result.success).toBe(true);
      expect(result.currentIntensity).toBe(5);
    });

    it('应该验证强度范围限制', async () => {
      await expect(
        controller.setIntensity(deviceId, 15) // 超出范围
      ).rejects.toThrow('Intensity out of range');
    });
  });

  describe('定时功能测试', () => {
    it('应该设置定时关闭', async () => {
      const result = await controller.setTimer(deviceId, {
        duration: 1800, // 30分钟
        action: 'POWER_OFF',
      });

      expect(result.success).toBe(true);
      expect(result.remainingTime).toBeGreaterThan(0);
    });

    it('应该取消定时器', async () => {
      await controller.setTimer(deviceId, { duration: 1800, action: 'POWER_OFF' });
      const result = await controller.cancelTimer(deviceId);

      expect(result.cancelled).toBe(true);
      expect(result.remainingTime).toBe(0);
    });

    it('应该在定时结束时执行动作', async () => {
      await controller.setTimer(deviceId, {
        duration: 5, // 5秒用于测试
        action: 'POWER_OFF',
      });

      // 等待定时器结束
      await new Promise(resolve => setTimeout(resolve, 6000));

      const status = await controller.getDeviceStatus(deviceId);
      expect(status.poweredOn).toBe(false);
    });
  });

  describe('预设模式测试', () => {
    it('应该应用预设模式', async () => {
      const preset = {
        name: '舒缓模式',
        mode: DeviceMode.GENTLE,
        intensity: 3,
        pattern: 'wave',
        duration: 900,
      };

      const result = await controller.applyPreset(deviceId, preset);
      expect(result.success).toBe(true);
      expect(result.activePreset).toBe('舒缓模式');
    });

    it('应该支持自定义预设', async () => {
      const customPreset = {
        name: '我的模式',
        mode: DeviceMode.PULSE,
        intensity: 7,
        pattern: 'custom',
        customPattern: [1, 3, 5, 7, 5, 3, 1],
      };

      const result = await controller.savePreset(deviceId, customPreset);
      expect(result.saved).toBe(true);
    });
  });
});
```

#### 3.3 数据同步测试

```typescript
// __tests__/iot/data-sync.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { DataSyncService } from '@/services/data-sync.service';
import { DeviceDataType } from '@/types/iot.types';

describe('IoT 数据同步测试', () => {
  let syncService: DataSyncService;
  let deviceId: string;
  let userId: string;

  beforeEach(() => {
    syncService = new DataSyncService();
    deviceId = 'test-device-001';
    userId = 'user-123';
  });

  describe('实时数据同步', () => {
    it('应该接收设备实时数据', async () => {
      const dataStream = syncService.subscribeToDeviceData(deviceId);

      // 模拟设备发送数据
      const mockData = {
        type: DeviceDataType.REALTIME_METRIC,
        timestamp: Date.now(),
        metrics: {
          battery: 85,
          temperature: 36.8,
          runtime: 1200,
        },
      };

      syncService.handleIncomingData(deviceId, mockData);

      const receivedData = await dataStream.next();
      expect(receivedData.value).toEqual(mockData);
    });

    it('应该处理数据同步中断', async () => {
      // 模拟连接中断
      syncService.handleDisconnection(deviceId);

      // 验证缓存未同步数据
      const cachedData = await syncService.getCachedData(deviceId);
      expect(cachedData).toBeDefined();
      expect(cachedData.synced).toBe(false);

      // 模拟重连后同步
      await syncService.syncCachedData(deviceId);
      const syncedData = await syncService.getCachedData(deviceId);
      expect(syncedData.synced).toBe(true);
    });
  });

  describe('使用记录同步', () => {
    it('应该同步设备使用记录', async () => {
      const usageRecord = {
        deviceId,
        userId,
        startTime: new Date(Date.now() - 3600000),
        endTime: new Date(),
        mode: 'GENTLE',
        avgIntensity: 5,
        maxIntensity: 7,
      };

      const result = await syncService.syncUsageRecord(usageRecord);
      expect(result.success).toBe(true);
      expect(result.recordId).toBeDefined();
    });

    it('应该批量同步多条记录', async () => {
      const records = [
        {
          deviceId,
          userId,
          startTime: new Date(Date.now() - 7200000),
          endTime: new Date(Date.now() - 3600000),
          mode: 'INTENSE',
          avgIntensity: 8,
          maxIntensity: 10,
        },
        {
          deviceId,
          userId,
          startTime: new Date(Date.now() - 3600000),
          endTime: new Date(),
          mode: 'GENTLE',
          avgIntensity: 3,
          maxIntensity: 5,
        },
      ];

      const result = await syncService.syncUsageRecordsBatch(records);
      expect(result.success).toBe(true);
      expect(result.syncedCount).toBe(2);
    });
  });

  describe('设备状态同步', () => {
    it('应该同步设备状态到云端', async () => {
      const deviceStatus = {
        deviceId,
        batteryLevel: 75,
        firmwareVersion: '2.1.0',
        lastUsed: new Date(),
        poweredOn: false,
      };

      await syncService.syncDeviceStatus(deviceStatus);

      const syncedStatus = await syncService.getDeviceStatusFromCloud(deviceId);
      expect(syncedStatus.batteryLevel).toBe(75);
      expect(syncedStatus.firmwareVersion).toBe('2.1.0');
    });

    it('应该在隐私模式下脱敏同步数据', async () => {
      const privacyContext = {
        userId: 'user-stealth',
        privacyLevel: 'STEALTH',
      };

      const sensitiveData = {
        deviceId,
        usagePatterns: [/* 详细使用数据 */],
      };

      const result = await syncService.syncWithPrivacy(sensitiveData, privacyContext);
      expect(result.masked).toBe(true);
      expect(result.data.usagePatterns).toBeUndefined();
    });
  });
});
```

#### 3.4 固件更新测试

```typescript
// __tests__/iot/firmware-update.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { FirmwareUpdateService } from '@/services/firmware-update.service';

describe('IoT 固件更新测试', () => {
  let updateService: FirmwareUpdateService;
  let deviceId: string;

  beforeEach(() => {
    updateService = new FirmwareUpdateService();
    deviceId = 'test-device-001';
  });

  describe('版本检查', () => {
    it('应该检测到有新固件版本', async () => {
      const currentVersion = '2.0.0';
      const checkResult = await updateService.checkForUpdates(deviceId, currentVersion);

      expect(checkResult.hasUpdate).toBe(true);
      expect(checkResult.latestVersion).toMatch(/^\d+\.\d+\.\d+$/);
      expect(checkResult.latestVersion).toBeGreaterThan(currentVersion);
    });

    it('应该获取固件更新日志', async () => {
      const changelog = await updateService.getChangelog('2.1.0');

      expect(changelog).toBeDefined();
      expect(changelog.version).toBe('2.1.0');
      expect(changelog.releaseDate).toBeDefined();
      expect(changelog.changes.length).toBeGreaterThan(0);
    });
  });

  describe('固件下载与安装', () => {
    it('应该下载固件更新包', async () => {
      const downloadProgress = [];

      const downloadPromise = updateService.downloadFirmware('2.1.0', {
        onProgress: (progress) => downloadProgress.push(progress),
      });

      await downloadPromise;

      expect(downloadProgress.length).toBeGreaterThan(0);
      expect(downloadProgress[downloadProgress.length - 1].percentage).toBe(100);
    });

    it('应该验证固件包完整性', async () => {
      const firmwarePackage = await updateService.downloadFirmware('2.1.0');
      const isValid = await updateService.verifyFirmware(firmwarePackage);

      expect(isValid).toBe(true);
    });

    it('应该成功安装固件更新', async () => {
      // 进入 DFU 模式
      await updateService.enterDFUMode(deviceId);

      // 传输固件
      const transferResult = await updateService.transferFirmware(deviceId, '2.1.0');
      expect(transferResult.success).toBe(true);
      expect(transferResult.bytesTransferred).toBeGreaterThan(0);

      // 验证更新
      const verifyResult = await updateService.verifyUpdate(deviceId);
      expect(verifyResult.success).toBe(true);
      expect(verifyResult.newVersion).toBe('2.1.0');

      // 重启设备
      await updateService.rebootDevice(deviceId);
    }, 60000); // 固件更新可能需要较长时间
  });

  describe('更新失败恢复', () => {
    it('应该在更新失败时回滚', async () => {
      // 模拟更新中断
      await updateService.enterDFUMode(deviceId);
      await updateService.transferFirmware(deviceId, '2.1.0');

      // 模拟传输中断
      await updateService.simulateTransferFailure();

      // 验证回滚
      const rollbackResult = await updateService.rollbackUpdate(deviceId);
      expect(rollbackResult.success).toBe(true);
      expect(rollbackResult.restoredVersion).toBeDefined();
    });

    it('应该保留旧固件作为备份', async () => {
      const hasBackup = await updateService.hasBackupFirmware(deviceId);
      expect(hasBackup).toBe(true);
    });
  });
});
```

#### 3.5 设备兼容性测试

```typescript
// __tests__/iot/device-compatibility.test.ts
import { describe, it, expect } from 'bun:test';
import { DeviceCompatibilityService } from '@/services/device-compatibility.service';

describe('IoT 设备兼容性测试', () => {
  let compatibilityService: DeviceCompatibilityService;

  const supportedDevices = [
    { model: 'HL-P1', name: '海蓝智能设备 Pro', firmwareRange: ['2.0.0', '3.0.0'] },
    { model: 'HL-S1', name: '海蓝智能设备标准版', firmwareRange: ['1.5.0', '2.5.0'] },
    { model: 'HL-M1', name: '海蓝迷你设备', firmwareRange: ['1.0.0', '2.0.0'] },
  ];

  beforeEach(() => {
    compatibilityService = new DeviceCompatibilityService(supportedDevices);
  });

  describe('设备识别', () => {
    it('应该正确识别支持的设备型号', async () => {
      const deviceInfo = {
        modelName: 'HL-P1',
        firmwareVersion: '2.5.0',
      };

      const isCompatible = await compatibilityService.checkCompatibility(deviceInfo);
      expect(isCompatible.compatible).toBe(true);
      expect(isCompatible.device).toEqual(supportedDevices[0]);
    });

    it('应该拒绝不支持的设备', async () => {
      const deviceInfo = {
        modelName: 'UNKNOWN-DEVICE',
        firmwareVersion: '1.0.0',
      };

      const isCompatible = await compatibilityService.checkCompatibility(deviceInfo);
      expect(isCompatible.compatible).toBe(false);
      expect(isCompatible.reason).toContain('不支持的设备型号');
    });

    it('应该检查固件版本兼容性', async () => {
      const deviceInfo = {
        modelName: 'HL-P1',
        firmwareVersion: '1.0.0', // 低于最低版本
      };

      const isCompatible = await compatibilityService.checkCompatibility(deviceInfo);
      expect(isCompatible.compatible).toBe(false);
      expect(isCompatible.reason).toContain('固件版本过低');
    });
  });

  describe('功能兼容性', () => {
    it('应该根据设备型号启用/禁用功能', async () => {
      const deviceInfo = { modelName: 'HL-M1', firmwareVersion: '1.5.0' };
      const features = await compatibilityService.getAvailableFeatures(deviceInfo);

      // 迷你版可能不支持某些高级功能
      expect(features.supportsTimer).toBe(true);
      expect(features.supportsCustomPattern).toBe(false); // 假设不支持
      expect(features.supportsFirmwareUpdate).toBe(true);
    });

    it('应该提供降级方案', async () => {
      const deviceInfo = { modelName: 'HL-S1', firmwareVersion: '1.5.0' };
      const fallbacks = await compatibilityService.getFallbackOptions(deviceInfo);

      expect(fallbacks.length).toBeGreaterThan(0);
      expect(fallbacks[0].description).toBeDefined();
    });
  });

  describe('浏览器兼容性', () => {
    it('应该检查 Web Bluetooth API 支持', () => {
      const isSupported = compatibilityService.checkWebBluetoothSupport();
      expect(typeof isSupported).toBe('boolean');
    });

    it('应该在不支持时显示替代方案', async () => {
      if (!compatibilityService.checkWebBluetoothSupport()) {
        const alternatives = await compatibilityService.getBluetoothAlternatives();
        expect(alternatives.length).toBeGreaterThan(0);
        expect(alternatives[0].type).toBeDefined();
      }
    });
  });
});
```

#### 3.6 设备安全测试

```typescript
// __tests__/iot/device-security.test.ts
import { describe, it, expect, beforeEach } from 'bun:test';
import { DeviceSecurityService } from '@/services/device-security.service';

describe('IoT 设备安全测试', () => {
  let securityService: DeviceSecurityService;
  let deviceId: string;
  let userId: string;

  beforeEach(() => {
    securityService = new DeviceSecurityService();
    deviceId = 'test-device-001';
    userId = 'user-123';
  });

  describe('设备配对安全', () => {
    it('应该验证设备所有权', async () => {
      const ownership = await securityService.verifyDeviceOwnership(deviceId, userId);
      expect(ownership.verified).toBe(true);
    });

    it('应该拒绝未授权的设备访问', async () => {
      const unauthorizedUserId = 'user-unauthorized';
      const access = await securityService.requestDeviceAccess(deviceId, unauthorizedUserId);

      expect(access.granted).toBe(false);
      expect(access.reason).toContain('未授权');
    });

    it('应该生成安全的配对密钥', async () => {
      const pairingKey = await securityService.generatePairingKey(deviceId, userId);

      expect(pairingKey.key).toBeDefined();
      expect(pairingKey.key.length).toBeGreaterThanOrEqual(32);
      expect(pairingKey.expiresAt).toBeDefined();
    });
  });

  describe('数据传输加密', () => {
    it('应该加密设备传输数据', async () => {
      const plaintext = Buffer.from('Sensitive device data');
      const encrypted = await securityService.encryptDeviceData(deviceId, plaintext);

      expect(encrypted).not.toEqual(plaintext);
      expect(encrypted.length).toBeGreaterThan(0);
    });

    it('应该解密设备数据', async () => {
      const plaintext = Buffer.from('Sensitive device data');
      const encrypted = await securityService.encryptDeviceData(deviceId, plaintext);
      const decrypted = await securityService.decryptDeviceData(deviceId, encrypted);

      expect(decrypted).toEqual(plaintext);
    });

    it('应该验证数据完整性', async () => {
      const data = { timestamp: Date.now(), value: 42 };
      const signature = await securityService.signData(deviceId, data);

      const isValid = await securityService.verifySignature(deviceId, data, signature);
      expect(isValid).toBe(true);
    });
  });

  describe('隐私保护', () => {
    it('应该在隐私模式下过滤敏感数据', async () => {
      const sensitiveData = {
        deviceId,
        usageHistory: [
          { timestamp: Date.now(), mode: 'INTENSE', duration: 1800 },
          { timestamp: Date.now() - 3600000, mode: 'GENTLE', duration: 900 },
        ],
        healthMetrics: { /* 敏感健康数据 */ },
      };

      const filtered = await securityService.filterSensitiveData(
        sensitiveData,
        'STEALTH'
      );

      expect(filtered.usageHistory).toBeUndefined();
      expect(filtered.healthMetrics).toBeUndefined();
      expect(filtered.deviceId).toBeDefined();
    });

    it('应该记录设备访问日志', async () => {
      await securityService.logDeviceAccess(deviceId, userId, {
        action: 'READ_DATA',
        timestamp: new Date(),
      });

      const accessLogs = await securityService.getAccessLogs(deviceId);
      expect(accessLogs.length).toBeGreaterThan(0);
      expect(accessLogs[0].userId).toBe(userId);
    });
  });
});
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
