---
file: 079-第三方-短信邮件服务接口.md
description: HaiLan Pro 对接短信、邮件平台的接口规范与调用实现，包含验证码、通知等
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-API文档,[第三方集成],[短信服务],[邮件服务]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 079 第三方-短信邮件服务接口

## 概述

本文档详细描述HaiLan Pro项目中第三方短信和邮件服务的集成接口规范，包括短信验证码、短信通知、邮件通知等功能的设计与实现，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范第三方短信和邮件服务接口相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保短信邮件服务7x24小时稳定运行，支持多厂商容灾切换
- **高性能**：优化发送效率和响应时间，支持高并发发送
- **高安全性**：保护用户隐私数据，防止短信邮件内容泄露
- **高扩展性**：支持多厂商接入，灵活切换服务提供商
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的接口和消息格式标准
- **规范化**：严格的发送管理和审核规范
- **自动化**：提高发送效率和质量，自动重试机制
- **智能化**：利用智能路由优化发送成功率
- **可视化**：直观的发送监控和统计界面

#### 2.3 五化架构
- **流程化**：标准化的发送流程
- **文档化**：完善的模板和配置文档
- **工具化**：高效的模板管理和测试工具
- **数字化**：数据驱动的发送优化
- **生态化**：开放的第三方服务集成

### 3. 服务架构

#### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        应用层                                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ 用户服务  │  │ 订单服务  │  │ 通知服务  │  │ 安全服务  │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      短信邮件服务层                          │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              短信邮件服务 (MessageService)           │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│  │  │ 短信服务  │  │ 邮件服务  │  │ 模板服务  │          │  │
│  │  └──────────┘  └──────────┘  └──────────┘          │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│  │  │ 限流服务  │  │ 重试服务  │  │ 统计服务  │          │  │
│  │  └──────────┘  └──────────┘  └──────────┘          │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      第三方服务层                            │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ 阿里云短信│  │ 腾讯云短信│  │ SendGrid │  │ AWS SES  │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ 阿里云邮件│  │ 腾讯云邮件│  │ Mailgun  │  │ SMTP    │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据存储层                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ 消息记录  │  │ 模板配置  │  │ 发送统计  │  │ 黑名单   │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
```

#### 3.2 服务组件

##### 3.2.1 短信服务 (SMSService)
- 验证码发送
- 通知短信发送
- 营销短信发送
- 短信状态查询
- 短信模板管理

##### 3.2.2 邮件服务 (EmailService)
- 验证邮件发送
- 通知邮件发送
- 营销邮件发送
- 邮件状态查询
- 邮件模板管理

##### 3.2.3 模板服务 (TemplateService)
- 短信模板管理
- 邮件模板管理
- 模板变量替换
- 模板审核流程
- 模板版本管理

##### 3.2.4 限流服务 (RateLimitService)
- 用户发送限流
- IP发送限流
- 内容限流
- 限流策略配置
- 限流统计

##### 3.2.5 重试服务 (RetryService)
- 失败自动重试
- 重试策略配置
- 重试次数限制
- 重试延迟控制
- 重试结果通知

##### 3.2.6 统计服务 (StatisticsService)
- 发送统计
- 成功率统计
- 成本统计
- 趋势分析
- 报表生成

### 4. 短信服务接口

#### 4.1 发送验证码短信

##### 4.1.1 接口描述
发送短信验证码，用于用户注册、登录、密码重置等场景。

##### 4.1.2 接口定义

```typescript
/**
 * 发送验证码短信请求
 */
interface SendSMSCodeRequest {
  phone: string;
  type: 'REGISTER' | 'LOGIN' | 'RESET_PASSWORD' | 'BIND_PHONE' | 'VERIFY_IDENTITY';
  scene?: string;
  clientId?: string;
}

/**
 * 发送验证码短信响应
 */
interface SendSMSCodeResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    expireTime: number;
    sendInterval: number;
  };
}
```

##### 4.1.3 接口实现

```typescript
/**
 * 发送验证码短信
 * @description 发送短信验证码，包含限流、防刷、模板选择等逻辑
 */
class SMSService {
  private readonly CODE_EXPIRE_TIME = 5 * 60; // 5分钟过期
  private readonly SEND_INTERVAL = 60; // 60秒发送间隔
  private readonly MAX_DAILY_COUNT = 10; // 每天最多发送10次
  
  constructor(
    private smsProvider: SMSProvider,
    private cacheService: CacheService,
    private rateLimitService: RateLimitService,
    private blacklistService: BlacklistService
  ) {}
  
  /**
   * 发送验证码
   */
  async sendCode(request: SendSMSCodeRequest): Promise<SendSMSCodeResponse> {
    // 检查黑名单
    if (await this.blacklistService.isBlacklisted(request.phone)) {
      return {
        success: false,
        code: 'PHONE_BLACKLISTED',
        message: '手机号已被加入黑名单'
      };
    }
    
    // 检查发送间隔
    const lastSendTime = await this.cacheService.get(`sms:last:${request.phone}`);
    if (lastSendTime && Date.now() - parseInt(lastSendTime) < this.SEND_INTERVAL * 1000) {
      return {
        success: false,
        code: 'SEND_TOO_FREQUENT',
        message: '发送过于频繁，请稍后再试'
      };
    }
    
    // 检查每日发送次数
    const dailyCount = await this.cacheService.get(`sms:daily:${request.phone}`);
    if (dailyCount && parseInt(dailyCount) >= this.MAX_DAILY_COUNT) {
      return {
        success: false,
        code: 'DAILY_LIMIT_EXCEEDED',
        message: '今日发送次数已达上限'
      };
    }
    
    // 检查IP限流
    const ipLimit = await this.rateLimitService.checkIPLimit(request.clientId);
    if (!ipLimit) {
      return {
        success: false,
        code: 'IP_LIMIT_EXCEEDED',
        message: 'IP发送次数已达上限'
      };
    }
    
    // 生成验证码
    const code = this.generateCode();
    
    // 选择模板
    const template = await this.selectTemplate(request.type, request.scene);
    
    // 发送短信
    const result = await this.smsProvider.send({
      phone: request.phone,
      template: template.id,
      params: {
        code: code,
        expire: this.CODE_EXPIRE_TIME / 60
      }
    });
    
    if (result.success) {
      // 保存验证码
      await this.cacheService.set(
        `sms:code:${request.phone}:${request.type}`,
        code,
        this.CODE_EXPIRE_TIME
      );
      
      // 更新发送时间
      await this.cacheService.set(`sms:last:${request.phone}`, Date.now().toString(), this.SEND_INTERVAL);
      
      // 更新每日计数
      const newCount = (dailyCount ? parseInt(dailyCount) : 0) + 1;
      await this.cacheService.set(`sms:daily:${request.phone}`, newCount.toString(), 24 * 60 * 60);
      
      return {
        success: true,
        code: 'SUCCESS',
        message: '验证码发送成功',
        data: {
          expireTime: this.CODE_EXPIRE_TIME,
          sendInterval: this.SEND_INTERVAL
        }
      };
    } else {
      return {
        success: false,
        code: result.errorCode,
        message: result.errorMessage || '验证码发送失败'
      };
    }
  }
  
  /**
   * 生成验证码
   */
  private generateCode(): string {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }
  
  /**
   * 选择模板
   */
  private async selectTemplate(type: string, scene?: string): Promise<SMSCodeTemplate> {
    const templates = await this.getTemplatesByType(type);
    
    if (templates.length === 0) {
      throw new Error('未找到可用模板');
    }
    
    if (scene) {
      const sceneTemplate = templates.find(t => t.scene === scene);
      if (sceneTemplate) {
        return sceneTemplate;
      }
    }
    
    return templates[0];
  }
}
```

#### 4.2 验证验证码

##### 4.2.1 接口描述
验证用户输入的短信验证码是否正确。

##### 4.2.2 接口定义

```typescript
/**
 * 验证验证码请求
 */
interface VerifySMSCodeRequest {
  phone: string;
  code: string;
  type: 'REGISTER' | 'LOGIN' | 'RESET_PASSWORD' | 'BIND_PHONE' | 'VERIFY_IDENTITY';
}

/**
 * 验证验证码响应
 */
interface VerifySMSCodeResponse {
  success: boolean;
  code: string;
  message: string;
}
```

##### 4.2.3 接口实现

```typescript
/**
 * 验证验证码
 */
async verifyCode(request: VerifySMSCodeRequest): Promise<VerifySMSCodeResponse> {
  const cacheKey = `sms:code:${request.phone}:${request.type}`;
  const savedCode = await this.cacheService.get(cacheKey);
  
  if (!savedCode) {
    return {
      success: false,
      code: 'CODE_EXPIRED',
      message: '验证码已过期'
    };
  }
  
  if (savedCode !== request.code) {
    return {
      success: false,
      code: 'CODE_INVALID',
      message: '验证码错误'
    };
  }
  
  // 验证成功后删除验证码
  await this.cacheService.delete(cacheKey);
  
  return {
    success: true,
    code: 'SUCCESS',
    message: '验证成功'
  };
}
```

#### 4.3 发送通知短信

##### 4.3.1 接口描述
发送通知类短信，包括订单通知、物流通知、活动通知等。

##### 4.3.2 接口定义

```typescript
/**
 * 发送通知短信请求
 */
interface SendSMSNotificationRequest {
  phone: string;
  template: string;
  params: Record<string, any>;
  priority?: 'LOW' | 'NORMAL' | 'HIGH';
  scheduledTime?: Date;
  userId?: string;
}

/**
 * 发送通知短信响应
 */
interface SendSMSNotificationResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    messageId: string;
    status: string;
  };
}
```

##### 4.3.3 接口实现

```typescript
/**
 * 发送通知短信
 */
async sendNotification(request: SendSMSNotificationRequest): Promise<SendSMSNotificationResponse> {
  // 检查黑名单
  if (await this.blacklistService.isBlacklisted(request.phone)) {
    return {
      success: false,
      code: 'PHONE_BLACKLISTED',
      message: '手机号已被加入黑名单'
    };
  }
  
  // 获取模板
  const template = await this.getTemplate(request.template);
  if (!template) {
    return {
      success: false,
      code: 'TEMPLATE_NOT_FOUND',
      message: '模板不存在'
    };
  }
  
  // 替换模板变量
  const content = this.replaceTemplateVariables(template.content, request.params);
  
  // 发送短信
  const result = await this.smsProvider.send({
    phone: request.phone,
    content: content,
    priority: request.priority || 'NORMAL'
  });
  
  if (result.success) {
    // 保存发送记录
    await this.saveMessageRecord({
      messageId: result.messageId,
      phone: request.phone,
      template: request.template,
      content: content,
      type: 'NOTIFICATION',
      status: 'SENT',
      userId: request.userId,
      scheduledTime: request.scheduledTime
    });
    
    return {
      success: true,
      code: 'SUCCESS',
      message: '短信发送成功',
      data: {
        messageId: result.messageId,
        status: 'SENT'
      }
    };
  } else {
    // 保存失败记录
    await this.saveMessageRecord({
      messageId: result.messageId,
      phone: request.phone,
      template: request.template,
      content: content,
      type: 'NOTIFICATION',
      status: 'FAILED',
      error: result.errorMessage,
      userId: request.userId
    });
    
    return {
      success: false,
      code: result.errorCode,
      message: result.errorMessage || '短信发送失败'
    };
  }
}
```

#### 4.4 查询短信状态

##### 4.4.1 接口描述
查询短信的发送状态和回执信息。

##### 4.4.2 接口定义

```typescript
/**
 * 查询短信状态请求
 */
interface QuerySMSStatusRequest {
  messageId: string;
}

/**
 * 查询短信状态响应
 */
interface QuerySMSStatusResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    messageId: string;
    phone: string;
    status: 'SENT' | 'DELIVERED' | 'FAILED' | 'PENDING';
    deliverTime?: Date;
    error?: string;
  };
}
```

##### 4.4.3 接口实现

```typescript
/**
 * 查询短信状态
 */
async queryStatus(request: QuerySMSStatusRequest): Promise<QuerySMSStatusResponse> {
  const record = await this.getMessageRecord(request.messageId);
  
  if (!record) {
    return {
      success: false,
      code: 'MESSAGE_NOT_FOUND',
      message: '消息记录不存在'
    };
  }
  
  // 如果状态为已发送，查询第三方状态
  if (record.status === 'SENT') {
    const status = await this.smsProvider.queryStatus(request.messageId);
    
    if (status) {
      // 更新状态
      await this.updateMessageStatus(request.messageId, status);
      
      return {
        success: true,
        code: 'SUCCESS',
        message: '查询成功',
        data: {
          messageId: record.messageId,
          phone: record.phone,
          status: status.status,
          deliverTime: status.deliverTime,
          error: status.error
        }
      };
    }
  }
  
  return {
    success: true,
    code: 'SUCCESS',
    message: '查询成功',
    data: {
      messageId: record.messageId,
      phone: record.phone,
      status: record.status,
      deliverTime: record.deliverTime,
      error: record.error
    }
  };
}
```

### 5. 邮件服务接口

#### 5.1 发送验证码邮件

##### 5.1.1 接口描述
发送邮件验证码，用于用户注册、登录、密码重置等场景。

##### 5.1.2 接口定义

```typescript
/**
 * 发送验证码邮件请求
 */
interface SendEmailCodeRequest {
  email: string;
  type: 'REGISTER' | 'LOGIN' | 'RESET_PASSWORD' | 'BIND_EMAIL' | 'VERIFY_IDENTITY';
  scene?: string;
  clientId?: string;
}

/**
 * 发送验证码邮件响应
 */
interface SendEmailCodeResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    expireTime: number;
    sendInterval: number;
  };
}
```

##### 5.1.3 接口实现

```typescript
/**
 * 邮件服务
 */
class EmailService {
  private readonly CODE_EXPIRE_TIME = 10 * 60; // 10分钟过期
  private readonly SEND_INTERVAL = 120; // 120秒发送间隔
  private readonly MAX_DAILY_COUNT = 5; // 每天最多发送5次
  
  constructor(
    private emailProvider: EmailProvider,
    private cacheService: CacheService,
    private rateLimitService: RateLimitService,
    private blacklistService: BlacklistService
  ) {}
  
  /**
   * 发送验证码邮件
   */
  async sendCode(request: SendEmailCodeRequest): Promise<SendEmailCodeResponse> {
    // 检查黑名单
    if (await this.blacklistService.isEmailBlacklisted(request.email)) {
      return {
        success: false,
        code: 'EMAIL_BLACKLISTED',
        message: '邮箱已被加入黑名单'
      };
    }
    
    // 检查发送间隔
    const lastSendTime = await this.cacheService.get(`email:last:${request.email}`);
    if (lastSendTime && Date.now() - parseInt(lastSendTime) < this.SEND_INTERVAL * 1000) {
      return {
        success: false,
        code: 'SEND_TOO_FREQUENT',
        message: '发送过于频繁，请稍后再试'
      };
    }
    
    // 检查每日发送次数
    const dailyCount = await this.cacheService.get(`email:daily:${request.email}`);
    if (dailyCount && parseInt(dailyCount) >= this.MAX_DAILY_COUNT) {
      return {
        success: false,
        code: 'DAILY_LIMIT_EXCEEDED',
        message: '今日发送次数已达上限'
      };
    }
    
    // 检查IP限流
    const ipLimit = await this.rateLimitService.checkIPEmailLimit(request.clientId);
    if (!ipLimit) {
      return {
        success: false,
        code: 'IP_LIMIT_EXCEEDED',
        message: 'IP发送次数已达上限'
      };
    }
    
    // 生成验证码
    const code = this.generateCode();
    
    // 选择模板
    const template = await this.selectEmailTemplate(request.type, request.scene);
    
    // 替换模板变量
    const subject = this.replaceTemplateVariables(template.subject, { code: code });
    const content = this.replaceTemplateVariables(template.content, { code: code });
    
    // 发送邮件
    const result = await this.emailProvider.send({
      to: request.email,
      subject: subject,
      content: content,
      type: 'HTML'
    });
    
    if (result.success) {
      // 保存验证码
      await this.cacheService.set(
        `email:code:${request.email}:${request.type}`,
        code,
        this.CODE_EXPIRE_TIME
      );
      
      // 更新发送时间
      await this.cacheService.set(`email:last:${request.email}`, Date.now().toString(), this.SEND_INTERVAL);
      
      // 更新每日计数
      const newCount = (dailyCount ? parseInt(dailyCount) : 0) + 1;
      await this.cacheService.set(`email:daily:${request.email}`, newCount.toString(), 24 * 60 * 60);
      
      return {
        success: true,
        code: 'SUCCESS',
        message: '验证码发送成功',
        data: {
          expireTime: this.CODE_EXPIRE_TIME,
          sendInterval: this.SEND_INTERVAL
        }
      };
    } else {
      return {
        success: false,
        code: result.errorCode,
        message: result.errorMessage || '验证码发送失败'
      };
    }
  }
  
  /**
   * 生成验证码
   */
  private generateCode(): string {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }
}
```

#### 5.2 验证邮件验证码

##### 5.2.1 接口描述
验证用户输入的邮件验证码是否正确。

##### 5.2.2 接口定义

```typescript
/**
 * 验证邮件验证码请求
 */
interface VerifyEmailCodeRequest {
  email: string;
  code: string;
  type: 'REGISTER' | 'LOGIN' | 'RESET_PASSWORD' | 'BIND_EMAIL' | 'VERIFY_IDENTITY';
}

/**
 * 验证邮件验证码响应
 */
interface VerifyEmailCodeResponse {
  success: boolean;
  code: string;
  message: string;
}
```

##### 5.2.3 接口实现

```typescript
/**
 * 验证邮件验证码
 */
async verifyCode(request: VerifyEmailCodeRequest): Promise<VerifyEmailCodeResponse> {
  const cacheKey = `email:code:${request.email}:${request.type}`;
  const savedCode = await this.cacheService.get(cacheKey);
  
  if (!savedCode) {
    return {
      success: false,
      code: 'CODE_EXPIRED',
      message: '验证码已过期'
    };
  }
  
  if (savedCode !== request.code) {
    return {
      success: false,
      code: 'CODE_INVALID',
      message: '验证码错误'
    };
  }
  
  // 验证成功后删除验证码
  await this.cacheService.delete(cacheKey);
  
  return {
    success: true,
    code: 'SUCCESS',
    message: '验证成功'
  };
}
```

#### 5.3 发送通知邮件

##### 5.3.1 接口描述
发送通知类邮件，包括订单通知、活动通知、系统通知等。

##### 5.3.2 接口定义

```typescript
/**
 * 发送通知邮件请求
 */
interface SendEmailNotificationRequest {
  to: string;
  cc?: string[];
  bcc?: string[];
  template: string;
  params: Record<string, any>;
  priority?: 'LOW' | 'NORMAL' | 'HIGH';
  scheduledTime?: Date;
  userId?: string;
}

/**
 * 发送通知邮件响应
 */
interface SendEmailNotificationResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    messageId: string;
    status: string;
  };
}
```

##### 5.3.3 接口实现

```typescript
/**
 * 发送通知邮件
 */
async sendNotification(request: SendEmailNotificationRequest): Promise<SendEmailNotificationResponse> {
  // 检查黑名单
  if (await this.blacklistService.isEmailBlacklisted(request.to)) {
    return {
      success: false,
      code: 'EMAIL_BLACKLISTED',
      message: '邮箱已被加入黑名单'
    };
  }
  
  // 获取模板
  const template = await this.getEmailTemplate(request.template);
  if (!template) {
    return {
      success: false,
      code: 'TEMPLATE_NOT_FOUND',
      message: '模板不存在'
    };
  }
  
  // 替换模板变量
  const subject = this.replaceTemplateVariables(template.subject, request.params);
  const content = this.replaceTemplateVariables(template.content, request.params);
  
  // 发送邮件
  const result = await this.emailProvider.send({
    to: request.to,
    cc: request.cc,
    bcc: request.bcc,
    subject: subject,
    content: content,
    type: 'HTML',
    priority: request.priority || 'NORMAL'
  });
  
  if (result.success) {
    // 保存发送记录
    await this.saveEmailRecord({
      messageId: result.messageId,
      to: request.to,
      cc: request.cc,
      bcc: request.bcc,
      template: request.template,
      subject: subject,
      content: content,
      type: 'NOTIFICATION',
      status: 'SENT',
      userId: request.userId,
      scheduledTime: request.scheduledTime
    });
    
    return {
      success: true,
      code: 'SUCCESS',
      message: '邮件发送成功',
      data: {
        messageId: result.messageId,
        status: 'SENT'
      }
    };
  } else {
    // 保存失败记录
    await this.saveEmailRecord({
      messageId: result.messageId,
      to: request.to,
      cc: request.cc,
      bcc: request.bcc,
      template: request.template,
      subject: subject,
      content: content,
      type: 'NOTIFICATION',
      status: 'FAILED',
      error: result.errorMessage,
      userId: request.userId
    });
    
    return {
      success: false,
      code: result.errorCode,
      message: result.errorMessage || '邮件发送失败'
    };
  }
}
```

#### 5.4 查询邮件状态

##### 5.4.1 接口描述
查询邮件的发送状态和回执信息。

##### 5.4.2 接口定义

```typescript
/**
 * 查询邮件状态请求
 */
interface QueryEmailStatusRequest {
  messageId: string;
}

/**
 * 查询邮件状态响应
 */
interface QueryEmailStatusResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    messageId: string;
    to: string;
    status: 'SENT' | 'DELIVERED' | 'OPENED' | 'FAILED' | 'PENDING';
    deliverTime?: Date;
    openTime?: Date;
    error?: string;
  };
}
```

##### 5.4.3 接口实现

```typescript
/**
 * 查询邮件状态
 */
async queryStatus(request: QueryEmailStatusRequest): Promise<QueryEmailStatusResponse> {
  const record = await this.getEmailRecord(request.messageId);
  
  if (!record) {
    return {
      success: false,
      code: 'MESSAGE_NOT_FOUND',
      message: '消息记录不存在'
    };
  }
  
  // 如果状态为已发送，查询第三方状态
  if (record.status === 'SENT') {
    const status = await this.emailProvider.queryStatus(request.messageId);
    
    if (status) {
      // 更新状态
      await this.updateEmailStatus(request.messageId, status);
      
      return {
        success: true,
        code: 'SUCCESS',
        message: '查询成功',
        data: {
          messageId: record.messageId,
          to: record.to,
          status: status.status,
          deliverTime: status.deliverTime,
          openTime: status.openTime,
          error: status.error
        }
      };
    }
  }
  
  return {
    success: true,
    code: 'SUCCESS',
    message: '查询成功',
    data: {
      messageId: record.messageId,
      to: record.to,
      status: record.status,
      deliverTime: record.deliverTime,
      openTime: record.openTime,
      error: record.error
    }
  };
}
```

### 6. 模板管理接口

#### 6.1 创建短信模板

##### 6.1.1 接口描述
创建新的短信模板。

##### 6.1.2 接口定义

```typescript
/**
 * 创建短信模板请求
 */
interface CreateSMSTemplateRequest {
  name: string;
  type: 'CODE' | 'NOTIFICATION' | 'MARKETING';
  scene?: string;
  content: string;
  variables?: string[];
  description?: string;
}

/**
 * 创建短信模板响应
 */
interface CreateSMSTemplateResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    templateId: string;
    status: 'PENDING' | 'APPROVED' | 'REJECTED';
  };
}
```

##### 6.1.3 接口实现

```typescript
/**
 * 创建短信模板
 */
async createSMSTemplate(request: CreateSMSTemplateRequest): Promise<CreateSMSTemplateResponse> {
  // 验证模板内容
  const validation = this.validateTemplateContent(request.content);
  if (!validation.valid) {
    return {
      success: false,
      code: 'INVALID_TEMPLATE',
      message: validation.message
    };
  }
  
  // 提取模板变量
  const variables = this.extractVariables(request.content);
  
  // 保存模板
  const template = await this.saveTemplate({
    id: generateTemplateId(),
    name: request.name,
    type: request.type,
    scene: request.scene,
    content: request.content,
    variables: variables,
    description: request.description,
    status: 'PENDING',
    createdAt: new Date(),
    createdBy: getCurrentUserId()
  });
  
  // 提交审核
  await this.submitForReview(template.id);
  
  return {
    success: true,
    code: 'SUCCESS',
    message: '模板创建成功，等待审核',
    data: {
      templateId: template.id,
      status: template.status
    }
  };
}
```

#### 6.2 创建邮件模板

##### 6.2.1 接口描述
创建新的邮件模板。

##### 6.2.2 接口定义

```typescript
/**
 * 创建邮件模板请求
 */
interface CreateEmailTemplateRequest {
  name: string;
  type: 'CODE' | 'NOTIFICATION' | 'MARKETING';
  scene?: string;
  subject: string;
  content: string;
  variables?: string[];
  description?: string;
}

/**
 * 创建邮件模板响应
 */
interface CreateEmailTemplateResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    templateId: string;
    status: 'PENDING' | 'APPROVED' | 'REJECTED';
  };
}
```

##### 6.2.3 接口实现

```typescript
/**
 * 创建邮件模板
 */
async createEmailTemplate(request: CreateEmailTemplateRequest): Promise<CreateEmailTemplateResponse> {
  // 验证模板内容
  const validation = this.validateEmailTemplateContent(request.content);
  if (!validation.valid) {
    return {
      success: false,
      code: 'INVALID_TEMPLATE',
      message: validation.message
    };
  }
  
  // 提取模板变量
  const variables = this.extractVariables(request.subject + ' ' + request.content);
  
  // 保存模板
  const template = await this.saveEmailTemplate({
    id: generateTemplateId(),
    name: request.name,
    type: request.type,
    scene: request.scene,
    subject: request.subject,
    content: request.content,
    variables: variables,
    description: request.description,
    status: 'PENDING',
    createdAt: new Date(),
    createdBy: getCurrentUserId()
  });
  
  // 提交审核
  await this.submitForReview(template.id);
  
  return {
    success: true,
    code: 'SUCCESS',
    message: '模板创建成功，等待审核',
    data: {
      templateId: template.id,
      status: template.status
    }
  };
}
```

### 7. 统计分析接口

#### 7.1 获取发送统计

##### 7.1.1 接口描述
获取短信和邮件的发送统计数据。

##### 7.1.2 接口定义

```typescript
/**
 * 获取发送统计请求
 */
interface GetSendStatisticsRequest {
  startDate: Date;
  endDate: Date;
  type?: 'SMS' | 'EMAIL' | 'ALL';
  groupBy?: 'DAY' | 'WEEK' | 'MONTH';
}

/**
 * 获取发送统计响应
 */
interface GetSendStatisticsResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    totalSent: number;
    totalDelivered: number;
    totalFailed: number;
    successRate: number;
    cost: number;
    details: StatisticsDetail[];
  };
}

interface StatisticsDetail {
  date: string;
  sent: number;
  delivered: number;
  failed: number;
  successRate: number;
  cost: number;
}
```

##### 7.1.3 接口实现

```typescript
/**
 * 获取发送统计
 */
async getSendStatistics(request: GetSendStatisticsRequest): Promise<GetSendStatisticsResponse> {
  const type = request.type || 'ALL';
  const groupBy = request.groupBy || 'DAY';
  
  // 查询发送记录
  const records = await this.getMessageRecords({
    startDate: request.startDate,
    endDate: request.endDate,
    type: type
  });
  
  // 统计总数
  const totalSent = records.filter(r => r.status !== 'FAILED').length;
  const totalDelivered = records.filter(r => r.status === 'DELIVERED' || r.status === 'OPENED').length;
  const totalFailed = records.filter(r => r.status === 'FAILED').length;
  const successRate = totalSent > 0 ? (totalDelivered / totalSent) * 100 : 0;
  
  // 计算成本
  const cost = await this.calculateCost(records);
  
  // 按日期分组
  const details = this.groupByDate(records, groupBy);
  
  return {
    success: true,
    code: 'SUCCESS',
    message: '查询成功',
    data: {
      totalSent: totalSent,
      totalDelivered: totalDelivered,
      totalFailed: totalFailed,
      successRate: successRate,
      cost: cost,
      details: details
    }
  };
}
```

### 8. 安全机制

#### 8.1 黑名单管理

##### 8.1.1 接口描述
管理短信和邮件的黑名单。

##### 8.1.2 接口定义

```typescript
/**
 * 添加黑名单请求
 */
interface AddBlacklistRequest {
  type: 'PHONE' | 'EMAIL';
  value: string;
  reason?: string;
  expireAt?: Date;
}

/**
 * 添加黑名单响应
 */
interface AddBlacklistResponse {
  success: boolean;
  code: string;
  message: string;
}
```

##### 8.1.3 接口实现

```typescript
/**
 * 添加黑名单
 */
async addBlacklist(request: AddBlacklistRequest): Promise<AddBlacklistResponse> {
  await this.blacklistService.add({
    type: request.type,
    value: request.value,
    reason: request.reason,
    expireAt: request.expireAt,
    createdAt: new Date(),
    createdBy: getCurrentUserId()
  });
  
  return {
    success: true,
    code: 'SUCCESS',
    message: '添加成功'
  };
}
```

#### 8.2 内容过滤

##### 8.2.1 接口描述
过滤短信和邮件中的敏感内容。

##### 8.2.2 接口实现

```typescript
/**
 * 内容过滤服务
 */
class ContentFilterService {
  private sensitiveWords: string[] = [];
  
  constructor(private wordRepository: WordRepository) {
    this.loadSensitiveWords();
  }
  
  /**
   * 加载敏感词
   */
  private async loadSensitiveWords() {
    this.sensitiveWords = await this.wordRepository.getSensitiveWords();
  }
  
  /**
   * 过滤内容
   */
  filter(content: string): FilterResult {
    let filteredContent = content;
    const foundWords: string[] = [];
    
    for (const word of this.sensitiveWords) {
      const regex = new RegExp(word, 'gi');
      if (regex.test(content)) {
        foundWords.push(word);
        filteredContent = filteredContent.replace(regex, '***');
      }
    }
    
    return {
      originalContent: content,
      filteredContent: filteredContent,
      hasSensitiveWords: foundWords.length > 0,
      sensitiveWords: foundWords
    };
  }
  
  /**
   * 检查是否包含敏感词
   */
  hasSensitiveWords(content: string): boolean {
    for (const word of this.sensitiveWords) {
      if (content.toLowerCase().includes(word.toLowerCase())) {
        return true;
      }
    }
    return false;
  }
}
```

### 9. 重试机制

#### 9.1 自动重试策略

##### 9.1.1 接口实现

```typescript
/**
 * 重试服务
 */
class RetryService {
  private readonly MAX_RETRY_COUNT = 3;
  private readonly RETRY_DELAYS = [1000, 5000, 15000]; // 1秒, 5秒, 15秒
  
  /**
   * 执行重试
   */
  async retry<T>(
    fn: () => Promise<T>,
    options?: {
      maxRetryCount?: number;
      retryDelays?: number[];
      onRetry?: (attempt: number, error: Error) => void;
    }
  ): Promise<T> {
    const maxRetryCount = options?.maxRetryCount || this.MAX_RETRY_COUNT;
    const retryDelays = options?.retryDelays || this.RETRY_DELAYS;
    
    let lastError: Error;
    
    for (let attempt = 0; attempt <= maxRetryCount; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        
        if (attempt < maxRetryCount) {
          const delay = retryDelays[Math.min(attempt, retryDelays.length - 1)];
          
          if (options?.onRetry) {
            options.onRetry(attempt + 1, error);
          }
          
          await this.sleep(delay);
        }
      }
    }
    
    throw lastError;
  }
  
  /**
   * 睡眠
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 10. 监控告警

#### 10.1 发送监控

##### 10.1.1 接口实现

```typescript
/**
 * 监控服务
 */
class MonitorService {
  /**
   * 监控发送成功率
   */
  async monitorSuccessRate(): Promise<void> {
    const now = new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    
    const records = await this.getMessageRecords({
      startDate: oneHourAgo,
      endDate: now
    });
    
    const totalSent = records.length;
    const totalDelivered = records.filter(r => r.status === 'DELIVERED' || r.status === 'OPENED').length;
    const successRate = totalSent > 0 ? (totalDelivered / totalSent) * 100 : 0;
    
    // 如果成功率低于阈值，发送告警
    if (successRate < 90) {
      await this.sendAlert({
        type: 'SUCCESS_RATE_LOW',
        message: `发送成功率过低: ${successRate.toFixed(2)}%`,
        data: {
          totalSent: totalSent,
          totalDelivered: totalDelivered,
          successRate: successRate
        }
      });
    }
  }
  
  /**
   * 监控失败率
   */
  async monitorFailureRate(): Promise<void> {
    const now = new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    
    const records = await this.getMessageRecords({
      startDate: oneHourAgo,
      endDate: now
    });
    
    const totalSent = records.length;
    const totalFailed = records.filter(r => r.status === 'FAILED').length;
    const failureRate = totalSent > 0 ? (totalFailed / totalSent) * 100 : 0;
    
    // 如果失败率高于阈值，发送告警
    if (failureRate > 10) {
      await this.sendAlert({
        type: 'FAILURE_RATE_HIGH',
        message: `失败率过高: ${failureRate.toFixed(2)}%`,
        data: {
          totalSent: totalSent,
          totalFailed: totalFailed,
          failureRate: failureRate
        }
      });
    }
  }
}
```

### 11. 最佳实践

#### 11.1 发送优化

- 使用异步发送，避免阻塞主线程
- 实现批量发送，提高发送效率
- 使用消息队列，削峰填谷
- 实现智能路由，选择最优服务商

#### 11.2 安全建议

- 对敏感内容进行加密
- 实现内容过滤，防止违规内容
- 使用黑名单机制，防止恶意发送
- 记录详细的发送日志，便于审计

#### 11.3 性能优化

- 使用缓存，减少数据库查询
- 实现连接池，提高连接复用
- 使用CDN加速，提高邮件打开速度
- 实现限流机制，防止系统过载

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
