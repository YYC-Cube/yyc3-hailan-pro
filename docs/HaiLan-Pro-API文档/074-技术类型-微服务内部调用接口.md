---
@file: 074-技术类型-微服务内部调用接口.md
@description: HaiLan Pro 微服务之间的内部调用接口规范，包含服务注册、发现、调用规则
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-API文档],[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 074 技术类型-微服务内部调用接口

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-API文档-技术类型-微服务内部调用接口相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范技术类型-微服务内部调用接口相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 技术类型-微服务内部调用接口

#### 3.1 微服务架构概述

##### 3.1.1 服务架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        API Gateway                           │
│                    (Nginx/Kong/APISIX)                      │
└─────────────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────▼──────┐  ┌──────▼──────┐  ┌──────▼──────┐
│  User Service │  │  Order Svc  │  │ Product Svc │
│   (用户服务)   │  │  (订单服务)   │  │  (商品服务)   │
└───────┬──────┘  └──────┬──────┘  └──────┬──────┘
        │                  │                  │
┌───────▼──────┐  ┌──────▼──────┐  ┌──────▼──────┐
│  Auth Svc    │  │  Payment Svc│  │ Inventory Svc│
│  (认证服务)    │  │  (支付服务)   │  │  (库存服务)   │
└───────┬──────┘  └──────┬──────┘  └──────┬──────┘
        │                  │                  │
┌───────▼──────┐  ┌──────▼──────┐  ┌──────▼──────┐
│  AI Service   │  │  Supply Svc │  │  IoT Service │
│  (AI服务)     │  │  (供应链服务)  │  │  (IoT服务)    │
└──────────────┘  └─────────────┘  └─────────────┘
        │                  │                  │
┌───────▼──────────────────▼──────────────────▼───────┐
│              Service Registry (Consul/Etcd)            │
│                   (服务注册中心)                        │
└─────────────────────────────────────────────────────────┘
        │                  │                  │
┌───────▼──────┐  ┌──────▼──────┐  ┌──────▼──────┐
│   Redis      │  │  RabbitMQ   │  │  MySQL/PG  │
│  (缓存)       │  │  (消息队列)   │  │  (数据库)     │
└──────────────┘  └─────────────┘  └─────────────┘
```

##### 3.1.2 服务列表

| 服务名称 | 服务代码 | 端口 | 负责功能 | 依赖服务 |
|----------|----------|------|----------|----------|
| 用户服务 | user-service | 3001 | 用户管理、认证授权 | Auth Service |
| 认证服务 | auth-service | 3002 | JWT生成、权限验证 | Redis |
| 订单服务 | order-service | 3003 | 订单管理、订单流程 | User Service, Product Service, Payment Service |
| 商品服务 | product-service | 3004 | 商品管理、商品搜索 | Inventory Service |
| 库存服务 | inventory-service | 3005 | 库存管理、库存同步 | Redis |
| 支付服务 | payment-service | 3006 | 支付处理、退款管理 | Order Service |
| 供应链服务 | supply-service | 3007 | 供应链管理、发货管理 | Inventory Service |
| AI服务 | ai-service | 3008 | AI对话、智能推荐 | User Service |
| IoT服务 | iot-service | 3009 | 设备管理、数据同步 | User Service |
| 社区服务 | community-service | 3010 | 内容社区、评论问答 | User Service |
| 会员服务 | member-service | 3011 | 会员管理、积分分销 | User Service |
| 通知服务 | notification-service | 3012 | 消息推送、邮件短信 | User Service |

#### 3.2 服务注册与发现

##### 3.2.1 服务注册

```typescript
/**
 * 服务注册
 * @description 微服务启动时向注册中心注册服务信息
 */
interface ServiceRegistration {
  serviceName: string;
  serviceId: string;
  host: string;
  port: number;
  healthCheckUrl: string;
  metadata: {
    version: string;
    environment: string;
    region: string;
    tags: string[];
  };
}

/**
 * 服务注册客户端
 */
class ServiceRegistryClient {
  private consul: Consul;
  
  constructor(consulHost: string, consulPort: number) {
    this.consul = new Consul({
      host: consulHost,
      port: consulPort
    });
  }
  
  /**
   * 注册服务
   * @param registration 服务注册信息
   */
  async registerService(registration: ServiceRegistration) {
    const serviceId = `${registration.serviceName}-${registration.serviceId}`;
    
    await this.consul.agent.service.register({
      id: serviceId,
      name: registration.serviceName,
      address: registration.host,
      port: registration.port,
      check: {
        http: registration.healthCheckUrl,
        interval: '10s',
        timeout: '5s',
        deregistercriticalserviceafter: '30s'
      },
      meta: registration.metadata
    });
    
    console.log(`Service registered: ${serviceId}`);
  }
  
  /**
   * 注销服务
   * @param serviceName 服务名称
   * @param serviceId 服务ID
   */
  async deregisterService(serviceName: string, serviceId: string) {
    const fullServiceId = `${serviceName}-${serviceId}`;
    
    await this.consul.agent.service.deregister(fullServiceId);
    
    console.log(`Service deregistered: ${fullServiceId}`);
  }
  
  /**
   * 发现服务
   * @param serviceName 服务名称
   * @returns 服务实例列表
   */
  async discoverService(serviceName: string): Promise<ServiceInstance[]> {
    const services = await this.consul.agent.service.list();
    const serviceInstances: ServiceInstance[] = [];
    
    for (const [serviceId, service] of Object.entries(services)) {
      if (service.Service === serviceName) {
        serviceInstances.push({
          serviceId,
          serviceName: service.Service,
          host: service.Address,
          port: service.Port,
          metadata: service.Meta
        });
      }
    }
    
    return serviceInstances;
  }
}

interface ServiceInstance {
  serviceId: string;
  serviceName: string;
  host: string;
  port: number;
  metadata: any;
}
```

##### 3.2.2 服务健康检查

```typescript
/**
 * 服务健康检查
 * @description 定期检查服务健康状态
 */
interface HealthCheckResult {
  status: 'UP' | 'DOWN' | 'UNKNOWN';
  timestamp: Date;
  details: {
    database: boolean;
    redis: boolean;
    externalServices: Record<string, boolean>;
  };
}

/**
 * 健康检查服务
 */
class HealthCheckService {
  /**
   * 执行健康检查
   * @returns 健康检查结果
   */
  async checkHealth(): Promise<HealthCheckResult> {
    const details = {
      database: await this.checkDatabase(),
      redis: await this.checkRedis(),
      externalServices: await this.checkExternalServices()
    };
    
    const allHealthy = Object.values(details).every(
      value => typeof value === 'boolean' ? value : Object.values(value).every(v => v)
    );
    
    return {
      status: allHealthy ? 'UP' : 'DOWN',
      timestamp: new Date(),
      details
    };
  }
  
  /**
   * 检查数据库连接
   */
  private async checkDatabase(): Promise<boolean> {
    try {
      await this.db.query('SELECT 1');
      return true;
    } catch (error) {
      console.error('Database health check failed:', error);
      return false;
    }
  }
  
  /**
   * 检查Redis连接
   */
  private async checkRedis(): Promise<boolean> {
    try {
      await this.redis.ping();
      return true;
    } catch (error) {
      console.error('Redis health check failed:', error);
      return false;
    }
  }
  
  /**
   * 检查外部服务
   */
  private async checkExternalServices(): Promise<Record<string, boolean>> {
    const services = ['auth-service', 'payment-service'];
    const results: Record<string, boolean> = {};
    
    for (const service of services) {
      try {
        const instances = await this.serviceRegistry.discoverService(service);
        results[service] = instances.length > 0;
      } catch (error) {
        console.error(`External service ${service} check failed:`, error);
        results[service] = false;
      }
    }
    
    return results;
  }
}
```

#### 3.3 服务间通信协议

##### 3.3.1 HTTP/REST调用

```typescript
/**
 * HTTP/REST调用客户端
 * @description 基于Axios的HTTP客户端封装
 */
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

class HttpClient {
  private client: AxiosInstance;
  private serviceRegistry: ServiceRegistryClient;
  private circuitBreaker: CircuitBreaker;
  
  constructor(
    serviceRegistry: ServiceRegistryClient,
    circuitBreaker: CircuitBreaker
  ) {
    this.serviceRegistry = serviceRegistry;
    this.circuitBreaker = circuitBreaker;
    
    this.client = axios.create({
      timeout: 5000,
      headers: {
        'Content-Type': 'application/json',
        'X-Service-Name': process.env.SERVICE_NAME
      }
    });
    
    this.setupInterceptors();
  }
  
  /**
   * 设置拦截器
   */
  private setupInterceptors() {
    this.client.interceptors.request.use(
      (config) => {
        config.headers['X-Request-Id'] = this.generateRequestId();
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    this.client.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          this.handleUnauthorized();
        }
        return Promise.reject(error);
      }
    );
  }
  
  /**
   * 调用服务
   * @param serviceName 服务名称
   * @param path 请求路径
   * @param config 请求配置
   */
  async callService<T>(
    serviceName: string,
    path: string,
    config: AxiosRequestConfig = {}
  ): Promise<AxiosResponse<T>> {
    const instance = await this.selectServiceInstance(serviceName);
    const url = `http://${instance.host}:${instance.port}${path}`;
    
    return this.circuitBreaker.execute(
      serviceName,
      () => this.client.request<T>({ ...config, url })
    );
  }
  
  /**
   * 选择服务实例
   * @param serviceName 服务名称
   */
  private async selectServiceInstance(serviceName: string): Promise<ServiceInstance> {
    const instances = await this.serviceRegistry.discoverService(serviceName);
    
    if (instances.length === 0) {
      throw new Error(`No available instances for service: ${serviceName}`);
    }
    
    return this.loadBalance(instances);
  }
  
  /**
   * 负载均衡
   * @param instances 服务实例列表
   */
  private loadBalance(instances: ServiceInstance[]): ServiceInstance {
    const index = Math.floor(Math.random() * instances.length);
    return instances[index];
  }
  
  /**
   * 生成请求ID
   */
  private generateRequestId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  /**
   * 处理未授权
   */
  private handleUnauthorized() {
    console.error('Unauthorized access');
  }
}
```

##### 3.3.2 gRPC调用

```typescript
/**
 * gRPC调用客户端
 * @description 基于gRPC的RPC调用封装
 */
import * as grpc from '@grpc/grpc-js';
import { loadPackageDefinition } from '@grpc/proto-loader';

class GrpcClient {
  private clients: Map<string, any> = new Map();
  private serviceRegistry: ServiceRegistryClient;
  
  constructor(serviceRegistry: ServiceRegistryClient) {
    this.serviceRegistry = serviceRegistry;
  }
  
  /**
   * 获取gRPC客户端
   * @param serviceName 服务名称
   * @param protoPath proto文件路径
   * @param packageName 包名
   * @param serviceName 服务名
   */
  async getClient<T>(
    serviceName: string,
    protoPath: string,
    packageName: string,
    serviceNameInProto: string
  ): Promise<T> {
    const cacheKey = `${serviceName}-${serviceNameInProto}`;
    
    if (this.clients.has(cacheKey)) {
      return this.clients.get(cacheKey);
    }
    
    const instance = await this.selectServiceInstance(serviceName);
    const address = `${instance.host}:${instance.port}`;
    
    const packageDefinition = await loadPackageDefinition(protoPath, {
      keepCase: true,
      longs: String,
      enums: String,
      defaults: true,
      oneofs: true
    });
    
    const proto = packageDefinition[packageName];
    const client = new proto[serviceNameInProto](
      address,
      grpc.credentials.createInsecure()
    );
    
    this.clients.set(cacheKey, client);
    
    return client;
  }
  
  /**
   * 选择服务实例
   * @param serviceName 服务名称
   */
  private async selectServiceInstance(serviceName: string): Promise<ServiceInstance> {
    const instances = await this.serviceRegistry.discoverService(serviceName);
    
    if (instances.length === 0) {
      throw new Error(`No available instances for service: ${serviceName}`);
    }
    
    return this.loadBalance(instances);
  }
  
  /**
   * 负载均衡
   * @param instances 服务实例列表
   */
  private loadBalance(instances: ServiceInstance[]): ServiceInstance {
    const index = Math.floor(Math.random() * instances.length);
    return instances[index];
  }
}
```

#### 3.4 负载均衡策略

##### 3.4.1 负载均衡算法

```typescript
/**
 * 负载均衡策略
 * @description 多种负载均衡算法实现
 */
interface LoadBalancer {
  select(instances: ServiceInstance[]): ServiceInstance;
}

/**
 * 随机负载均衡
 */
class RandomLoadBalancer implements LoadBalancer {
  select(instances: ServiceInstance[]): ServiceInstance {
    const index = Math.floor(Math.random() * instances.length);
    return instances[index];
  }
}

/**
 * 轮询负载均衡
 */
class RoundRobinLoadBalancer implements LoadBalancer {
  private currentIndex = 0;
  
  select(instances: ServiceInstance[]): ServiceInstance {
    const instance = instances[this.currentIndex];
    this.currentIndex = (this.currentIndex + 1) % instances.length;
    return instance;
  }
}

/**
 * 最少连接负载均衡
 */
class LeastConnectionsLoadBalancer implements LoadBalancer {
  private connectionCounts: Map<string, number> = new Map();
  
  select(instances: ServiceInstance[]): ServiceInstance {
    let selectedInstance = instances[0];
    let minConnections = Infinity;
    
    for (const instance of instances) {
      const connections = this.connectionCounts.get(instance.serviceId) || 0;
      if (connections < minConnections) {
        minConnections = connections;
        selectedInstance = instance;
      }
    }
    
    this.connectionCounts.set(
      selectedInstance.serviceId,
      (this.connectionCounts.get(selectedInstance.serviceId) || 0) + 1
    );
    
    return selectedInstance;
  }
  
  releaseConnection(instance: ServiceInstance) {
    const current = this.connectionCounts.get(instance.serviceId) || 0;
    this.connectionCounts.set(instance.serviceId, Math.max(0, current - 1));
  }
}

/**
 * 加权随机负载均衡
 */
class WeightedRandomLoadBalancer implements LoadBalancer {
  select(instances: ServiceInstance[]): ServiceInstance {
    const totalWeight = instances.reduce(
      (sum, instance) => sum + (instance.metadata.weight || 1),
      0
    );
    
    let random = Math.random() * totalWeight;
    
    for (const instance of instances) {
      const weight = instance.metadata.weight || 1;
      random -= weight;
      if (random <= 0) {
        return instance;
      }
    }
    
    return instances[instances.length - 1];
  }
}
```

#### 3.5 熔断降级机制

##### 3.5.1 熔断器实现

```typescript
/**
 * 熔断器
 * @description 防止级联故障，实现服务降级
 */
interface CircuitBreakerConfig {
  failureThreshold: number;
  successThreshold: number;
  timeout: number;
  halfOpenMaxCalls: number;
}

enum CircuitState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN'
}

class CircuitBreaker {
  private state = CircuitState.CLOSED;
  private failureCount = 0;
  private successCount = 0;
  private lastFailureTime: Date | null = null;
  private halfOpenCallCount = 0;
  
  constructor(private config: CircuitBreakerConfig) {}
  
  /**
   * 执行请求
   * @param serviceName 服务名称
   * @param fn 执行函数
   */
  async execute<T>(serviceName: string, fn: () => Promise<T>): Promise<T> {
    if (this.state === CircuitState.OPEN) {
      if (this.shouldAttemptReset()) {
        this.transitionToHalfOpen();
      } else {
        throw new Error(`Circuit breaker is OPEN for service: ${serviceName}`);
      }
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  /**
   * 成功回调
   */
  private onSuccess() {
    this.failureCount = 0;
    
    if (this.state === CircuitState.HALF_OPEN) {
      this.successCount++;
      this.halfOpenCallCount++;
      
      if (this.successCount >= this.config.successThreshold) {
        this.transitionToClosed();
      }
    }
  }
  
  /**
   * 失败回调
   */
  private onFailure() {
    this.failureCount++;
    this.lastFailureTime = new Date();
    
    if (this.failureCount >= this.config.failureThreshold) {
      this.transitionToOpen();
    } else if (this.state === CircuitState.HALF_OPEN) {
      this.transitionToOpen();
    }
  }
  
  /**
   * 转换到关闭状态
   */
  private transitionToClosed() {
    this.state = CircuitState.CLOSED;
    this.successCount = 0;
    this.halfOpenCallCount = 0;
    console.log('Circuit breaker transitioned to CLOSED');
  }
  
  /**
   * 转换到开启状态
   */
  private transitionToOpen() {
    this.state = CircuitState.OPEN;
    this.successCount = 0;
    this.halfOpenCallCount = 0;
    console.log('Circuit breaker transitioned to OPEN');
  }
  
  /**
   * 转换到半开状态
   */
  private transitionToHalfOpen() {
    this.state = CircuitState.HALF_OPEN;
    this.successCount = 0;
    this.halfOpenCallCount = 0;
    console.log('Circuit breaker transitioned to HALF_OPEN');
  }
  
  /**
   * 是否应该尝试重置
   */
  private shouldAttemptReset(): boolean {
    if (!this.lastFailureTime) return false;
    
    const elapsed = Date.now() - this.lastFailureTime.getTime();
    return elapsed >= this.config.timeout;
  }
  
  /**
   * 获取当前状态
   */
  getState(): CircuitState {
    return this.state;
  }
}
```

#### 3.6 服务监控与追踪

##### 3.6.1 分布式追踪

```typescript
/**
 * 分布式追踪
 * @description 跨服务请求追踪
 */
interface TraceContext {
  traceId: string;
  spanId: string;
  parentSpanId?: string;
  sampled: boolean;
}

class DistributedTracer {
  private tracer: any;
  
  constructor(serviceName: string) {
    this.tracer = this.initTracer(serviceName);
  }
  
  /**
   * 初始化追踪器
   * @param serviceName 服务名称
   */
  private initTracer(serviceName: string) {
    return {
      startSpan: (name: string, parentSpan?: any) => ({
        setTag: (key: string, value: any) => {},
        log: (event: any) => {},
        finish: () => {},
        context: () => ({
          toSpanId: () => 'span-id',
          toTraceId: () => 'trace-id'
        })
      })
    };
  }
  
  /**
   * 创建追踪上下文
   * @param headers 请求头
   */
  extractTraceContext(headers: Record<string, string>): TraceContext {
    return {
      traceId: headers['x-trace-id'] || this.generateId(),
      spanId: headers['x-span-id'] || this.generateId(),
      parentSpanId: headers['x-parent-span-id'],
      sampled: headers['x-sampled'] === '1'
    };
  }
  
  /**
   * 注入追踪上下文
   * @param context 追踪上下文
   */
  injectTraceContext(context: TraceContext): Record<string, string> {
    return {
      'x-trace-id': context.traceId,
      'x-span-id': context.spanId,
      'x-parent-span-id': context.parentSpanId,
      'x-sampled': context.sampled ? '1' : '0'
    };
  }
  
  /**
   * 生成ID
   */
  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

##### 3.6.2 性能监控

```typescript
/**
 * 性能监控
 * @description 服务性能指标收集
 */
interface PerformanceMetrics {
  serviceName: string;
  timestamp: Date;
  requestCount: number;
  errorCount: number;
  avgResponseTime: number;
  p50ResponseTime: number;
  p95ResponseTime: number;
  p99ResponseTime: number;
}

class PerformanceMonitor {
  private metrics: Map<string, PerformanceMetrics[]> = new Map();
  private responseTimes: Map<string, number[]> = new Map();
  
  /**
   * 记录请求
   * @param serviceName 服务名称
   * @param responseTime 响应时间
   * @param error 是否错误
   */
  recordRequest(serviceName: string, responseTime: number, error: boolean) {
    if (!this.responseTimes.has(serviceName)) {
      this.responseTimes.set(serviceName, []);
    }
    
    const times = this.responseTimes.get(serviceName)!;
    times.push(responseTime);
    
    const metrics = this.calculateMetrics(serviceName, times, error);
    
    if (!this.metrics.has(serviceName)) {
      this.metrics.set(serviceName, []);
    }
    
    this.metrics.get(serviceName)!.push(metrics);
    
    if (times.length > 1000) {
      this.responseTimes.set(serviceName, times.slice(-1000));
    }
  }
  
  /**
   * 计算指标
   * @param serviceName 服务名称
   * @param times 响应时间列表
   * @param error 是否错误
   */
  private calculateMetrics(
    serviceName: string,
    times: number[],
    error: boolean
  ): PerformanceMetrics {
    const sorted = [...times].sort((a, b) => a - b);
    const sum = times.reduce((a, b) => a + b, 0);
    
    return {
      serviceName,
      timestamp: new Date(),
      requestCount: times.length,
      errorCount: error ? 1 : 0,
      avgResponseTime: sum / times.length,
      p50ResponseTime: sorted[Math.floor(times.length * 0.5)],
      p95ResponseTime: sorted[Math.floor(times.length * 0.95)],
      p99ResponseTime: sorted[Math.floor(times.length * 0.99)]
    };
  }
  
  /**
   * 获取指标
   * @param serviceName 服务名称
   */
  getMetrics(serviceName: string): PerformanceMetrics[] {
    return this.metrics.get(serviceName) || [];
  }
}
```

#### 3.7 安全认证

##### 3.7.1 服务间认证

```typescript
/**
 * 服务间认证
 * @description 微服务之间的相互认证
 */
import * as jwt from 'jsonwebtoken';

interface ServiceToken {
  serviceName: string;
  serviceId: string;
  issuedAt: Date;
  expiresAt: Date;
}

class ServiceAuth {
  private privateKey: string;
  private publicKey: string;
  private tokenCache: Map<string, string> = new Map();
  
  constructor(privateKey: string, publicKey: string) {
    this.privateKey = privateKey;
    this.publicKey = publicKey;
  }
  
  /**
   * 生成服务令牌
   * @param serviceName 服务名称
   * @param serviceId 服务ID
   */
  generateToken(serviceName: string, serviceId: string): string {
    const cacheKey = `${serviceName}-${serviceId}`;
    
    if (this.tokenCache.has(cacheKey)) {
      const cachedToken = this.tokenCache.get(cacheKey)!;
      const decoded = jwt.decode(cachedToken) as any;
      
      if (decoded.exp * 1000 > Date.now()) {
        return cachedToken;
      }
    }
    
    const payload: ServiceToken = {
      serviceName,
      serviceId,
      issuedAt: new Date(),
      expiresAt: new Date(Date.now() + 3600000) // 1小时
    };
    
    const token = jwt.sign(payload, this.privateKey, {
      algorithm: 'RS256',
      expiresIn: '1h'
    });
    
    this.tokenCache.set(cacheKey, token);
    
    return token;
  }
  
  /**
   * 验证服务令牌
   * @param token 服务令牌
   */
  verifyToken(token: string): ServiceToken {
    try {
      const decoded = jwt.verify(token, this.publicKey, {
        algorithms: ['RS256']
      }) as ServiceToken;
      
      return decoded;
    } catch (error) {
      throw new Error('Invalid service token');
    }
  }
  
  /**
   * 验证服务权限
   * @param token 服务令牌
   * @param requiredServiceName 需要的服务名称
   */
  verifyServicePermission(token: string, requiredServiceName: string): boolean {
    const decoded = this.verifyToken(token);
    return decoded.serviceName === requiredServiceName;
  }
}
```

#### 3.8 最佳实践

##### 3.8.1 服务设计原则

1. **单一职责**
   - 每个微服务只负责一个业务领域
   - 避免服务功能过于复杂
   - 保持服务边界清晰

2. **无状态设计**
   - 服务实例之间无状态共享
   - 使用Redis等外部存储共享状态
   - 便于水平扩展

3. **异步通信**
   - 使用消息队列处理异步任务
   - 避免服务间同步调用链过长
   - 提高系统响应速度

##### 3.8.2 性能优化建议

1. **缓存策略**
   - 合理使用Redis缓存热点数据
   - 设置合适的缓存过期时间
   - 实现缓存预热机制

2. **连接池管理**
   - 使用连接池管理数据库连接
   - 设置合理的连接池大小
   - 监控连接池使用情况

3. **批量处理**
   - 批量查询减少数据库访问
   - 批量写入提高写入效率
   - 合理设置批量大小

#### 3.9 常见问题

**Q: 如何处理服务间调用超时？**
A: 设置合理的超时时间，使用熔断器防止级联故障，实现降级策略保证核心功能可用。

**Q: 如何保证服务间调用的可靠性？**
A: 使用重试机制处理临时故障，实现幂等性避免重复操作，使用消息队列保证最终一致性。

**Q: 如何监控微服务性能？**
A: 使用分布式追踪系统跟踪请求链路，收集性能指标进行分析，设置告警规则及时发现异常。

**Q: 如何实现服务版本管理？**
A: 在服务注册时标注版本信息，客户端根据版本选择服务实例，实现灰度发布和版本切换。

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
