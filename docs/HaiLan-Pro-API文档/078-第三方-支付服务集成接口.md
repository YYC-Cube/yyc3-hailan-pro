---
@file: 078-第三方-支付服务集成接口.md
@description: HaiLan Pro 对接第三方支付平台的接口规范与调用实现，包含支付、退款等
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-API文档],[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 078 第三方-支付服务集成接口

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-API文档-第三方-支付服务集成接口相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范第三方-支付服务集成接口相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 支付服务集成接口

#### 3.1 接口概述

支付服务集成接口为HaiLan Pro提供完整的支付能力，支持以下核心功能：

- **多种支付方式**：支持微信支付、支付宝、银联等多种支付方式
- **统一下单**：统一的支付下单接口，简化支付流程
- **支付查询**：查询支付状态和订单信息
- **退款处理**：支持全额和部分退款
- **对账功能**：自动对账，确保账目准确
- **安全防护**：多重安全验证，防止支付风险

#### 3.2 支付方式

##### 3.2.1 支持的支付方式

| 支付方式 | 支付渠道 | 状态 | 说明 |
|----------|----------|------|------|
| 微信支付 | APP、小程序、H5、扫码 | 已接入 | 支持APP支付、小程序支付、H5支付、扫码支付 |
| 支付宝 | APP、H5、扫码 | 已接入 | 支持APP支付、H5支付、扫码支付 |
| 银联支付 | APP、H5 | 已接入 | 支持APP支付、H5支付 |
| 余额支付 | - | 已接入 | 使用账户余额支付 |
| 积分支付 | - | 已接入 | 使用积分兑换商品 |

##### 3.2.2 支付配置

**支付配置结构**

```typescript
/**
 * 支付配置
 */
interface PaymentConfig {
  wechatPay: WeChatPayConfig;
  alipay: AlipayConfig;
  unionPay: UnionPayConfig;
}

/**
 * 微信支付配置
 */
interface WeChatPayConfig {
  appId: string;
  mchId: string;
  apiKey: string;
  apiV3Key: string;
  certPath: string;
  keyPath: string;
  notifyUrl: string;
}

/**
 * 支付宝配置
 */
interface AlipayConfig {
  appId: string;
  privateKey: string;
  publicKey: string;
  notifyUrl: string;
}

/**
 * 银联支付配置
 */
interface UnionPayConfig {
  merId: string;
  certPath: string;
  certPassword: string;
  notifyUrl: string;
}
```

#### 3.3 支付流程

##### 3.3.1 统一下单流程

**流程图**

```
用户下单
    ↓
创建支付订单
    ↓
调用统一下单接口
    ↓
获取支付参数
    ↓
调起支付
    ↓
用户完成支付
    ↓
支付结果通知
    ↓
更新订单状态
```

**统一下单接口**

**接口说明**

创建支付订单，获取支付参数。

**请求**

- **方法**：`POST`
- **路径**：`/api/v1/payment/create`
- **认证**：需要JWT认证

**请求参数**

```json
{
  "orderId": "order-123456",
  "paymentMethod": "WECHAT_APP",
  "amount": 99.99,
  "currency": "CNY",
  "subject": "商品订单",
  "body": "商品描述",
  "clientIp": "192.168.1.1",
  "returnUrl": "https://hailan-pro.com/payment/return",
  "notifyUrl": "https://hailan-pro.com/api/v1/payment/notify"
}
```

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| orderId | string | 是 | 订单ID |
| paymentMethod | string | 是 | 支付方式：WECHAT_APP/WECHAT_MINI/WECHAT_H5/WECHAT_QR/ALIPAY_APP/ALIPAY_H5/ALIPAY_QR/UNION_APP/UNION_H5/BALANCE/POINTS |
| amount | number | 是 | 支付金额 |
| currency | string | 否 | 货币类型，默认CNY |
| subject | string | 是 | 订单标题 |
| body | string | 否 | 订单描述 |
| clientIp | string | 是 | 客户端IP |
| returnUrl | string | 否 | 支付完成跳转URL |
| notifyUrl | string | 否 | 支付结果通知URL |

**响应**

- **成功 (200)**

```json
{
  "success": true,
  "data": {
    "paymentId": "payment-123456",
    "orderId": "order-123456",
    "paymentMethod": "WECHAT_APP",
    "amount": 99.99,
    "status": "PENDING",
    "paymentParams": {
      "appid": "wx1234567890",
      "partnerid": "1234567890",
      "prepayid": "wx1234567890",
      "package": "Sign=WXPay",
      "noncestr": "abc123",
      "timestamp": "1234567890",
      "sign": "ABC123"
    },
    "expiresAt": "2026-01-26T11:00:00Z",
    "createdAt": "2026-01-26T10:00:00Z"
  }
}
```

- **错误 (400)**

```json
{
  "success": false,
  "error": {
    "code": "PAYMENT_001",
    "message": "订单不存在"
  }
}
```

**错误码**

| 错误码 | 说明 |
|--------|------|
| PAYMENT_001 | 订单不存在 |
| PAYMENT_002 | 订单已支付 |
| PAYMENT_003 | 支付金额不正确 |
| PAYMENT_004 | 支付方式不支持 |
| PAYMENT_005 | 余额不足 |
| PAYMENT_006 | 积分不足 |

##### 3.3.2 支付查询

**接口说明**

查询支付订单状态。

**请求**

- **方法**：`GET`
- **路径**：`/api/v1/payment/{paymentId}`
- **认证**：需要JWT认证

**路径参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| paymentId | string | 是 | 支付ID |

**响应**

```json
{
  "success": true,
  "data": {
    "paymentId": "payment-123456",
    "orderId": "order-123456",
    "paymentMethod": "WECHAT_APP",
    "amount": 99.99,
    "status": "SUCCESS",
    "transactionId": "4200001234567890",
    "paidAt": "2026-01-26T10:05:00Z",
    "createdAt": "2026-01-26T10:00:00Z"
  }
}
```

##### 3.3.3 支付实现

**支付服务实现**

```typescript
/**
 * 支付服务
 */
class PaymentService {
  constructor(
    private wechatPayService: WeChatPayService,
    private alipayService: AlipayService,
    private unionPayService: UnionPayService,
    private balanceService: BalanceService,
    private pointsService: PointsService
  ) {}
  
  /**
   * 创建支付订单
   */
  async createPayment(
    userId: string,
    request: CreatePaymentRequest
  ): Promise<Payment> {
    // 验证订单
    const order = await this.validateOrder(request.orderId, userId);
    
    // 验证金额
    if (request.amount !== order.totalAmount) {
      throw new Error('支付金额不正确');
    }
    
    // 检查是否已支付
    const existingPayment = await this.getPaymentByOrderId(request.orderId);
    if (existingPayment && existingPayment.status === 'SUCCESS') {
      throw new Error('订单已支付');
    }
    
    // 根据支付方式创建支付
    let payment: Payment;
    switch (request.paymentMethod) {
      case 'WECHAT_APP':
      case 'WECHAT_MINI':
      case 'WECHAT_H5':
      case 'WECHAT_QR':
        payment = await this.wechatPayService.createPayment(request);
        break;
      case 'ALIPAY_APP':
      case 'ALIPAY_H5':
      case 'ALIPAY_QR':
        payment = await this.alipayService.createPayment(request);
        break;
      case 'UNION_APP':
      case 'UNION_H5':
        payment = await this.unionPayService.createPayment(request);
        break;
      case 'BALANCE':
        payment = await this.balanceService.createPayment(request);
        break;
      case 'POINTS':
        payment = await this.pointsService.createPayment(request);
        break;
      default:
        throw new Error('支付方式不支持');
    }
    
    // 保存支付记录
    await this.savePayment(payment);
    
    return payment;
  }
  
  /**
   * 查询支付
   */
  async queryPayment(paymentId: string): Promise<Payment> {
    const payment = await this.getPaymentById(paymentId);
    
    if (!payment) {
      throw new Error('支付订单不存在');
    }
    
    // 如果支付状态为处理中，查询第三方支付状态
    if (payment.status === 'PENDING') {
      const updatedPayment = await this.syncPaymentStatus(payment);
      return updatedPayment;
    }
    
    return payment;
  }
  
  /**
   * 同步支付状态
   */
  private async syncPaymentStatus(payment: Payment): Promise<Payment> {
    let status: PaymentStatus;
    
    switch (payment.paymentMethod) {
      case 'WECHAT_APP':
      case 'WECHAT_MINI':
      case 'WECHAT_H5':
      case 'WECHAT_QR':
        status = await this.wechatPayService.queryPayment(payment);
        break;
      case 'ALIPAY_APP':
      case 'ALIPAY_H5':
      case 'ALIPAY_QR':
        status = await this.alipayService.queryPayment(payment);
        break;
      case 'UNION_APP':
      case 'UNION_H5':
        status = await this.unionPayService.queryPayment(payment);
        break;
      default:
        return payment;
    }
    
    if (status !== payment.status) {
      payment.status = status;
      await this.updatePayment(payment);
      
      // 如果支付成功，更新订单状态
      if (status === 'SUCCESS') {
        await this.updateOrderStatus(payment.orderId, 'PAID');
      }
    }
    
    return payment;
  }
  
  /**
   * 验证订单
   */
  private async validateOrder(orderId: string, userId: string): Promise<Order> {
    const order = await this.getOrderById(orderId);
    
    if (!order) {
      throw new Error('订单不存在');
    }
    
    if (order.userId !== userId) {
      throw new Error('无权限访问该订单');
    }
    
    if (order.status !== 'PENDING') {
      throw new Error('订单状态不正确');
    }
    
    return order;
  }
}
```

#### 3.4 退款处理

##### 3.4.1 退款接口

**接口说明**

申请退款。

**请求**

- **方法**：`POST`
- **路径**：`/api/v1/payment/refund`
- **认证**：需要JWT认证

**请求参数**

```json
{
  "paymentId": "payment-123456",
  "refundAmount": 99.99,
  "reason": "商品质量问题",
  "operator": "user-123"
}
```

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| paymentId | string | 是 | 支付ID |
| refundAmount | number | 是 | 退款金额 |
| reason | string | 是 | 退款原因 |
| operator | string | 是 | 操作人ID |

**响应**

- **成功 (200)**

```json
{
  "success": true,
  "data": {
    "refundId": "refund-123456",
    "paymentId": "payment-123456",
    "orderId": "order-123456",
    "refundAmount": 99.99,
    "status": "PROCESSING",
    "reason": "商品质量问题",
    "createdAt": "2026-01-26T12:00:00Z"
  }
}
```

##### 3.4.2 退款查询

**接口说明**

查询退款状态。

**请求**

- **方法**：`GET`
- **路径**：`/api/v1/payment/refund/{refundId}`
- **认证**：需要JWT认证

**响应**

```json
{
  "success": true,
  "data": {
    "refundId": "refund-123456",
    "paymentId": "payment-123456",
    "orderId": "order-123456",
    "refundAmount": 99.99,
    "status": "SUCCESS",
    "refundIdThird": "REFUND_1234567890",
    "refundedAt": "2026-01-26T12:05:00Z",
    "reason": "商品质量问题",
    "createdAt": "2026-01-26T12:00:00Z"
  }
}
```

##### 3.4.3 退款实现

**退款服务实现**

```typescript
/**
 * 退款服务
 */
class RefundService {
  constructor(
    private wechatPayService: WeChatPayService,
    private alipayService: AlipayService,
    private unionPayService: UnionPayService,
    private balanceService: BalanceService,
    private pointsService: PointsService
  ) {}
  
  /**
   * 创建退款
   */
  async createRefund(
    userId: string,
    request: CreateRefundRequest
  ): Promise<Refund> {
    // 获取支付记录
    const payment = await this.getPaymentById(request.paymentId);
    
    if (!payment) {
      throw new Error('支付订单不存在');
    }
    
    if (payment.status !== 'SUCCESS') {
      throw new Error('支付订单状态不正确');
    }
    
    // 验证退款金额
    if (request.refundAmount > payment.amount) {
      throw new Error('退款金额不能超过支付金额');
    }
    
    // 检查已退款金额
    const refundedAmount = await this.getRefundedAmount(request.paymentId);
    if (refundedAmount + request.refundAmount > payment.amount) {
      throw new Error('退款金额超过可退款金额');
    }
    
    // 根据支付方式创建退款
    let refund: Refund;
    switch (payment.paymentMethod) {
      case 'WECHAT_APP':
      case 'WECHAT_MINI':
      case 'WECHAT_H5':
      case 'WECHAT_QR':
        refund = await this.wechatPayService.createRefund(payment, request);
        break;
      case 'ALIPAY_APP':
      case 'ALIPAY_H5':
      case 'ALIPAY_QR':
        refund = await this.alipayService.createRefund(payment, request);
        break;
      case 'UNION_APP':
      case 'UNION_H5':
        refund = await this.unionPayService.createRefund(payment, request);
        break;
      case 'BALANCE':
        refund = await this.balanceService.createRefund(payment, request);
        break;
      case 'POINTS':
        refund = await this.pointsService.createRefund(payment, request);
        break;
      default:
        throw new Error('支付方式不支持');
    }
    
    // 保存退款记录
    await this.saveRefund(refund);
    
    return refund;
  }
  
  /**
   * 查询退款
   */
  async queryRefund(refundId: string): Promise<Refund> {
    const refund = await this.getRefundById(refundId);
    
    if (!refund) {
      throw new Error('退款订单不存在');
    }
    
    // 如果退款状态为处理中，查询第三方退款状态
    if (refund.status === 'PROCESSING') {
      const updatedRefund = await this.syncRefundStatus(refund);
      return updatedRefund;
    }
    
    return refund;
  }
  
  /**
   * 同步退款状态
   */
  private async syncRefundStatus(refund: Refund): Promise<Refund> {
    const payment = await this.getPaymentById(refund.paymentId);
    let status: RefundStatus;
    
    switch (payment.paymentMethod) {
      case 'WECHAT_APP':
      case 'WECHAT_MINI':
      case 'WECHAT_H5':
      case 'WECHAT_QR':
        status = await this.wechatPayService.queryRefund(refund);
        break;
      case 'ALIPAY_APP':
      case 'ALIPAY_H5':
      case 'ALIPAY_QR':
        status = await this.alipayService.queryRefund(refund);
        break;
      case 'UNION_APP':
      case 'UNION_H5':
        status = await this.unionPayService.queryRefund(refund);
        break;
      default:
        return refund;
    }
    
    if (status !== refund.status) {
      refund.status = status;
      await this.updateRefund(refund);
      
      // 如果退款成功，更新订单状态
      if (status === 'SUCCESS') {
        await this.updateOrderStatus(refund.orderId, 'REFUNDED');
      }
    }
    
    return refund;
  }
}
```

#### 3.5 通知回调

##### 3.5.1 支付结果通知

**接口说明**

接收第三方支付平台的支付结果通知。

**请求**

- **方法**：`POST`
- **路径**：`/api/v1/payment/notify`
- **认证**：签名验证

**微信支付通知**

```xml
<xml>
  <appid><![CDATA[wx1234567890]]></appid>
  <bank_type><![CDATA[CFT]]></bank_type>
  <fee_type><![CDATA[CNY]]></fee_type>
  <is_subscribe><![CDATA[Y]]></is_subscribe>
  <mch_id><![CDATA[1234567890]]></mch_id>
  <nonce_str><![CDATA[abc123]]></nonce_str>
  <openid><![CDATA[oUpF8uMuAJO_M2pxb1Q9zNjWeS6o]]></openid>
  <out_trade_no><![CDATA[payment-123456]]></out_trade_no>
  <result_code><![CDATA[SUCCESS]]></result_code>
  <return_code><![CDATA[SUCCESS]]></return_code>
  <sign><![CDATA[ABC123]]></sign>
  <time_end><![CDATA[20140903131540]]></time_end>
  <total_fee>1</total_fee>
  <trade_type><![CDATA[APP]]></trade_type>
  <transaction_id><![CDATA[4200001234567890]]></transaction_id>
</xml>
```

**支付宝通知**

```json
{
  "gmt_create": "2026-01-26 10:00:00",
  "charset": "UTF-8",
  "seller_email": "test@example.com",
  "subject": "商品订单",
  "sign": "ABC123",
  "buyer_id": "20881021234567890",
  "invoice_amount": "99.99",
  "notify_id": "20260126100000000000000000000000",
  "fund_bill_list": "[{\"amount\":\"99.99\",\"fundChannel\":\"ALIPAYACCOUNT\"}]",
  "notify_type": "trade_status_sync",
  "trade_status": "TRADE_SUCCESS",
  "receipt_amount": "99.99",
  "buyer_pay_amount": "99.99",
  "app_id": "2021001234567890",
  "seller_id": "2088101234567890",
  "notify_time": "2026-01-26 10:05:00",
  "total_amount": "99.99",
  "out_trade_no": "payment-123456",
  "trade_no": "2026012622001234567890123456",
  "auth_app_id": "2021001234567890",
  "buyer_logon_id": "abc***@example.com",
  "point_amount": "0.00"
}
```

**响应**

```xml
<xml>
  <return_code><![CDATA[SUCCESS]]></return_code>
  <return_msg><![CDATA[OK]]></return_msg>
</xml>
```

##### 3.5.2 退款结果通知

**接口说明**

接收第三方支付平台的退款结果通知。

**请求**

- **方法**：`POST`
- **路径**：`/api/v1/payment/refund/notify`
- **认证**：签名验证

**响应**

```xml
<xml>
  <return_code><![CDATA[SUCCESS]]></return_code>
  <return_msg><![CDATA[OK]]></return_msg>
</xml>
```

##### 3.5.3 通知处理

**通知处理服务**

```typescript
/**
 * 支付通知处理服务
 */
class PaymentNotifyService {
  constructor(
    private wechatPayService: WeChatPayService,
    private alipayService: AlipayService,
    private unionPayService: UnionPayService
  ) {}
  
  /**
   * 处理支付通知
   */
  async handlePaymentNotify(
    paymentMethod: string,
    data: any
  ): Promise<void> {
    let notify: PaymentNotify;
    
    switch (paymentMethod) {
      case 'WECHAT':
        notify = await this.wechatPayService.parseNotify(data);
        break;
      case 'ALIPAY':
        notify = await this.alipayService.parseNotify(data);
        break;
      case 'UNION':
        notify = await this.unionPayService.parseNotify(data);
        break;
      default:
        throw new Error('支付方式不支持');
    }
    
    // 验证签名
    if (!notify.signatureValid) {
      throw new Error('签名验证失败');
    }
    
    // 防止重复处理
    const processed = await this.checkNotifyProcessed(notify.outTradeNo);
    if (processed) {
      return;
    }
    
    // 更新支付状态
    await this.updatePaymentStatus(notify);
    
    // 更新订单状态
    await this.updateOrderStatus(notify.outTradeNo, 'PAID');
    
    // 标记通知已处理
    await this.markNotifyProcessed(notify.outTradeNo);
  }
  
  /**
   * 处理退款通知
   */
  async handleRefundNotify(
    paymentMethod: string,
    data: any
  ): Promise<void> {
    let notify: RefundNotify;
    
    switch (paymentMethod) {
      case 'WECHAT':
        notify = await this.wechatPayService.parseRefundNotify(data);
        break;
      case 'ALIPAY':
        notify = await this.alipayService.parseRefundNotify(data);
        break;
      case 'UNION':
        notify = await this.unionPayService.parseRefundNotify(data);
        break;
      default:
        throw new Error('支付方式不支持');
    }
    
    // 验证签名
    if (!notify.signatureValid) {
      throw new Error('签名验证失败');
    }
    
    // 防止重复处理
    const processed = await this.checkRefundNotifyProcessed(notify.outRefundNo);
    if (processed) {
      return;
    }
    
    // 更新退款状态
    await this.updateRefundStatus(notify);
    
    // 更新订单状态
    await this.updateOrderStatus(notify.orderId, 'REFUNDED');
    
    // 标记通知已处理
    await this.markRefundNotifyProcessed(notify.outRefundNo);
  }
}
```

#### 3.6 对账功能

##### 3.6.1 对账接口

**接口说明**

获取对账数据。

**请求**

- **方法**：`GET`
- **路径**：`/api/v1/payment/reconciliation`
- **认证**：需要JWT认证

**查询参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| startDate | string | 是 | 开始日期（YYYY-MM-DD） |
| endDate | string | 是 | 结束日期（YYYY-MM-DD） |
| paymentMethod | string | 否 | 支付方式 |

**响应**

```json
{
  "success": true,
  "data": {
    "startDate": "2026-01-26",
    "endDate": "2026-01-26",
    "totalAmount": 9999.99,
    "totalCount": 100,
    "payments": [
      {
        "paymentId": "payment-123456",
        "orderId": "order-123456",
        "paymentMethod": "WECHAT_APP",
        "amount": 99.99,
        "status": "SUCCESS",
        "transactionId": "4200001234567890",
        "paidAt": "2026-01-26T10:05:00Z"
      }
    ]
  }
}
```

##### 3.6.2 对账实现

**对账服务**

```typescript
/**
 * 对账服务
 */
class ReconciliationService {
  /**
   * 下载对账单
   */
  async downloadBill(
    paymentMethod: string,
    date: string
  ): Promise<Bill> {
    let bill: Bill;
    
    switch (paymentMethod) {
      case 'WECHAT':
        bill = await this.wechatPayService.downloadBill(date);
        break;
      case 'ALIPAY':
        bill = await this.alipayService.downloadBill(date);
        break;
      case 'UNION':
        bill = await this.unionPayService.downloadBill(date);
        break;
      default:
        throw new Error('支付方式不支持');
    }
    
    return bill;
  }
  
  /**
   * 对账
   */
  async reconcile(
    paymentMethod: string,
    date: string
  ): Promise<ReconciliationResult> {
    // 下载对账单
    const bill = await this.downloadBill(paymentMethod, date);
    
    // 获取本地支付记录
    const localPayments = await this.getLocalPayments(paymentMethod, date);
    
    // 对比数据
    const result = this.compareData(bill, localPayments);
    
    // 保存对账结果
    await this.saveReconciliationResult(result);
    
    return result;
  }
  
  /**
   * 对比数据
   */
  private compareData(
    bill: Bill,
    localPayments: Payment[]
  ): ReconciliationResult {
    const billMap = new Map(bill.records.map(r => [r.transactionId, r]));
    const localMap = new Map(localPayments.map(p => [p.transactionId, p]));
    
    const matched: string[] = [];
    const missingInBill: Payment[] = [];
    const missingInLocal: BillRecord[] = [];
    const amountMismatch: Array<{ payment: Payment; bill: BillRecord }> = [];
    
    // 检查本地支付记录
    for (const payment of localPayments) {
      const billRecord = billMap.get(payment.transactionId);
      
      if (!billRecord) {
        missingInBill.push(payment);
        continue;
      }
      
      if (billRecord.amount !== payment.amount) {
        amountMismatch.push({ payment, bill: billRecord });
        continue;
      }
      
      matched.push(payment.transactionId);
    }
    
    // 检查对账单记录
    for (const record of bill.records) {
      if (!localMap.has(record.transactionId)) {
        missingInLocal.push(record);
      }
    }
    
    return {
      date: bill.date,
      paymentMethod: bill.paymentMethod,
      totalAmount: bill.totalAmount,
      totalCount: bill.records.length,
      matchedCount: matched.length,
      missingInBillCount: missingInBill.length,
      missingInLocalCount: missingInLocal.length,
      amountMismatchCount: amountMismatch.length,
      matched: matched,
      missingInBill: missingInBill,
      missingInLocal: missingInLocal,
      amountMismatch: amountMismatch
    };
  }
}
```

#### 3.7 安全机制

##### 3.7.1 签名验证

**签名验证**

```typescript
/**
 * 签名验证服务
 */
class SignatureService {
  /**
   * 验证微信支付签名
   */
  verifyWeChatSign(data: any, apiKey: string): boolean {
    const sortedKeys = Object.keys(data).sort();
    const signStr = sortedKeys
      .filter(key => key !== 'sign' && data[key])
      .map(key => `${key}=${data[key]}`)
      .join('&');
    
    const signStrWithKey = `${signStr}&key=${apiKey}`;
    const sign = crypto.createHash('md5').update(signStrWithKey, 'utf8').digest('hex').toUpperCase();
    
    return sign === data.sign;
  }
  
  /**
   * 生成微信支付签名
   */
  generateWeChatSign(data: any, apiKey: string): string {
    const sortedKeys = Object.keys(data).sort();
    const signStr = sortedKeys
      .filter(key => data[key])
      .map(key => `${key}=${data[key]}`)
      .join('&');
    
    const signStrWithKey = `${signStr}&key=${apiKey}`;
    return crypto.createHash('md5').update(signStrWithKey, 'utf8').digest('hex').toUpperCase();
  }
  
  /**
   * 验证支付宝签名
   */
  verifyAlipaySign(data: any, publicKey: string): boolean {
    const sign = data.sign;
    delete data.sign;
    
    const signStr = JSON.stringify(data);
    const verify = crypto.createVerify('RSA-SHA256');
    verify.update(signStr, 'utf8');
    
    return verify.verify(publicKey, sign, 'base64');
  }
  
  /**
   * 生成支付宝签名
   */
  generateAlipaySign(data: any, privateKey: string): string {
    const signStr = JSON.stringify(data);
    const sign = crypto.createSign('RSA-SHA256');
    sign.update(signStr, 'utf8');
    
    return sign.sign(privateKey, 'base64');
  }
}
```

##### 3.7.2 防重放攻击

**防重放攻击**

```typescript
/**
 * 防重放攻击服务
 */
class AntiReplayService {
  private readonly CACHE_TTL = 300; // 5分钟
  
  /**
   * 检查是否重复请求
   */
  async isReplayRequest(key: string): Promise<boolean> {
    const exists = await this.cache.get(key);
    return !!exists;
  }
  
  /**
   * 记录请求
   */
  async recordRequest(key: string): Promise<void> {
    await this.cache.set(key, '1', this.CACHE_TTL);
  }
  
  /**
   * 生成请求唯一标识
   */
  generateRequestKey(data: any): string {
    const sortedKeys = Object.keys(data).sort();
    const signStr = sortedKeys
      .map(key => `${key}=${data[key]}`)
      .join('&');
    
    return crypto.createHash('md5').update(signStr, 'utf8').digest('hex');
  }
}
```

#### 3.8 接口示例

##### 3.8.1 微信支付示例

```javascript
/**
 * 微信支付示例
 */
async function createWeChatPayment(orderId, amount) {
  const response = await fetch('https://api.hailan-pro.com/api/v1/payment/create', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${getJWTToken()}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      orderId: orderId,
      paymentMethod: 'WECHAT_APP',
      amount: amount,
      currency: 'CNY',
      subject: '商品订单',
      body: '商品描述',
      clientIp: getClientIp()
    })
  });
  
  const result = await response.json();
  
  if (result.success) {
    const { paymentParams } = result.data;
    
    // 调起微信支付
    wx.requestPayment({
      appId: paymentParams.appid,
      timeStamp: paymentParams.timestamp,
      nonceStr: paymentParams.noncestr,
      package: paymentParams.package,
      signType: 'MD5',
      paySign: paymentParams.sign,
      success: (res) => {
        console.log('支付成功:', res);
      },
      fail: (err) => {
        console.error('支付失败:', err);
      }
    });
  } else {
    console.error('创建支付失败:', result.error);
  }
}

// 使用示例
createWeChatPayment('order-123456', 99.99);
```

##### 3.8.2 支付宝支付示例

```javascript
/**
 * 支付宝支付示例
 */
async function createAlipayPayment(orderId, amount) {
  const response = await fetch('https://api.hailan-pro.com/api/v1/payment/create', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${getJWTToken()}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      orderId: orderId,
      paymentMethod: 'ALIPAY_APP',
      amount: amount,
      currency: 'CNY',
      subject: '商品订单',
      body: '商品描述',
      clientIp: getClientIp()
    })
  });
  
  const result = await response.json();
  
  if (result.success) {
    const { paymentParams } = result.data;
    
    // 调起支付宝支付
    Alipay.pay({
      orderInfo: paymentParams.orderInfo,
      success: (res) => {
        console.log('支付成功:', res);
      },
      fail: (err) => {
        console.error('支付失败:', err);
      }
    });
  } else {
    console.error('创建支付失败:', result.error);
  }
}

// 使用示例
createAlipayPayment('order-123456', 99.99);
```

### 4. 最佳实践

#### 4.1 支付安全

- **签名验证**：严格验证所有支付通知的签名
- **防重放攻击**：记录已处理的通知，防止重复处理
- **金额验证**：验证支付金额与订单金额是否一致
- **状态检查**：检查订单状态，防止重复支付

#### 4.2 用户体验

- **支付超时**：设置合理的支付超时时间
- **支付重试**：支持支付失败后的重试
- **支付引导**：提供清晰的支付引导和说明
- **支付反馈**：及时反馈支付结果

#### 4.3 异常处理

- **网络异常**：处理网络中断等异常情况
- **支付超时**：处理支付超时的情况
- **支付失败**：提供清晰的错误提示
- **退款处理**：及时处理退款请求

#### 4.4 数据管理

- **数据备份**：定期备份支付数据
- **数据清理**：定期清理过期数据
- **数据统计**：统计支付数据，分析业务趋势
- **数据安全**：保护支付数据安全

### 5. 故障处理

#### 5.1 常见问题

**支付失败**

- 检查网络连接
- 验证支付参数
- 检查支付账户状态
- 查看错误日志

**退款失败**

- 检查退款金额
- 验证支付状态
- 检查退款账户状态
- 查看错误日志

**对账异常**

- 检查对账单下载
- 验证数据格式
- 检查数据一致性
- 查看错误日志

### 6. 附录

#### 6.1 错误码

| 错误码 | 说明 |
|--------|------|
| PAYMENT_001 | 订单不存在 |
| PAYMENT_002 | 订单已支付 |
| PAYMENT_003 | 支付金额不正确 |
| PAYMENT_004 | 支付方式不支持 |
| PAYMENT_005 | 余额不足 |
| PAYMENT_006 | 积分不足 |
| PAYMENT_007 | 支付超时 |
| PAYMENT_008 | 支付失败 |
| PAYMENT_009 | 签名验证失败 |
| PAYMENT_010 | 重复请求 |

#### 6.2 支付状态

| 状态 | 说明 |
|------|------|
| PENDING | 待支付 |
| PROCESSING | 支付处理中 |
| SUCCESS | 支付成功 |
| FAILED | 支付失败 |
| REFUNDED | 已退款 |
| CANCELLED | 已取消 |

#### 6.3 退款状态

| 状态 | 说明 |
|------|------|
| PROCESSING | 退款处理中 |
| SUCCESS | 退款成功 |
| FAILED | 退款失败 |
| CANCELLED | 退款取消 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
