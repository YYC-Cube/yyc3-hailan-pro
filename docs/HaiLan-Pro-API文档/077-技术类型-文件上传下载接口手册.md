---
@file: 077-技术类型-文件上传下载接口手册.md
@description: HaiLan Pro 图片、视频、文档等文件的上传、下载、预览接口规范
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-API文档],[]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 077 技术类型-文件上传下载接口手册

## 概述

本文档详细描述HaiLan Pro-HaiLan-Pro-API文档-技术类型-文件上传下载接口手册相关内容，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范技术类型-文件上传下载接口手册相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保系统7x24小时稳定运行，支持PWA离线能力
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持业务快速扩展，微服务架构设计
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的技术和流程标准
- **规范化**：严格的开发和管理规范
- **自动化**：提高开发效率和质量，CI/CD自动化
- **智能化**：利用AI技术提升能力，LLM智能顾问
- **可视化**：直观的监控和管理界面

#### 2.3 五化架构
- **流程化**：标准化的开发流程
- **文档化**：完善的文档体系
- **工具化**：高效的开发工具链
- **数字化**：数据驱动的决策
- **生态化**：开放的生态系统

### 3. 文件上传下载接口

#### 3.1 接口概述

文件上传下载接口为HaiLan Pro提供完整的文件管理能力，支持以下核心功能：

- **文件上传**：支持图片、视频、文档等多种文件类型的上传
- **文件下载**：提供安全、高效的文件下载服务
- **文件预览**：支持图片、视频、PDF等文件的在线预览
- **文件管理**：文件的删除、重命名、移动等管理操作
- **文件存储**：分布式存储，支持CDN加速
- **安全控制**：文件访问权限控制和病毒扫描

#### 3.2 文件上传

##### 3.2.1 单文件上传

**接口说明**

上传单个文件到服务器。

**请求**

- **方法**：`POST`
- **路径**：`/api/v1/files/upload`
- **认证**：需要JWT认证
- **Content-Type**：`multipart/form-data`

**请求参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| file | File | 是 | 上传的文件 |
| category | string | 否 | 文件分类：avatar/product/article/document/other |
| description | string | 否 | 文件描述 |
| tags | string[] | 否 | 文件标签 |
| isPublic | boolean | 否 | 是否公开，默认false |

**请求示例**

```bash
curl -X POST 'https://api.hailan-pro.com/api/v1/files/upload' \
  -H 'Authorization: Bearer YOUR_JWT_TOKEN' \
  -F 'file=@/path/to/image.jpg' \
  -F 'category=avatar' \
  -F 'description=用户头像' \
  -F 'tags=["avatar","profile"]'
```

**响应**

- **成功 (200)**

```json
{
  "success": true,
  "data": {
    "fileId": "file-123456",
    "fileName": "image.jpg",
    "fileSize": 102400,
    "fileType": "image/jpeg",
    "category": "avatar",
    "url": "https://cdn.hailan-pro.com/files/file-123456.jpg",
    "thumbnailUrl": "https://cdn.hailan-pro.com/thumbnails/file-123456.jpg",
    "previewUrl": "https://cdn.hailan-pro.com/previews/file-123456.jpg",
    "md5": "d41d8cd98f00b204e9800998ecf8427e",
    "width": 1920,
    "height": 1080,
    "duration": null,
    "createdAt": "2026-01-26T10:00:00Z",
    "uploadedBy": "user-123"
  }
}
```

- **错误 (400)**

```json
{
  "success": false,
  "error": {
    "code": "FILE_001",
    "message": "文件类型不支持",
    "details": "仅支持jpg、png、gif、webp格式的图片"
  }
}
```

**错误码**

| 错误码 | 说明 |
|--------|------|
| FILE_001 | 文件类型不支持 |
| FILE_002 | 文件大小超过限制 |
| FILE_003 | 文件内容损坏 |
| FILE_004 | 病毒检测失败 |
| FILE_005 | 存储空间不足 |

##### 3.2.2 多文件上传

**接口说明**

批量上传多个文件到服务器。

**请求**

- **方法**：`POST`
- **路径**：`/api/v1/files/upload/batch`
- **认证**：需要JWT认证
- **Content-Type**：`multipart/form-data`

**请求参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| files | File[] | 是 | 上传的文件数组 |
| category | string | 否 | 文件分类 |
| description | string | 否 | 文件描述 |
| tags | string[] | 否 | 文件标签 |

**请求示例**

```bash
curl -X POST 'https://api.hailan-pro.com/api/v1/files/upload/batch' \
  -H 'Authorization: Bearer YOUR_JWT_TOKEN' \
  -F 'files=@/path/to/image1.jpg' \
  -F 'files=@/path/to/image2.jpg' \
  -F 'files=@/path/to/image3.jpg' \
  -F 'category=product' \
  -F 'description=商品图片'
```

**响应**

- **成功 (200)**

```json
{
  "success": true,
  "data": {
    "files": [
      {
        "fileId": "file-123456",
        "fileName": "image1.jpg",
        "fileSize": 102400,
        "fileType": "image/jpeg",
        "url": "https://cdn.hailan-pro.com/files/file-123456.jpg",
        "thumbnailUrl": "https://cdn.hailan-pro.com/thumbnails/file-123456.jpg",
        "status": "SUCCESS"
      },
      {
        "fileId": "file-123457",
        "fileName": "image2.jpg",
        "fileSize": 204800,
        "fileType": "image/jpeg",
        "url": "https://cdn.hailan-pro.com/files/file-123457.jpg",
        "thumbnailUrl": "https://cdn.hailan-pro.com/thumbnails/file-123457.jpg",
        "status": "SUCCESS"
      },
      {
        "fileName": "image3.jpg",
        "status": "FAILED",
        "error": {
          "code": "FILE_002",
          "message": "文件大小超过限制"
        }
      }
    ],
    "summary": {
      "total": 3,
      "success": 2,
      "failed": 1
    }
  }
}
```

##### 3.2.3 分片上传

**接口说明**

支持大文件的分片上传，提高上传成功率和速度。

**初始化分片上传**

- **方法**：`POST`
- **路径**：`/api/v1/files/upload/chunk/init`
- **认证**：需要JWT认证

**请求参数**

```json
{
  "fileName": "large-video.mp4",
  "fileSize": 524288000,
  "fileType": "video/mp4",
  "chunkSize": 5242880,
  "totalChunks": 100,
  "md5": "d41d8cd98f00b204e9800998ecf8427e",
  "category": "video",
  "description": "大视频文件"
}
```

**响应**

```json
{
  "success": true,
  "data": {
    "uploadId": "upload-123456",
    "chunkSize": 5242880,
    "totalChunks": 100,
    "uploadedChunks": [],
    "expiresAt": "2026-01-27T10:00:00Z"
  }
}
```

**上传分片**

- **方法**：`POST`
- **路径**：`/api/v1/files/upload/chunk/{uploadId}/{chunkNumber}`
- **认证**：需要JWT认证

**请求参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| chunk | File | 是 | 文件分片 |
| chunkNumber | number | 是 | 分片序号（从1开始） |

**响应**

```json
{
  "success": true,
  "data": {
    "uploadId": "upload-123456",
    "chunkNumber": 1,
    "uploadedChunks": [1],
    "progress": 1
  }
}
```

**完成分片上传**

- **方法**：`POST`
- **路径**：`/api/v1/files/upload/chunk/{uploadId}/complete`
- **认证**：需要JWT认证

**请求参数**

```json
{
  "md5": "d41d8cd98f00b204e9800998ecf8427e"
}
```

**响应**

```json
{
  "success": true,
  "data": {
    "fileId": "file-123456",
    "fileName": "large-video.mp4",
    "fileSize": 524288000,
    "url": "https://cdn.hailan-pro.com/files/file-123456.mp4",
    "thumbnailUrl": "https://cdn.hailan-pro.com/thumbnails/file-123456.jpg",
    "createdAt": "2026-01-26T10:00:00Z"
  }
}
```

##### 3.2.4 上传实现

**上传服务实现**

```typescript
/**
 * 文件上传服务
 */
class FileUploadService {
  private readonly MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
  private readonly ALLOWED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  private readonly ALLOWED_VIDEO_TYPES = ['video/mp4', 'video/webm', 'video/ogg'];
  private readonly ALLOWED_DOCUMENT_TYPES = ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
  
  constructor(
    private storageService: StorageService,
    private virusScanner: VirusScanner,
    private thumbnailGenerator: ThumbnailGenerator
  ) {}
  
  /**
   * 上传单个文件
   */
  async uploadFile(
    file: File,
    options: UploadOptions
  ): Promise<UploadedFile> {
    // 验证文件类型
    this.validateFileType(file);
    
    // 验证文件大小
    this.validateFileSize(file);
    
    // 病毒扫描
    await this.virusScanner.scan(file);
    
    // 计算文件MD5
    const md5 = await this.calculateMD5(file);
    
    // 检查文件是否已存在
    const existingFile = await this.checkFileExists(md5);
    if (existingFile) {
      return existingFile;
    }
    
    // 上传文件到存储
    const storageKey = await this.storageService.upload(file);
    
    // 生成缩略图
    let thumbnailUrl: string | null = null;
    if (this.isImage(file)) {
      thumbnailUrl = await this.thumbnailGenerator.generate(file);
    }
    
    // 提取文件元数据
    const metadata = await this.extractMetadata(file);
    
    // 保存文件记录
    const fileRecord = await this.saveFileRecord({
      fileId: generateFileId(),
      fileName: file.name,
      fileSize: file.size,
      fileType: file.type,
      category: options.category || 'other',
      url: `${this.storageService.getBaseUrl()}/${storageKey}`,
      thumbnailUrl: thumbnailUrl,
      md5: md5,
      metadata: metadata,
      uploadedBy: options.userId,
      isPublic: options.isPublic || false
    });
    
    return fileRecord;
  }
  
  /**
   * 批量上传文件
   */
  async uploadFiles(
    files: File[],
    options: UploadOptions
  ): Promise<BatchUploadResult> {
    const results: UploadedFile[] = [];
    const errors: UploadError[] = [];
    
    for (const file of files) {
      try {
        const uploadedFile = await this.uploadFile(file, options);
        results.push(uploadedFile);
      } catch (error) {
        errors.push({
          fileName: file.name,
          error: error.message
        });
      }
    }
    
    return {
      files: results,
      errors: errors,
      summary: {
        total: files.length,
        success: results.length,
        failed: errors.length
      }
    };
  }
  
  /**
   * 初始化分片上传
   */
  async initChunkUpload(
    options: ChunkUploadInitOptions
  ): Promise<ChunkUploadSession> {
    const uploadId = generateUploadId();
    
    const session: ChunkUploadSession = {
      uploadId: uploadId,
      fileName: options.fileName,
      fileSize: options.fileSize,
      fileType: options.fileType,
      chunkSize: options.chunkSize,
      totalChunks: options.totalChunks,
      uploadedChunks: [],
      md5: options.md5,
      category: options.category,
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24小时后过期
    };
    
    await this.saveUploadSession(session);
    
    return session;
  }
  
  /**
   * 上传分片
   */
  async uploadChunk(
    uploadId: string,
    chunkNumber: number,
    chunk: Buffer
  ): Promise<ChunkUploadProgress> {
    const session = await this.getUploadSession(uploadId);
    
    if (!session) {
      throw new Error('上传会话不存在');
    }
    
    if (session.expiresAt < new Date()) {
      throw new Error('上传会话已过期');
    }
    
    // 上传分片到临时存储
    const chunkKey = `${uploadId}/chunk-${chunkNumber}`;
    await this.storageService.uploadChunk(chunkKey, chunk);
    
    // 更新上传进度
    if (!session.uploadedChunks.includes(chunkNumber)) {
      session.uploadedChunks.push(chunkNumber);
    }
    
    await this.saveUploadSession(session);
    
    return {
      uploadId: uploadId,
      chunkNumber: chunkNumber,
      uploadedChunks: session.uploadedChunks,
      progress: (session.uploadedChunks.length / session.totalChunks) * 100
    };
  }
  
  /**
   * 完成分片上传
   */
  async completeChunkUpload(
    uploadId: string,
    md5: string
  ): Promise<UploadedFile> {
    const session = await this.getUploadSession(uploadId);
    
    if (!session) {
      throw new Error('上传会话不存在');
    }
    
    if (session.uploadedChunks.length !== session.totalChunks) {
      throw new Error('分片未全部上传完成');
    }
    
    // 合并分片
    const mergedFile = await this.mergeChunks(uploadId, session.totalChunks);
    
    // 验证文件MD5
    const calculatedMd5 = await this.calculateMD5(mergedFile);
    if (calculatedMd5 !== md5) {
      throw new Error('文件MD5验证失败');
    }
    
    // 上传完整文件
    const storageKey = await this.storageService.upload(mergedFile);
    
    // 生成缩略图
    let thumbnailUrl: string | null = null;
    if (session.fileType.startsWith('image/')) {
      thumbnailUrl = await this.thumbnailGenerator.generate(mergedFile);
    }
    
    // 保存文件记录
    const fileRecord = await this.saveFileRecord({
      fileId: generateFileId(),
      fileName: session.fileName,
      fileSize: session.fileSize,
      fileType: session.fileType,
      category: session.category,
      url: `${this.storageService.getBaseUrl()}/${storageKey}`,
      thumbnailUrl: thumbnailUrl,
      md5: md5,
      uploadedBy: session.userId
    });
    
    // 清理临时文件
    await this.cleanupChunks(uploadId);
    
    return fileRecord;
  }
  
  /**
   * 验证文件类型
   */
  private validateFileType(file: File): void {
    const allowedTypes = [
      ...this.ALLOWED_IMAGE_TYPES,
      ...this.ALLOWED_VIDEO_TYPES,
      ...this.ALLOWED_DOCUMENT_TYPES
    ];
    
    if (!allowedTypes.includes(file.type)) {
      throw new Error('文件类型不支持');
    }
  }
  
  /**
   * 验证文件大小
   */
  private validateFileSize(file: File): void {
    if (file.size > this.MAX_FILE_SIZE) {
      throw new Error('文件大小超过限制');
    }
  }
  
  /**
   * 计算文件MD5
   */
  private async calculateMD5(file: File | Buffer): Promise<string> {
    const hash = crypto.createHash('md5');
    const buffer = file instanceof File ? await file.arrayBuffer() : file;
    hash.update(Buffer.from(buffer));
    return hash.digest('hex');
  }
  
  /**
   * 检查文件是否已存在
   */
  private async checkFileExists(md5: string): Promise<UploadedFile | null> {
    return await this.db.files.findOne({ md5: md5 });
  }
  
  /**
   * 提取文件元数据
   */
  private async extractMetadata(file: File): Promise<FileMetadata> {
    const metadata: FileMetadata = {};
    
    if (file.type.startsWith('image/')) {
      const image = await this.getImageDimensions(file);
      metadata.width = image.width;
      metadata.height = image.height;
    } else if (file.type.startsWith('video/')) {
      const video = await this.getVideoMetadata(file);
      metadata.width = video.width;
      metadata.height = video.height;
      metadata.duration = video.duration;
    }
    
    return metadata;
  }
  
  /**
   * 合并分片
   */
  private async mergeChunks(uploadId: string, totalChunks: number): Promise<Buffer> {
    const chunks: Buffer[] = [];
    
    for (let i = 1; i <= totalChunks; i++) {
      const chunkKey = `${uploadId}/chunk-${i}`;
      const chunk = await this.storageService.downloadChunk(chunkKey);
      chunks.push(chunk);
    }
    
    return Buffer.concat(chunks);
  }
  
  /**
   * 清理分片
   */
  private async cleanupChunks(uploadId: string): Promise<void> {
    await this.storageService.deleteChunks(uploadId);
    await this.deleteUploadSession(uploadId);
  }
}
```

#### 3.3 文件下载

##### 3.3.1 单文件下载

**接口说明**

下载指定文件。

**请求**

- **方法**：`GET`
- **路径**：`/api/v1/files/{fileId}/download`
- **认证**：需要JWT认证

**路径参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| fileId | string | 是 | 文件ID |

**查询参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| thumbnail | boolean | 否 | 是否下载缩略图，默认false |
| preview | boolean | 否 | 是否下载预览图，默认false |

**请求示例**

```bash
curl -X GET 'https://api.hailan-pro.com/api/v1/files/file-123456/download' \
  -H 'Authorization: Bearer YOUR_JWT_TOKEN' \
  -o image.jpg
```

**响应**

- **成功 (200)**

返回文件二进制数据，Content-Type为文件类型，Content-Disposition包含文件名。

**错误 (404)**

```json
{
  "success": false,
  "error": {
    "code": "FILE_006",
    "message": "文件不存在"
  }
}
```

**错误 (403)**

```json
{
  "success": false,
  "error": {
    "code": "FILE_007",
    "message": "无权限访问该文件"
  }
}
```

##### 3.3.2 批量下载

**接口说明**

打包下载多个文件。

**请求**

- **方法**：`POST`
- **路径**：`/api/v1/files/download/batch`
- **认证**：需要JWT认证

**请求参数**

```json
{
  "fileIds": ["file-123456", "file-123457", "file-123458"],
  "archiveName": "files.zip"
}
```

**响应**

- **成功 (200)**

返回ZIP压缩包文件。

##### 3.3.3 下载实现

**下载服务实现**

```typescript
/**
 * 文件下载服务
 */
class FileDownloadService {
  constructor(
    private storageService: StorageService,
    private accessControl: FileAccessControl
  ) {}
  
  /**
   * 下载文件
   */
  async downloadFile(
    fileId: string,
    options: DownloadOptions,
    userId: string
  ): Promise<DownloadResult> {
    // 获取文件记录
    const file = await this.getFileRecord(fileId);
    
    if (!file) {
      throw new Error('文件不存在');
    }
    
    // 检查访问权限
    await this.accessControl.checkAccess(file, userId);
    
    // 确定下载URL
    let downloadUrl = file.url;
    if (options.thumbnail && file.thumbnailUrl) {
      downloadUrl = file.thumbnailUrl;
    } else if (options.preview && file.previewUrl) {
      downloadUrl = file.previewUrl;
    }
    
    // 生成临时下载令牌
    const downloadToken = this.generateDownloadToken(fileId, userId);
    
    // 记录下载日志
    await this.logDownload(fileId, userId);
    
    return {
      fileId: fileId,
      fileName: file.fileName,
      fileSize: file.fileSize,
      fileType: file.fileType,
      downloadUrl: `${downloadUrl}?token=${downloadToken}`,
      expiresAt: new Date(Date.now() + 3600000) // 1小时后过期
    };
  }
  
  /**
   * 批量下载文件
   */
  async downloadFiles(
    fileIds: string[],
    archiveName: string,
    userId: string
  ): Promise<DownloadResult> {
    // 获取所有文件记录
    const files = await this.getFileRecords(fileIds);
    
    // 检查访问权限
    for (const file of files) {
      await this.accessControl.checkAccess(file, userId);
    }
    
    // 创建临时目录
    const tempDir = await this.createTempDirectory();
    
    // 下载所有文件到临时目录
    const filePaths: string[] = [];
    for (const file of files) {
      const filePath = await this.downloadFileToTemp(file, tempDir);
      filePaths.push(filePath);
    }
    
    // 打包成ZIP
    const archivePath = await this.createArchive(filePaths, archiveName, tempDir);
    
    // 上传到临时存储
    const storageKey = await this.storageService.uploadFile(archivePath);
    
    // 生成下载URL
    const downloadToken = this.generateDownloadToken(storageKey, userId);
    const downloadUrl = `${this.storageService.getBaseUrl()}/${storageKey}?token=${downloadToken}`;
    
    // 清理临时文件
    await this.cleanupTempDirectory(tempDir);
    
    return {
      archiveName: archiveName,
      fileSize: await this.getFileSize(archivePath),
      downloadUrl: downloadUrl,
      expiresAt: new Date(Date.now() + 3600000)
    };
  }
  
  /**
   * 生成下载令牌
   */
  private generateDownloadToken(fileId: string, userId: string): string {
    const payload = {
      fileId: fileId,
      userId: userId,
      expiresAt: Date.now() + 3600000 // 1小时后过期
    };
    
    return jwt.sign(payload, process.env.DOWNLOAD_TOKEN_SECRET, {
      expiresIn: '1h'
    });
  }
  
  /**
   * 验证下载令牌
   */
  verifyDownloadToken(token: string): DownloadTokenPayload | null {
    try {
      const decoded = jwt.verify(token, process.env.DOWNLOAD_TOKEN_SECRET) as DownloadTokenPayload;
      
      if (decoded.expiresAt < Date.now()) {
        return null;
      }
      
      return decoded;
    } catch (error) {
      return null;
    }
  }
  
  /**
   * 记录下载日志
   */
  private async logDownload(fileId: string, userId: string): Promise<void> {
    await this.db.downloads.insert({
      fileId: fileId,
      userId: userId,
      downloadedAt: new Date(),
      ipAddress: this.getClientIp()
    });
  }
}
```

#### 3.4 文件预览

##### 3.4.1 图片预览

**接口说明**

获取图片的预览URL。

**请求**

- **方法**：`GET`
- **路径**：`/api/v1/files/{fileId}/preview`
- **认证**：需要JWT认证

**查询参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| width | number | 否 | 预览宽度，默认800 |
| height | number | 否 | 预览高度，默认600 |
| quality | number | 否 | 图片质量（1-100），默认85 |

**请求示例**

```bash
curl -X GET 'https://api.hailan-pro.com/api/v1/files/file-123456/preview?width=800&height=600&quality=85' \
  -H 'Authorization: Bearer YOUR_JWT_TOKEN'
```

**响应**

```json
{
  "success": true,
  "data": {
    "fileId": "file-123456",
    "previewUrl": "https://cdn.hailan-pro.com/previews/file-123456_800x600.jpg",
    "width": 800,
    "height": 600,
    "quality": 85,
    "fileSize": 51200
  }
}
```

##### 3.4.2 视频预览

**接口说明**

获取视频的预览图和缩略图。

**请求**

- **方法**：`GET`
- **路径**：`/api/v1/files/{fileId}/video-preview`
- **认证**：需要JWT认证

**查询参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| timestamp | number | 否 | 截取时间戳（秒），默认为视频中间位置 |

**响应**

```json
{
  "success": true,
  "data": {
    "fileId": "file-123456",
    "thumbnailUrl": "https://cdn.hailan-pro.com/thumbnails/file-123456.jpg",
    "previewUrl": "https://cdn.hailan-pro.com/previews/file-123456.mp4",
    "duration": 120,
    "width": 1920,
    "height": 1080
  }
}
```

##### 3.4.3 PDF预览

**接口说明**

获取PDF文档的预览图片。

**请求**

- **方法**：`GET`
- **路径**：`/api/v1/files/{fileId}/pdf-preview`
- **认证**：需要JWT认证

**查询参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| page | number | 否 | 页码，默认1 |
| width | number | 否 | 预览宽度，默认800 |

**响应**

```json
{
  "success": true,
  "data": {
    "fileId": "file-123456",
    "page": 1,
    "totalPages": 10,
    "previewUrl": "https://cdn.hailan-pro.com/previews/file-123456_page1.jpg",
    "width": 800,
    "height": 1131
  }
}
```

##### 3.4.4 预览实现

**预览服务实现**

```typescript
/**
 * 文件预览服务
 */
class FilePreviewService {
  constructor(
    private storageService: StorageService,
    private imageProcessor: ImageProcessor,
    private videoProcessor: VideoProcessor,
    private pdfProcessor: PDFProcessor
  ) {}
  
  /**
   * 生成图片预览
   */
  async generateImagePreview(
    fileId: string,
    options: ImagePreviewOptions
  ): Promise<ImagePreview> {
    const file = await this.getFileRecord(fileId);
    
    if (!file.fileType.startsWith('image/')) {
      throw new Error('文件不是图片类型');
    }
    
    // 下载原始文件
    const originalFile = await this.storageService.download(file.url);
    
    // 生成预览图
    const previewBuffer = await this.imageProcessor.resize(originalFile, {
      width: options.width || 800,
      height: options.height || 600,
      quality: options.quality || 85,
      format: 'jpeg'
    });
    
    // 上传预览图
    const previewKey = `previews/${fileId}_${options.width}x${options.height}.jpg`;
    await this.storageService.upload(previewKey, previewBuffer);
    
    return {
      fileId: fileId,
      previewUrl: `${this.storageService.getBaseUrl()}/${previewKey}`,
      width: options.width || 800,
      height: options.height || 600,
      quality: options.quality || 85,
      fileSize: previewBuffer.length
    };
  }
  
  /**
   * 生成视频预览
   */
  async generateVideoPreview(
    fileId: string,
    options: VideoPreviewOptions
  ): Promise<VideoPreview> {
    const file = await this.getFileRecord(fileId);
    
    if (!file.fileType.startsWith('video/')) {
      throw new Error('文件不是视频类型');
    }
    
    // 下载原始文件
    const originalFile = await this.storageService.download(file.url);
    
    // 提取视频元数据
    const metadata = await this.videoProcessor.getMetadata(originalFile);
    
    // 生成缩略图
    const thumbnailTimestamp = options.timestamp || Math.floor(metadata.duration / 2);
    const thumbnailBuffer = await this.videoProcessor.extractFrame(originalFile, {
      timestamp: thumbnailTimestamp,
      width: 320,
      height: 180
    });
    
    const thumbnailKey = `thumbnails/${fileId}.jpg`;
    await this.storageService.upload(thumbnailKey, thumbnailBuffer);
    
    // 生成预览视频（前10秒）
    const previewBuffer = await this.videoProcessor.trim(originalFile, {
      startTime: 0,
      endTime: 10,
      quality: 'medium'
    });
    
    const previewKey = `previews/${fileId}.mp4`;
    await this.storageService.upload(previewKey, previewBuffer);
    
    return {
      fileId: fileId,
      thumbnailUrl: `${this.storageService.getBaseUrl()}/${thumbnailKey}`,
      previewUrl: `${this.storageService.getBaseUrl()}/${previewKey}`,
      duration: metadata.duration,
      width: metadata.width,
      height: metadata.height
    };
  }
  
  /**
   * 生成PDF预览
   */
  async generatePDFPreview(
    fileId: string,
    options: PDFPreviewOptions
  ): Promise<PDFPreview> {
    const file = await this.getFileRecord(fileId);
    
    if (file.fileType !== 'application/pdf') {
      throw new Error('文件不是PDF类型');
    }
    
    // 下载原始文件
    const originalFile = await this.storageService.download(file.url);
    
    // 获取PDF总页数
    const totalPages = await this.pdfProcessor.getPageCount(originalFile);
    
    // 转换指定页面为图片
    const pageNumber = options.page || 1;
    const previewBuffer = await this.pdfProcessor.convertPageToImage(originalFile, {
      page: pageNumber,
      width: options.width || 800,
      format: 'jpeg'
    });
    
    // 上传预览图
    const previewKey = `previews/${fileId}_page${pageNumber}.jpg`;
    await this.storageService.upload(previewKey, previewBuffer);
    
    return {
      fileId: fileId,
      page: pageNumber,
      totalPages: totalPages,
      previewUrl: `${this.storageService.getBaseUrl()}/${previewKey}`,
      width: options.width || 800,
      height: Math.round(options.width || 800 * 1.414)
    };
  }
}
```

#### 3.5 文件管理

##### 3.5.1 获取文件信息

**接口说明**

获取文件的详细信息。

**请求**

- **方法**：`GET`
- **路径**：`/api/v1/files/{fileId}`
- **认证**：需要JWT认证

**响应**

```json
{
  "success": true,
  "data": {
    "fileId": "file-123456",
    "fileName": "image.jpg",
    "fileSize": 102400,
    "fileType": "image/jpeg",
    "category": "avatar",
    "url": "https://cdn.hailan-pro.com/files/file-123456.jpg",
    "thumbnailUrl": "https://cdn.hailan-pro.com/thumbnails/file-123456.jpg",
    "previewUrl": "https://cdn.hailan-pro.com/previews/file-123456.jpg",
    "md5": "d41d8cd98f00b204e9800998ecf8427e",
    "metadata": {
      "width": 1920,
      "height": 1080
    },
    "tags": ["avatar", "profile"],
    "description": "用户头像",
    "isPublic": false,
    "createdAt": "2026-01-26T10:00:00Z",
    "uploadedBy": "user-123",
    "downloadCount": 10
  }
}
```

##### 3.5.2 删除文件

**接口说明**

删除指定文件。

**请求**

- **方法**：`DELETE`
- **路径**：`/api/v1/files/{fileId}`
- **认证**：需要JWT认证

**响应**

```json
{
  "success": true,
  "data": {
    "fileId": "file-123456",
    "deletedAt": "2026-01-26T11:00:00Z"
  }
}
```

##### 3.5.3 文件列表

**接口说明**

获取用户上传的文件列表。

**请求**

- **方法**：`GET`
- **路径**：`/api/v1/files`
- **认证**：需要JWT认证

**查询参数**

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| category | string | 否 | 文件分类 |
| page | number | 否 | 页码，默认1 |
| pageSize | number | 否 | 每页数量，默认20 |
| sortBy | string | 否 | 排序字段：createdAt/fileSize/downloadCount，默认createdAt |
| sortOrder | string | 否 | 排序方向：asc/desc，默认desc |

**响应**

```json
{
  "success": true,
  "data": {
    "files": [
      {
        "fileId": "file-123456",
        "fileName": "image.jpg",
        "fileSize": 102400,
        "fileType": "image/jpeg",
        "category": "avatar",
        "thumbnailUrl": "https://cdn.hailan-pro.com/thumbnails/file-123456.jpg",
        "createdAt": "2026-01-26T10:00:00Z",
        "downloadCount": 10
      }
    ],
    "pagination": {
      "page": 1,
      "pageSize": 20,
      "total": 100,
      "totalPages": 5
    }
  }
}
```

#### 3.6 安全控制

##### 3.6.1 病毒扫描

**病毒扫描服务**

```typescript
/**
 * 病毒扫描服务
 */
class VirusScanner {
  private readonly CLAMAV_HOST = process.env.CLAMAV_HOST || 'localhost';
  private readonly CLAMAV_PORT = parseInt(process.env.CLAMAV_PORT || '3310');
  
  /**
   * 扫描文件
   */
  async scan(file: File | Buffer): Promise<ScanResult> {
    const buffer = file instanceof File ? await file.arrayBuffer() : file;
    
    // 连接到ClamAV
    const socket = new net.Socket();
    
    return new Promise((resolve, reject) => {
      socket.connect(this.CLAMAV_PORT, this.CLAMAV_HOST, () => {
        // 发送文件进行扫描
        socket.write(Buffer.from(buffer));
        
        // 接收扫描结果
        socket.on('data', (data) => {
          const result = data.toString();
          
          if (result.includes('FOUND')) {
            resolve({
              isClean: false,
              virusName: result.split('FOUND')[1].trim()
            });
          } else if (result.includes('OK')) {
            resolve({
              isClean: true,
              virusName: null
            });
          } else {
            reject(new Error('扫描失败'));
          }
          
          socket.end();
        });
        
        socket.on('error', (error) => {
          reject(error);
        });
      });
    });
  }
}
```

##### 3.6.2 访问控制

**访问控制服务**

```typescript
/**
 * 文件访问控制
 */
class FileAccessControl {
  /**
   * 检查访问权限
   */
  async checkAccess(file: FileRecord, userId: string): Promise<boolean> {
    // 公开文件，允许所有用户访问
    if (file.isPublic) {
      return true;
    }
    
    // 文件上传者可以访问
    if (file.uploadedBy === userId) {
      return true;
    }
    
    // 检查共享权限
    const hasSharedAccess = await this.checkSharedAccess(file.fileId, userId);
    if (hasSharedAccess) {
      return true;
    }
    
    throw new Error('无权限访问该文件');
  }
  
  /**
   * 检查共享权限
   */
  private async checkSharedAccess(fileId: string, userId: string): Promise<boolean> {
    const share = await this.db.fileShares.findOne({
      fileId: fileId,
      sharedWith: userId,
      expiresAt: { $gt: new Date() }
    });
    
    return !!share;
  }
  
  /**
   * 分享文件
   */
  async shareFile(
    fileId: string,
    sharedWith: string[],
    expiresAt: Date
  ): Promise<void> {
    for (const userId of sharedWith) {
      await this.db.fileShares.insert({
        fileId: fileId,
        sharedWith: userId,
        sharedBy: this.getCurrentUserId(),
        sharedAt: new Date(),
        expiresAt: expiresAt
      });
    }
  }
}
```

#### 3.7 性能优化

##### 3.7.1 CDN加速

**CDN配置**

```typescript
/**
 * CDN服务
 */
class CDNService {
  private readonly CDN_DOMAIN = 'cdn.hailan-pro.com';
  
  /**
   * 获取CDN URL
   */
  getCDNUrl(storageKey: string): string {
    return `https://${this.CDN_DOMAIN}/${storageKey}`;
  }
  
  /**
   * 刷新CDN缓存
   */
  async refreshCache(storageKeys: string[]): Promise<void> {
    // 调用CDN API刷新缓存
    await this.cdnClient.refreshObjects(storageKeys);
  }
  
  /**
   * 预热CDN缓存
   */
  async warmupCache(storageKeys: string[]): Promise<void> {
    // 调用CDN API预热缓存
    await this.cdnClient.prefetchObjects(storageKeys);
  }
}
```

##### 3.7.2 图片优化

**图片优化服务**

```typescript
/**
 * 图片优化服务
 */
class ImageOptimizer {
  /**
   * 优化图片
   */
  async optimize(image: Buffer, options: OptimizeOptions): Promise<Buffer> {
    // 转换为WebP格式
    const webp = await this.convertToWebP(image, options);
    
    // 压缩图片
    const compressed = await this.compress(webp, options.quality || 85);
    
    return compressed;
  }
  
  /**
   * 生成响应式图片
   */
  async generateResponsiveImages(
    image: Buffer,
    sizes: number[]
  ): Promise<Map<number, Buffer>> {
    const images = new Map<number, Buffer>();
    
    for (const size of sizes) {
      const resized = await this.resize(image, {
        width: size,
        format: 'webp'
      });
      images.set(size, resized);
    }
    
    return images;
  }
}
```

#### 3.8 接口示例

##### 3.8.1 上传示例

```javascript
/**
 * 文件上传示例
 */
async function uploadFile(file, options = {}) {
  const formData = new FormData();
  formData.append('file', file);
  
  if (options.category) {
    formData.append('category', options.category);
  }
  
  if (options.description) {
    formData.append('description', options.description);
  }
  
  if (options.tags) {
    formData.append('tags', JSON.stringify(options.tags));
  }
  
  const response = await fetch('https://api.hailan-pro.com/api/v1/files/upload', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${getJWTToken()}`
    },
    body: formData
  });
  
  const result = await response.json();
  
  if (result.success) {
    console.log('文件上传成功:', result.data);
    return result.data;
  } else {
    console.error('文件上传失败:', result.error);
    throw new Error(result.error.message);
  }
}

// 使用示例
const fileInput = document.getElementById('file-input');
fileInput.addEventListener('change', async (event) => {
  const file = event.target.files[0];
  
  try {
    const uploadedFile = await uploadFile(file, {
      category: 'avatar',
      description: '用户头像',
      tags: ['avatar', 'profile']
    });
    
    console.log('上传成功:', uploadedFile.url);
  } catch (error) {
    console.error('上传失败:', error);
  }
});
```

##### 3.8.2 分片上传示例

```javascript
/**
 * 分片上传示例
 */
class ChunkUploader {
  constructor(file, options = {}) {
    this.file = file;
    this.chunkSize = options.chunkSize || 5 * 1024 * 1024; // 5MB
    this.totalChunks = Math.ceil(file.size / this.chunkSize);
    this.uploadedChunks = new Set();
    this.uploadId = null;
  }
  
  async upload() {
    // 计算文件MD5
    const md5 = await this.calculateMD5(this.file);
    
    // 初始化分片上传
    const initResponse = await fetch('https://api.hailan-pro.com/api/v1/files/upload/chunk/init', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getJWTToken()}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        fileName: this.file.name,
        fileSize: this.file.size,
        fileType: this.file.type,
        chunkSize: this.chunkSize,
        totalChunks: this.totalChunks,
        md5: md5,
        category: 'video'
      })
    });
    
    const initResult = await initResponse.json();
    this.uploadId = initResult.data.uploadId;
    
    // 上传所有分片
    for (let i = 1; i <= this.totalChunks; i++) {
      await this.uploadChunk(i);
      this.updateProgress(i);
    }
    
    // 完成分片上传
    const completeResponse = await fetch(`https://api.hailan-pro.com/api/v1/files/upload/chunk/${this.uploadId}/complete`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getJWTToken()}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        md5: md5
      })
    });
    
    const completeResult = await completeResponse.json();
    return completeResult.data;
  }
  
  async uploadChunk(chunkNumber) {
    const start = (chunkNumber - 1) * this.chunkSize;
    const end = Math.min(start + this.chunkSize, this.file.size);
    const chunk = this.file.slice(start, end);
    
    const formData = new FormData();
    formData.append('chunk', chunk);
    formData.append('chunkNumber', chunkNumber);
    
    const response = await fetch(`https://api.hailan-pro.com/api/v1/files/upload/chunk/${this.uploadId}/${chunkNumber}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getJWTToken()}`
      },
      body: formData
    });
    
    const result = await response.json();
    this.uploadedChunks.add(chunkNumber);
    
    return result.data;
  }
  
  updateProgress(chunkNumber) {
    const progress = (chunkNumber / this.totalChunks) * 100;
    console.log(`上传进度: ${progress.toFixed(2)}%`);
  }
  
  async calculateMD5(file) {
    return new Promise((resolve) => {
      const spark = new SparkMD5.ArrayBuffer();
      const fileReader = new FileReader();
      
      fileReader.onload = (event) => {
        spark.append(event.target.result);
        resolve(spark.end());
      };
      
      fileReader.readAsArrayBuffer(file);
    });
  }
}

// 使用示例
const fileInput = document.getElementById('file-input');
fileInput.addEventListener('change', async (event) => {
  const file = event.target.files[0];
  
  if (file.size > 50 * 1024 * 1024) { // 大于50MB使用分片上传
    const uploader = new ChunkUploader(file);
    
    try {
      const uploadedFile = await uploader.upload();
      console.log('上传成功:', uploadedFile.url);
    } catch (error) {
      console.error('上传失败:', error);
    }
  }
});
```

### 4. 最佳实践

#### 4.1 上传优化

- **分片上传**：大文件使用分片上传，提高成功率和速度
- **断点续传**：记录上传进度，支持断点续传
- **并发上传**：多个分片并发上传，提高上传速度
- **压缩优化**：上传前对图片进行压缩，减少传输数据量

#### 4.2 下载优化

- **CDN加速**：使用CDN分发文件，提高下载速度
- **断点续传**：支持Range请求，实现断点续传
- **缓存策略**：设置合理的缓存头，减少重复下载
- **预加载**：对可能需要的文件进行预加载

#### 4.3 安全考虑

- **病毒扫描**：上传文件进行病毒扫描
- **文件验证**：验证文件类型和内容
- **访问控制**：实现细粒度的文件访问控制
- **加密传输**：使用HTTPS加密传输文件

#### 4.4 存储管理

- **分布式存储**：使用分布式存储系统，提高可用性
- **定期清理**：定期清理临时文件和过期文件
- **备份策略**：实现文件备份和恢复机制
- **容量监控**：监控存储容量，及时扩容

### 5. 故障处理

#### 5.1 常见问题

**上传失败**

- 检查网络连接
- 验证文件类型和大小
- 检查服务器存储空间
- 查看错误日志

**下载失败**

- 检查文件是否存在
- 验证访问权限
- 检查下载令牌是否有效
- 查看错误日志

**预览失败**

- 检查文件类型是否支持预览
- 验证文件是否损坏
- 检查预览服务是否正常
- 查看错误日志

### 6. 附录

#### 6.1 错误码

| 错误码 | 说明 |
|--------|------|
| FILE_001 | 文件类型不支持 |
| FILE_002 | 文件大小超过限制 |
| FILE_003 | 文件内容损坏 |
| FILE_004 | 病毒检测失败 |
| FILE_005 | 存储空间不足 |
| FILE_006 | 文件不存在 |
| FILE_007 | 无权限访问该文件 |
| FILE_008 | 分片上传会话不存在 |
| FILE_009 | 分片上传会话已过期 |
| FILE_010 | 文件MD5验证失败 |

#### 6.2 配置参数

| 参数名 | 默认值 | 说明 |
|--------|--------|------|
| MAX_FILE_SIZE | 104857600 | 最大文件大小（字节） |
| CHUNK_SIZE | 5242880 | 分片大小（字节） |
| MAX_CHUNKS | 1000 | 最大分片数 |
| UPLOAD_SESSION_TTL | 86400000 | 上传会话TTL（毫秒） |
| DOWNLOAD_TOKEN_TTL | 3600000 | 下载令牌TTL（毫秒） |
| THUMBNAIL_WIDTH | 320 | 缩略图宽度（像素） |
| THUMBNAIL_HEIGHT | 180 | 缩略图高度（像素） |
| PREVIEW_WIDTH | 800 | 预览图宽度（像素） |
| PREVIEW_HEIGHT | 600 | 预览图高度（像素） |

#### 6.3 支持的文件类型

| 分类 | 支持的类型 |
|------|------------|
| 图片 | jpg, jpeg, png, gif, webp |
| 视频 | mp4, webm, ogg |
| 文档 | pdf, doc, docx |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
