---
@file: 065-通用规范-接口签名鉴权手册.md
@description: HaiLan Pro 接口请求的签名、验签、token鉴权的实现规范与调用方式
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-02-03
@updated: 2026-02-03
@status: published
@tags: [API接口],[通用规范],[接口鉴权]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 065 通用规范-接口签名鉴权手册

## 概述

本文档详细描述HaiLan Pro项目接口请求的签名、验签、token鉴权的实现规范与调用方式，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 建立统一的接口签名鉴权体系
- 规范JWT Token和匿名DID的使用
- 为前后端开发人员提供清晰的鉴权指导
- 保障接口安全性和隐私保护

### 2. 鉴权体系架构

#### 2.1 鉴权类型

##### 2.1.1 JWT Token认证
- 用于已登录用户的身份认证
- 支持访问受保护的资源
- Token有效期：24小时
- 支持Token刷新机制

##### 2.1.2 匿名DID认证
- 用于隐私模式下的匿名访问
- 不记录用户身份信息
- 支持隐身和伪装模式
- 临时DID有效期：1小时

##### 2.1.3 接口签名
- 防止请求被篡改
- 防止重放攻击
- 确保数据完整性
- 支持时间戳验证

#### 2.2 鉴权流程

```
客户端请求
    ↓
检查Token/DID
    ↓
    ├─ JWT Token有效 → 验证签名 → 通过
    ├─ 匿名DID有效 → 验证DID → 通过
    └─ 无认证信息 → 返回401 → 拒绝
```

### 3. JWT Token认证

#### 3.1 Token结构

##### 3.1.1 JWT格式
```
Header.Payload.Signature
```

##### 3.1.2 Header示例
```json
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "key-id"
}
```

##### 3.1.3 Payload示例
```json
{
  "sub": "user-id",
  "did": "anonymous-did",
  "privacyMode": "STANDARD",
  "iat": 1706908800,
  "exp": 1706995200,
  "iss": "hailan-pro"
}
```

#### 3.2 Token生成

##### 3.2.1 登录获取Token
```typescript
// 登录接口
POST /api/v1.0/users/login

// 请求体
{
  "email": "user@example.com",
  "password": "password123"
}

// 响应
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "refresh-token-xxx",
    "expiresIn": 86400
  }
}
```

##### 3.2.2 Token刷新
```typescript
// 刷新Token接口
POST /api/v1.0/users/refresh-token

// 请求体
{
  "refreshToken": "refresh-token-xxx"
}

// 响应
{
  "success": true,
  "data": {
    "token": "new-jwt-token-xxx",
    "refreshToken": "new-refresh-token-xxx",
    "expiresIn": 86400
  }
}
```

#### 3.3 Token使用

##### 3.3.1 请求头携带Token
```http
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
```

##### 3.3.2 前端实现示例
```typescript
// Axios拦截器自动添加Token
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

#### 3.4 Token验证

##### 3.4.1 后端验证逻辑
```typescript
// JWT验证中间件
@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    
    if (!token) {
      throw new UnauthorizedException();
    }

    try {
      const payload = this.jwtService.verify(token);
      request.user = payload;
      return true;
    } catch (error) {
      throw new UnauthorizedException('Token无效或已过期');
    }
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

### 4. 匿名DID认证

#### 4.1 DID生成

##### 4.1.1 生成匿名DID
```typescript
// 生成匿名DID接口
POST /api/v1.0/privacy/anonymous-did

// 响应
{
  "success": true,
  "data": {
    "did": "did:hailan:anonymous:abc123xyz",
    "expiresIn": 3600,
    "privacyMode": "DISGUISE"
  }
}
```

##### 4.1.2 DID格式规范
```
did:hailan:{type}:{random-string}

type:
  - anonymous: 匿名DID
  - stealth: 隐身DID
  - disguise: 伪装DID
```

#### 4.2 DID使用

##### 4.2.1 请求头携带DID
```http
X-Anonymous-DID: did:hailan:anonymous:abc123xyz
X-Privacy-Mode: DISGUISE
```

##### 4.2.2 前端实现示例
```typescript
// 隐私模式下的请求
const anonymousRequest = async () => {
  const did = await generateAnonymousDID();
  
  return apiClient.post('/api/v1.0/products', data, {
    headers: {
      'X-Anonymous-DID': did,
      'X-Privacy-Mode': 'DISGUISE'
    }
  });
};
```

#### 4.3 DID验证

##### 4.3.1 后端验证逻辑
```typescript
// 匿名DID验证中间件
@Injectable()
export class AnonymousDidAuthGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const did = request.headers['x-anonymous-did'];
    const privacyMode = request.headers['x-privacy-mode'];
    
    if (!did || !privacyMode) {
      throw new UnauthorizedException('缺少匿名DID或隐私模式标识');
    }

    // 验证DID格式和有效期
    if (!this.validateDid(did)) {
      throw new UnauthorizedException('DID无效或已过期');
    }

    request.user = {
      did,
      privacyMode,
      isAnonymous: true
    };
    
    return true;
  }

  private validateDid(did: string): boolean {
    // 验证DID格式
    const didRegex = /^did:hailan:(anonymous|stealth|disguise):[a-z0-9]+$/;
    if (!didRegex.test(did)) {
      return false;
    }

    // 验证DID有效期
    const didData = this.getDidData(did);
    if (!didData || didData.expiresAt < Date.now()) {
      return false;
    }

    return true;
  }
}
```

### 5. 接口签名机制

#### 5.1 签名算法

##### 5.1.1 签名流程
```
1. 收集所有请求参数
2. 按参数名排序
3. 拼接成字符串
4. 添加时间戳和随机数
5. 使用HMAC-SHA256计算签名
6. 将签名添加到请求头
```

##### 5.1.2 签名算法
```typescript
// 签名生成函数
function generateSignature(params: Record<string, any>, secretKey: string): string {
  // 1. 按参数名排序
  const sortedParams = Object.keys(params).sort();
  
  // 2. 拼接参数
  const paramString = sortedParams
    .map(key => `${key}=${params[key]}`)
    .join('&');
  
  // 3. 添加时间戳和随机数
  const timestamp = Date.now();
  const nonce = generateNonce();
  const signString = `${paramString}&timestamp=${timestamp}&nonce=${nonce}`;
  
  // 4. 计算HMAC-SHA256签名
  const signature = crypto
    .createHmac('sha256', secretKey)
    .update(signString)
    .digest('hex');
  
  return {
    signature,
    timestamp,
    nonce
  };
}
```

#### 5.2 签名使用

##### 5.2.1 请求头携带签名
```http
X-Signature: abc123def456...
X-Timestamp: 1706908800000
X-Nonce: random-string-123
```

##### 5.2.2 前端实现示例
```typescript
// 签名请求拦截器
apiClient.interceptors.request.use((config) => {
  const secretKey = getSecretKey();
  const params = config.params || {};
  
  const { signature, timestamp, nonce } = generateSignature(params, secretKey);
  
  config.headers['X-Signature'] = signature;
  config.headers['X-Timestamp'] = timestamp.toString();
  config.headers['X-Nonce'] = nonce;
  
  return config;
});
```

#### 5.3 签名验证

##### 5.3.1 后端验证逻辑
```typescript
// 签名验证中间件
@Injectable()
export class SignatureGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    
    const signature = request.headers['x-signature'];
    const timestamp = request.headers['x-timestamp'];
    const nonce = request.headers['x-nonce'];
    
    if (!signature || !timestamp || !nonce) {
      throw new BadRequestException('缺少签名信息');
    }

    // 验证时间戳（5分钟内有效）
    const now = Date.now();
    const requestTime = parseInt(timestamp);
    if (Math.abs(now - requestTime) > 300000) {
      throw new BadRequestException('请求已过期');
    }

    // 验证随机数（防止重放）
    if (this.isNonceUsed(nonce)) {
      throw new BadRequestException('请求已被处理');
    }

    // 验证签名
    const params = { ...request.query, ...request.body };
    const expectedSignature = this.generateSignature(params, timestamp, nonce);
    
    if (signature !== expectedSignature) {
      throw new BadRequestException('签名验证失败');
    }

    // 标记随机数已使用
    this.markNonceAsUsed(nonce);
    
    return true;
  }

  private isNonceUsed(nonce: string): boolean {
    // 检查Redis中是否存在该nonce
    return this.redisClient.exists(`nonce:${nonce}`);
  }

  private markNonceAsUsed(nonce: string): void {
    // 将nonce存入Redis，5分钟后过期
    this.redisClient.setex(`nonce:${nonce}`, 300, '1');
  }
}
```

### 6. 隐私模式鉴权

#### 6.1 隐私模式类型

| 模式 | 说明 | 鉴权方式 | 数据处理 |
|-----|------|---------|---------|
| STANDARD | 标准模式 | JWT Token | 正常数据处理 |
| STEALTH | 隐身模式 | 匿名DID | 数据脱敏 |
| DISGUISE | 伪装模式 | 匿名DID | 数据匿名化 |

#### 6.2 隐私模式切换

##### 6.2.1 切换隐私模式
```typescript
// 切换隐私模式接口
POST /api/v1.0/privacy/mode

// 请求体
{
  "mode": "DISGUISE"
}

// 响应
{
  "success": true,
  "data": {
    "mode": "DISGUISE",
    "did": "did:hailan:disguise:xyz789",
    "expiresIn": 3600
  }
}
```

##### 6.2.2 前端实现示例
```typescript
// 隐私模式切换
const switchPrivacyMode = async (mode: 'STANDARD' | 'STEALTH' | 'DISGUISE') => {
  const response = await apiClient.post('/api/v1.0/privacy/mode', { mode });
  
  if (mode !== 'STANDARD') {
    // 隐私模式，使用匿名DID
    localStorage.setItem('privacyMode', mode);
    localStorage.setItem('anonymousDID', response.data.did);
  } else {
    // 标准模式，使用JWT Token
    localStorage.removeItem('privacyMode');
    localStorage.removeItem('anonymousDID');
  }
  
  return response.data;
};
```

### 7. 权限控制

#### 7.1 权限级别

##### 7.1.1 权限等级
| 等级 | 说明 | 访问范围 |
|-----|------|---------|
| PUBLIC | 公开接口 | 无需认证 |
| USER | 用户接口 | 需要JWT Token |
| ADMIN | 管理员接口 | 需要管理员权限 |
| ANONYMOUS | 匿名接口 | 需要匿名DID |

##### 7.1.2 权限装饰器
```typescript
// 权限装饰器
export const RequirePermissions = (...permissions: string[]) => SetMetadata('permissions', permissions);

// 使用示例
@RequirePermissions('user:read', 'user:write')
@Get('profile')
async getProfile(@Request() req) {
  return req.user;
}
```

#### 7.2 权限验证

##### 7.2.1 权限验证中间件
```typescript
// 权限验证中间件
@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredPermissions = this.reflector.get<string[]>(
      'permissions',
      context.getHandler()
    );

    if (!requiredPermissions) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user) {
      throw new UnauthorizedException();
    }

    // 检查用户权限
    const hasPermission = requiredPermissions.every(permission =>
      user.permissions.includes(permission)
    );

    if (!hasPermission) {
      throw new ForbiddenException('权限不足');
    }

    return true;
  }
}
```

### 8. 安全最佳实践

#### 8.1 Token安全

##### 8.1.1 Token存储
- 使用HttpOnly Cookie存储（推荐）
- 或使用localStorage存储
- 避免在URL中传递Token
- 定期刷新Token

##### 8.1.2 Token传输
- 始终使用HTTPS
- 在Authorization头中传递
- 避免在请求体中传递
- 敏感接口需要二次验证

#### 8.2 签名安全

##### 8.2.1 密钥管理
- 密钥定期轮换
- 密钥加密存储
- 密钥访问权限控制
- 密钥泄露应急处理

##### 8.2.2 防重放攻击
- 使用时间戳验证
- 使用随机数验证
- 随机数短期有效
- 记录已使用随机数

#### 8.3 隐私保护

##### 8.3.1 数据脱敏
- 隐私模式下自动脱敏
- 敏感字段加密存储
- 日志中不记录敏感信息
- 响应数据脱敏处理

##### 8.3.2 匿名化处理
- 伪装模式完全匿名化
- 不记录用户行为轨迹
- 不关联用户身份
- 定期清理匿名数据

### 9. 错误处理

#### 9.1 鉴权错误

| 错误码 | HTTP码 | 错误描述 | 解决方案 |
|-------|-------|---------|---------|
| 1120 | 401 | 用户名或密码错误 | 检查用户名和密码 |
| 1121 | 401 | Token已过期 | 重新登录获取新Token |
| 1122 | 401 | Token无效 | 检查Token是否正确 |
| 5120 | 403 | 无权限修改隐私设置 | 检查权限设置 |
| 5130 | 422 | 隐私模式设置失败 | 重试设置隐私模式 |

#### 9.2 签名错误

| 错误码 | HTTP码 | 错误描述 | 解决方案 |
|-------|-------|---------|---------|
| 1000 | 400 | 参数缺失 | 检查请求参数完整性 |
| 1001 | 400 | 参数格式错误 | 检查参数格式是否正确 |
| 1002 | 400 | 签名验证失败 | 检查签名生成逻辑 |
| 1003 | 400 | 请求已过期 | 重新发起请求 |
| 1004 | 400 | 请求已被处理 | 避免重复请求 |

### 10. 实施指南

#### 10.1 前端实施

##### 10.1.1 鉴权拦截器
```typescript
// 统一鉴权拦截器
apiClient.interceptors.request.use(async (config) => {
  const privacyMode = localStorage.getItem('privacyMode');
  
  if (privacyMode && privacyMode !== 'STANDARD') {
    // 隐私模式：使用匿名DID
    const did = localStorage.getItem('anonymousDID');
    config.headers['X-Anonymous-DID'] = did;
    config.headers['X-Privacy-Mode'] = privacyMode;
  } else {
    // 标准模式：使用JWT Token
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
  }
  
  // 添加签名
  const signatureData = generateSignature(config.params || {});
  config.headers['X-Signature'] = signatureData.signature;
  config.headers['X-Timestamp'] = signatureData.timestamp.toString();
  config.headers['X-Nonce'] = signatureData.nonce;
  
  return config;
});
```

##### 10.1.2 响应拦截器
```typescript
// 响应拦截器处理Token过期
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      // Token过期，尝试刷新
      const refreshToken = localStorage.getItem('refreshToken');
      if (refreshToken) {
        try {
          const response = await refreshAccessToken(refreshToken);
          localStorage.setItem('token', response.data.token);
          localStorage.setItem('refreshToken', response.data.refreshToken);
          
          // 重新发送原请求
          error.config.headers.Authorization = `Bearer ${response.data.token}`;
          return apiClient.request(error.config);
        } catch (refreshError) {
          // 刷新失败，跳转登录
          localStorage.clear();
          window.location.href = '/login';
        }
      } else {
        // 无刷新Token，跳转登录
        window.location.href = '/login';
      }
    }
    
    return Promise.reject(error);
  }
);
```

#### 10.2 后端实施

##### 10.2.1 全局鉴权守卫
```typescript
// 全局鉴权守卫
@Injectable()
export class GlobalAuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private reflector: Reflector
  ) {}

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const isPublic = this.reflector.get<boolean>(
      'isPublic',
      context.getHandler()
    );

    // 公开接口跳过鉴权
    if (isPublic) {
      return true;
    }

    // 检查Token或DID
    const token = this.extractTokenFromHeader(request);
    const did = request.headers['x-anonymous-did'];
    const privacyMode = request.headers['x-privacy-mode'];

    if (token) {
      // JWT Token认证
      try {
        const payload = this.jwtService.verify(token);
        request.user = payload;
        return true;
      } catch (error) {
        throw new UnauthorizedException('Token无效或已过期');
      }
    } else if (did && privacyMode) {
      // 匿名DID认证
      if (this.validateDid(did)) {
        request.user = { did, privacyMode, isAnonymous: true };
        return true;
      }
    }

    throw new UnauthorizedException();
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }

  private validateDid(did: string): boolean {
    // DID验证逻辑
    const didRegex = /^did:hailan:(anonymous|stealth|disguise):[a-z0-9]+$/;
    return didRegex.test(did);
  }
}
```

##### 10.2.2 控制器使用
```typescript
// 公开接口
@Public()
@Get('products')
async getProducts() {
  return this.productsService.findAll();
}

// 用户接口
@UseGuards(GlobalAuthGuard)
@Get('profile')
async getProfile(@Request() req) {
  return this.usersService.findById(req.user.sub);
}

// 管理员接口
@UseGuards(GlobalAuthGuard, PermissionsGuard)
@RequirePermissions('admin:read')
@Get('users')
async getAllUsers() {
  return this.usersService.findAll();
}
```

## 附录

### A. 参考文档

- JWT规范 (RFC 7519)
- OAuth 2.0规范
- DID规范 (W3C)
- HMAC-SHA256签名算法
- YYC³项目规范文档

### B. 术语表

- JWT：JSON Web Token
- DID：Decentralized Identity
- HMAC：Hash-based Message Authentication Code
- SHA：Secure Hash Algorithm
- PWA：Progressive Web App
- API：Application Programming Interface

### C. 常见问题

#### Q1: Token过期后如何处理？
A: 使用Refresh Token刷新JWT Token，如果Refresh Token也过期，需要重新登录。

#### Q2: 匿名DID和JWT Token可以同时使用吗？
A: 不可以，根据隐私模式选择其中一种认证方式。标准模式使用JWT Token，隐私模式使用匿名DID。

#### Q3: 签名验证失败怎么办？
A: 检查签名生成逻辑、时间戳是否正确、随机数是否唯一、密钥是否正确。

---

<div align="center">

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」

</div>
