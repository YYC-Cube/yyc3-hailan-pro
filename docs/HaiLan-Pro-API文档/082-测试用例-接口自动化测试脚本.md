---
file: 082-测试用例-接口自动化测试脚本.md
description: HaiLan Pro 接口自动化测试的用例与脚本，保障接口功能正确性
author: YanYuCloudCube Team
version: v1.0.0
created: 2026-01-26
updated: 2026-01-26
status: published
tags:
  - HaiLan-Pro-API文档,[API测试],[自动化测试]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***

---

# 082 测试用例-接口自动化测试脚本

## 概述

本文档详细描述HaiLan Pro项目接口自动化测试的测试用例设计、测试脚本实现及测试执行流程，确保所有API接口的功能正确性、性能稳定性和安全性符合项目标准。

## 核心内容

### 1. 测试框架架构

#### 1.1 技术栈选择

```typescript
/**
 * 测试框架技术栈
 */
const TEST_STACK = {
  // 测试框架
  framework: 'Vitest',

  // 断言库
  assert: 'Chai',

  // HTTP客户端
  httpClient: 'Axios',

  // Mock工具
  mock: 'MSW (Mock Service Worker)',

  // 测试覆盖率
  coverage: 'c8',

  // 测试报告
  reporter: 'Vitest UI',

  // 性能测试
  performance: 'k6',

  // API测试
  apiTest: 'Supertest'
};
```

#### 1.2 目录结构

```
tests/
├── unit/                    # 单元测试
│   ├── services/
│   │   ├── userService.test.ts
│   │   ├── authService.test.ts
│   │   └── aiService.test.ts
│   ├── utils/
│   │   ├── crypto.test.ts
│   │   └── validator.test.ts
│   └── repositories/
│       └── userRepository.test.ts
├── integration/             # 集成测试
│   ├── api/
│   │   ├── userApi.test.ts
│   │   ├── authApi.test.ts
│   │   └── aiApi.test.ts
│   └── database/
│       └── dbConnection.test.ts
├── e2e/                     # 端到端测试
│   ├── userFlow.test.ts
│   ├── shoppingFlow.test.ts
│   └── aiChatFlow.test.ts
├── performance/             # 性能测试
│   ├── loadTest.js
│   └── stressTest.js
├── security/                # 安全测试
│   ├── authTest.ts
│   ├── inputValidation.test.ts
│   └── sqlInjection.test.ts
├── fixtures/                # 测试数据
│   ├── users.json
│   ├── products.json
│   └── messages.json
├── mocks/                   # Mock数据
│   ├── handlers.ts
│   └── server.ts
├── utils/                   # 测试工具
│   ├── testHelpers.ts
│   ├── apiClient.ts
│   └── dataGenerator.ts
└── config/                  # 测试配置
    ├── vitest.config.ts
    └── testSetup.ts
```

### 2. 测试用例设计原则

#### 2.1 测试金字塔

```
         /\
        /E2E\        10% - 端到端测试
       /------\
      /Integration\  30% - 集成测试
     /------------\
    /   Unit Tests  \  60% - 单元测试
   /----------------\
```

#### 2.2 测试覆盖率要求

| 测试类型 | 覆盖率要求 | 说明 |
|---------|-----------|------|
| 单元测试 | ≥ 80% | 核心业务逻辑必须达到90%以上 |
| 集成测试 | ≥ 70% | API接口必须完全覆盖 |
| E2E测试 | ≥ 50% | 主要用户流程必须覆盖 |
| 分支覆盖率 | ≥ 75% | 所有条件分支必须测试 |

#### 2.3 测试用例分类

```typescript
/**
 * 测试用例类型枚举
 */
enum TestCaseType {
  // 功能测试
  POSITIVE = 'POSITIVE',           // 正向测试
  NEGATIVE = 'NEGATIVE',           // 负向测试
  BOUNDARY = 'BOUNDARY',           // 边界测试
  ERROR = 'ERROR',                 // 错误处理测试

  // 非功能测试
  PERFORMANCE = 'PERFORMANCE',     // 性能测试
  SECURITY = 'SECURITY',           // 安全测试
  COMPATIBILITY = 'COMPATIBILITY', // 兼容性测试
  RELIABILITY = 'RELIABILITY'      // 可靠性测试
}

/**
 * 测试优先级
 */
enum TestPriority {
  CRITICAL = 'P0',  // 核心功能，必须通过
  HIGH = 'P1',      // 重要功能，必须通过
  MEDIUM = 'P2',    // 一般功能，建议通过
  LOW = 'P3'        // 边缘功能，可选通过
}
```

### 3. 单元测试

#### 3.1 用户服务测试

```typescript
/**
 * @file 用户服务单元测试
 * @description 测试用户服务的各项功能
 * @module tests/unit/services/userService.test
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { UserService } from '@/services/userService';
import { UserRepository } from '@/repositories/userRepository';
import { CacheService } from '@/services/cacheService';
import { EmailService } from '@/services/emailService';
import { CryptoService } from '@/services/cryptoService';

// Mock依赖
vi.mock('@/repositories/userRepository');
vi.mock('@/services/cacheService');
vi.mock('@/services/emailService');
vi.mock('@/services/cryptoService');

describe('UserService - 用户服务单元测试', () => {
  let userService: UserService;
  let mockUserRepository: any;
  let mockCacheService: any;
  let mockEmailService: any;
  let mockCryptoService: any;

  beforeEach(() => {
    mockUserRepository = {
      create: vi.fn(),
      findById: vi.fn(),
      findByEmail: vi.fn(),
      findByPhone: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
      exists: vi.fn()
    };

    mockCacheService = {
      get: vi.fn(),
      set: vi.fn(),
      del: vi.fn(),
      exists: vi.fn()
    };

    mockEmailService = {
      sendVerificationEmail: vi.fn(),
      sendPasswordResetEmail: vi.fn()
    };

    mockCryptoService = {
      hashPassword: vi.fn(),
      comparePassword: vi.fn(),
      encryptData: vi.fn(),
      decryptData: vi.fn()
    };

    userService = new UserService(
      mockUserRepository,
      mockCacheService,
      mockEmailService,
      mockCryptoService
    );

    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('createUser - 创建用户', () => {
    it('应该成功创建用户', async () => {
      const userData = {
        email: 'test@example.com',
        phone: '13800138000',
        password: 'Password123!',
        name: '测试用户',
        nickname: '测试昵称',
        avatar: 'https://example.com/avatar.jpg',
        gender: 'MALE',
        birthdate: '1990-01-01'
      };

      const expectedUser = {
        id: 'user_001',
        ...userData,
        password: 'hashed_password',
        status: 'ACTIVE',
        createdAt: new Date(),
        updatedAt: new Date()
      };

      mockUserRepository.findByEmail.mockResolvedValue(null);
      mockUserRepository.findByPhone.mockResolvedValue(null);
      mockCryptoService.hashPassword.mockResolvedValue('hashed_password');
      mockUserRepository.create.mockResolvedValue(expectedUser);

      const result = await userService.createUser(userData);

      expect(mockUserRepository.findByEmail).toHaveBeenCalledWith(userData.email);
      expect(mockUserRepository.findByPhone).toHaveBeenCalledWith(userData.phone);
      expect(mockCryptoService.hashPassword).toHaveBeenCalledWith(userData.password);
      expect(mockUserRepository.create).toHaveBeenCalled();
      expect(result).toEqual(expectedUser);
    });

    it('当邮箱已存在时应该抛出错误', async () => {
      const userData = {
        email: 'existing@example.com',
        phone: '13800138000',
        password: 'Password123!',
        name: '测试用户'
      };

      mockUserRepository.findByEmail.mockResolvedValue({ id: 'user_001' });

      await expect(userService.createUser(userData)).rejects.toThrow('邮箱已被注册');
    });

    it('当手机号已存在时应该抛出错误', async () => {
      const userData = {
        email: 'test@example.com',
        phone: '13800138000',
        password: 'Password123!',
        name: '测试用户'
      };

      mockUserRepository.findByEmail.mockResolvedValue(null);
      mockUserRepository.findByPhone.mockResolvedValue({ id: 'user_001' });

      await expect(userService.createUser(userData)).rejects.toThrow('手机号已被注册');
    });

    it('当密码不符合要求时应该抛出错误', async () => {
      const userData = {
        email: 'test@example.com',
        phone: '13800138000',
        password: '123',
        name: '测试用户'
      };

      await expect(userService.createUser(userData)).rejects.toThrow('密码格式不正确');
    });
  });

  describe('loginUser - 用户登录', () => {
    it('应该成功使用邮箱登录', async () => {
      const loginData = {
        account: 'test@example.com',
        password: 'Password123!',
        loginType: 'EMAIL'
      };

      const mockUser = {
        id: 'user_001',
        email: 'test@example.com',
        password: 'hashed_password',
        status: 'ACTIVE',
        lastLoginAt: new Date()
      };

      mockUserRepository.findByEmail.mockResolvedValue(mockUser);
      mockCryptoService.comparePassword.mockResolvedValue(true);
      mockUserRepository.update.mockResolvedValue(mockUser);

      const result = await userService.loginUser(loginData);

      expect(mockUserRepository.findByEmail).toHaveBeenCalledWith(loginData.account);
      expect(mockCryptoService.comparePassword).toHaveBeenCalledWith(
        loginData.password,
        mockUser.password
      );
      expect(mockUserRepository.update).toHaveBeenCalled();
      expect(result).toHaveProperty('token');
      expect(result).toHaveProperty('user');
    });

    it('当用户不存在时应该抛出错误', async () => {
      const loginData = {
        account: 'nonexistent@example.com',
        password: 'Password123!',
        loginType: 'EMAIL'
      };

      mockUserRepository.findByEmail.mockResolvedValue(null);

      await expect(userService.loginUser(loginData)).rejects.toThrow('用户不存在');
    });

    it('当密码错误时应该抛出错误', async () => {
      const loginData = {
        account: 'test@example.com',
        password: 'WrongPassword123!',
        loginType: 'EMAIL'
      };

      const mockUser = {
        id: 'user_001',
        email: 'test@example.com',
        password: 'hashed_password',
        status: 'ACTIVE'
      };

      mockUserRepository.findByEmail.mockResolvedValue(mockUser);
      mockCryptoService.comparePassword.mockResolvedValue(false);

      await expect(userService.loginUser(loginData)).rejects.toThrow('密码错误');
    });

    it('当用户被禁用时应该抛出错误', async () => {
      const loginData = {
        account: 'test@example.com',
        password: 'Password123!',
        loginType: 'EMAIL'
      };

      const mockUser = {
        id: 'user_001',
        email: 'test@example.com',
        password: 'hashed_password',
        status: 'DISABLED'
      };

      mockUserRepository.findByEmail.mockResolvedValue(mockUser);

      await expect(userService.loginUser(loginData)).rejects.toThrow('用户已被禁用');
    });
  });

  describe('updateUser - 更新用户信息', () => {
    it('应该成功更新用户信息', async () => {
      const userId = 'user_001';
      const updateData = {
        name: '新用户名',
        nickname: '新昵称',
        avatar: 'https://example.com/new-avatar.jpg'
      };

      const mockUser = {
        id: userId,
        email: 'test@example.com',
        name: '旧用户名',
        nickname: '旧昵称',
        avatar: 'https://example.com/old-avatar.jpg'
      };

      const updatedUser = {
        ...mockUser,
        ...updateData,
        updatedAt: new Date()
      };

      mockUserRepository.findById.mockResolvedValue(mockUser);
      mockUserRepository.update.mockResolvedValue(updatedUser);

      const result = await userService.updateUser(userId, updateData);

      expect(mockUserRepository.findById).toHaveBeenCalledWith(userId);
      expect(mockUserRepository.update).toHaveBeenCalledWith(userId, updateData);
      expect(result).toEqual(updatedUser);
    });

    it('当用户不存在时应该抛出错误', async () => {
      const userId = 'nonexistent_user';
      const updateData = { name: '新用户名' };

      mockUserRepository.findById.mockResolvedValue(null);

      await expect(userService.updateUser(userId, updateData)).rejects.toThrow('用户不存在');
    });

    it('当尝试更新邮箱时应该抛出错误', async () => {
      const userId = 'user_001';
      const updateData = { email: 'newemail@example.com' };

      mockUserRepository.findById.mockResolvedValue({ id: userId });

      await expect(userService.updateUser(userId, updateData)).rejects.toThrow('不能直接更新邮箱');
    });
  });

  describe('deleteUser - 删除用户', () => {
    it('应该成功删除用户', async () => {
      const userId = 'user_001';
      const mockUser = {
        id: userId,
        email: 'test@example.com',
        status: 'ACTIVE'
      };

      mockUserRepository.findById.mockResolvedValue(mockUser);
      mockUserRepository.delete.mockResolvedValue(true);

      const result = await userService.deleteUser(userId);

      expect(mockUserRepository.findById).toHaveBeenCalledWith(userId);
      expect(mockUserRepository.delete).toHaveBeenCalledWith(userId);
      expect(result).toBe(true);
    });

    it('当用户不存在时应该抛出错误', async () => {
      const userId = 'nonexistent_user';

      mockUserRepository.findById.mockResolvedValue(null);

      await expect(userService.deleteUser(userId)).rejects.toThrow('用户不存在');
    });
  });
});
```

#### 3.2 认证服务测试

```typescript
/**
 * @file 认证服务单元测试
 * @description 测试认证服务的各项功能
 * @module tests/unit/services/authService.test
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { AuthService } from '@/services/authService';
import { UserRepository } from '@/repositories/userRepository';
import { TokenService } from '@/services/tokenService';
import { CacheService } from '@/services/cacheService';
import { CryptoService } from '@/services/cryptoService';

vi.mock('@/repositories/userRepository');
vi.mock('@/services/tokenService');
vi.mock('@/services/cacheService');
vi.mock('@/services/cryptoService');

describe('AuthService - 认证服务单元测试', () => {
  let authService: AuthService;
  let mockUserRepository: any;
  let mockTokenService: any;
  let mockCacheService: any;
  let mockCryptoService: any;

  beforeEach(() => {
    mockUserRepository = {
      findById: vi.fn(),
      update: vi.fn()
    };

    mockTokenService = {
      generateToken: vi.fn(),
      verifyToken: vi.fn(),
      refreshToken: vi.fn(),
      revokeToken: vi.fn()
    };

    mockCacheService = {
      get: vi.fn(),
      set: vi.fn(),
      del: vi.fn()
    };

    mockCryptoService = {
      generateDID: vi.fn(),
      verifyDID: vi.fn()
    };

    authService = new AuthService(
      mockUserRepository,
      mockTokenService,
      mockCacheService,
      mockCryptoService
    );

    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('generateToken - 生成令牌', () => {
    it('应该成功生成访问令牌', async () => {
      const userId = 'user_001';
      const tokenPayload = {
        userId: userId,
        type: 'ACCESS',
        exp: Math.floor(Date.now() / 1000) + 3600
      };

      const mockToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';

      mockUserRepository.findById.mockResolvedValue({
        id: userId,
        status: 'ACTIVE'
      });
      mockTokenService.generateToken.mockResolvedValue(mockToken);

      const result = await authService.generateToken(userId, 'ACCESS');

      expect(mockUserRepository.findById).toHaveBeenCalledWith(userId);
      expect(mockTokenService.generateToken).toHaveBeenCalledWith(
        expect.objectContaining({
          userId: userId,
          type: 'ACCESS'
        })
      );
      expect(result).toBe(mockToken);
    });

    it('应该成功生成刷新令牌', async () => {
      const userId = 'user_001';
      const mockToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';

      mockUserRepository.findById.mockResolvedValue({
        id: userId,
        status: 'ACTIVE'
      });
      mockTokenService.generateToken.mockResolvedValue(mockToken);

      const result = await authService.generateToken(userId, 'REFRESH');

      expect(mockTokenService.generateToken).toHaveBeenCalledWith(
        expect.objectContaining({
          userId: userId,
          type: 'REFRESH'
        })
      );
      expect(result).toBe(mockToken);
    });

    it('当用户不存在时应该抛出错误', async () => {
      const userId = 'nonexistent_user';

      mockUserRepository.findById.mockResolvedValue(null);

      await expect(authService.generateToken(userId, 'ACCESS')).rejects.toThrow('用户不存在');
    });
  });

  describe('verifyToken - 验证令牌', () => {
    it('应该成功验证有效的令牌', async () => {
      const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';
      const decodedPayload = {
        userId: 'user_001',
        type: 'ACCESS',
        exp: Math.floor(Date.now() / 1000) + 3600
      };

      mockTokenService.verifyToken.mockResolvedValue(decodedPayload);
      mockUserRepository.findById.mockResolvedValue({
        id: 'user_001',
        status: 'ACTIVE'
      });

      const result = await authService.verifyToken(token);

      expect(mockTokenService.verifyToken).toHaveBeenCalledWith(token);
      expect(mockUserRepository.findById).toHaveBeenCalledWith('user_001');
      expect(result).toEqual(decodedPayload);
    });

    it('当令牌过期时应该抛出错误', async () => {
      const token = 'expired_token';

      mockTokenService.verifyToken.mockRejectedValue(new Error('令牌已过期'));

      await expect(authService.verifyToken(token)).rejects.toThrow('令牌已过期');
    });

    it('当令牌无效时应该抛出错误', async () => {
      const token = 'invalid_token';

      mockTokenService.verifyToken.mockRejectedValue(new Error('令牌无效'));

      await expect(authService.verifyToken(token)).rejects.toThrow('令牌无效');
    });

    it('当用户已被禁用时应该抛出错误', async () => {
      const token = 'valid_token';
      const decodedPayload = {
        userId: 'user_001',
        type: 'ACCESS',
        exp: Math.floor(Date.now() / 1000) + 3600
      };

      mockTokenService.verifyToken.mockResolvedValue(decodedPayload);
      mockUserRepository.findById.mockResolvedValue({
        id: 'user_001',
        status: 'DISABLED'
      });

      await expect(authService.verifyToken(token)).rejects.toThrow('用户已被禁用');
    });
  });

  describe('refreshToken - 刷新令牌', () => {
    it('应该成功刷新令牌', async () => {
      const refreshToken = 'refresh_token_value';
      const decodedPayload = {
        userId: 'user_001',
        type: 'REFRESH',
        exp: Math.floor(Date.now() / 1000) + 3600
      };

      const newAccessToken = 'new_access_token';
      const newRefreshToken = 'new_refresh_token';

      mockTokenService.verifyToken.mockResolvedValue(decodedPayload);
      mockUserRepository.findById.mockResolvedValue({
        id: 'user_001',
        status: 'ACTIVE'
      });
      mockTokenService.generateToken
        .mockResolvedValueOnce(newAccessToken)
        .mockResolvedValueOnce(newRefreshToken);

      const result = await authService.refreshToken(refreshToken);

      expect(mockTokenService.verifyToken).toHaveBeenCalledWith(refreshToken);
      expect(mockTokenService.generateToken).toHaveBeenCalledTimes(2);
      expect(result).toHaveProperty('accessToken', newAccessToken);
      expect(result).toHaveProperty('refreshToken', newRefreshToken);
    });
  });

  describe('generateAnonymousDID - 生成匿名DID', () => {
    it('应该成功生成匿名DID', async () => {
      const mockDID = 'did:anonymous:1234567890abcdef';
      const mockToken = 'did_token_value';

      mockCryptoService.generateDID.mockResolvedValue(mockDID);
      mockTokenService.generateToken.mockResolvedValue(mockToken);

      const result = await authService.generateAnonymousDID();

      expect(mockCryptoService.generateDID).toHaveBeenCalled();
      expect(mockTokenService.generateToken).toHaveBeenCalledWith(
        expect.objectContaining({
          did: mockDID,
          type: 'ANONYMOUS'
        })
      );
      expect(result).toHaveProperty('did', mockDID);
      expect(result).toHaveProperty('token', mockToken);
    });
  });
});
```

### 4. 集成测试

#### 4.1 API集成测试

```typescript
/**
 * @file 用户API集成测试
 * @description 测试用户相关API接口的集成功能
 * @module tests/integration/api/userApi.test
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { setupTestServer, teardownTestServer } from '@/tests/utils/testServer';
import { createTestUser, cleanupTestData } from '@/tests/utils/testHelpers';
import { APIClient } from '@/tests/utils/apiClient';

describe('User API Integration Tests - 用户API集成测试', () => {
  let apiClient: APIClient;
  let testUser: any;

  beforeAll(async () => {
    await setupTestServer();
    apiClient = new APIClient('http://localhost:3200');
  });

  afterAll(async () => {
    await teardownTestServer();
  });

  beforeEach(async () => {
    testUser = await createTestUser();
  });

  afterEach(async () => {
    await cleanupTestData();
  });

  describe('POST /api/v1/users/register - 用户注册', () => {
    it('应该成功注册新用户', async () => {
      const registerData = {
        email: `test${Date.now()}@example.com`,
        phone: '13800138001',
        password: 'Password123!',
        name: '测试用户',
        nickname: '测试昵称'
      };

      const response = await apiClient.post('/api/v1/users/register', registerData);

      expect(response.status).toBe(201);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toHaveProperty('userId');
      expect(response.data.data).toHaveProperty('token');
      expect(response.data.data.user.email).toBe(registerData.email);
    });

    it('当邮箱已存在时应该返回错误', async () => {
      const registerData = {
        email: testUser.email,
        phone: '13800138002',
        password: 'Password123!',
        name: '测试用户'
      };

      const response = await apiClient.post('/api/v1/users/register', registerData);

      expect(response.status).toBe(400);
      expect(response.data.success).toBe(false);
      expect(response.data.code).toBe('EMAIL_ALREADY_EXISTS');
    });

    it('当密码格式不正确时应该返回错误', async () => {
      const registerData = {
        email: `test${Date.now()}@example.com`,
        phone: '13800138003',
        password: '123',
        name: '测试用户'
      };

      const response = await apiClient.post('/api/v1/users/register', registerData);

      expect(response.status).toBe(400);
      expect(response.data.success).toBe(false);
      expect(response.data.code).toBe('INVALID_PASSWORD');
    });
  });

  describe('POST /api/v1/users/login - 用户登录', () => {
    it('应该成功使用邮箱登录', async () => {
      const loginData = {
        account: testUser.email,
        password: 'Password123!',
        loginType: 'EMAIL'
      };

      const response = await apiClient.post('/api/v1/users/login', loginData);

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toHaveProperty('accessToken');
      expect(response.data.data).toHaveProperty('refreshToken');
      expect(response.data.data.user.email).toBe(testUser.email);
    });

    it('应该成功使用手机号登录', async () => {
      const loginData = {
        account: testUser.phone,
        password: 'Password123!',
        loginType: 'PHONE'
      };

      const response = await apiClient.post('/api/v1/users/login', loginData);

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toHaveProperty('accessToken');
    });

    it('当密码错误时应该返回错误', async () => {
      const loginData = {
        account: testUser.email,
        password: 'WrongPassword123!',
        loginType: 'EMAIL'
      };

      const response = await apiClient.post('/api/v1/users/login', loginData);

      expect(response.status).toBe(401);
      expect(response.data.success).toBe(false);
      expect(response.data.code).toBe('INVALID_CREDENTIALS');
    });
  });

  describe('GET /api/v1/users/profile - 获取用户信息', () => {
    it('应该成功获取用户信息', async () => {
      const loginResponse = await apiClient.post('/api/v1/users/login', {
        account: testUser.email,
        password: 'Password123!',
        loginType: 'EMAIL'
      });

      const token = loginResponse.data.data.accessToken;

      const response = await apiClient.get('/api/v1/users/profile', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data.id).toBe(testUser.id);
      expect(response.data.data.email).toBe(testUser.email);
    });

    it('当未提供令牌时应该返回错误', async () => {
      const response = await apiClient.get('/api/v1/users/profile');

      expect(response.status).toBe(401);
      expect(response.data.success).toBe(false);
      expect(response.data.code).toBe('UNAUTHORIZED');
    });

    it('当令牌无效时应该返回错误', async () => {
      const response = await apiClient.get('/api/v1/users/profile', {
        headers: {
          'Authorization': 'Bearer invalid_token'
        }
      });

      expect(response.status).toBe(401);
      expect(response.data.success).toBe(false);
      expect(response.data.code).toBe('INVALID_TOKEN');
    });
  });

  describe('PUT /api/v1/users/profile - 更新用户信息', () => {
    it('应该成功更新用户信息', async () => {
      const loginResponse = await apiClient.post('/api/v1/users/login', {
        account: testUser.email,
        password: 'Password123!',
        loginType: 'EMAIL'
      });

      const token = loginResponse.data.data.accessToken;

      const updateData = {
        name: '新用户名',
        nickname: '新昵称'
      };

      const response = await apiClient.put('/api/v1/users/profile', updateData, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data.name).toBe(updateData.name);
      expect(response.data.data.nickname).toBe(updateData.nickname);
    });
  });

  describe('POST /api/v1/users/logout - 用户登出', () => {
    it('应该成功登出', async () => {
      const loginResponse = await apiClient.post('/api/v1/users/login', {
        account: testUser.email,
        password: 'Password123!',
        loginType: 'EMAIL'
      });

      const token = loginResponse.data.data.accessToken;

      const response = await apiClient.post('/api/v1/users/logout', {}, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.message).toBe('登出成功');
    });
  });
});
```

#### 4.2 AI API集成测试

```typescript
/**
 * @file AI API集成测试
 * @description 测试AI相关API接口的集成功能
 * @module tests/integration/api/aiApi.test
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { setupTestServer, teardownTestServer } from '@/tests/utils/testServer';
import { createTestUser, cleanupTestData } from '@/tests/utils/testHelpers';
import { APIClient } from '@/tests/utils/apiClient';

describe('AI API Integration Tests - AI API集成测试', () => {
  let apiClient: APIClient;
  let testUser: any;
  let authToken: string;

  beforeAll(async () => {
    await setupTestServer();
    apiClient = new APIClient('http://localhost:3200');
  });

  afterAll(async () => {
    await teardownTestServer();
  });

  beforeEach(async () => {
    testUser = await createTestUser();
    const loginResponse = await apiClient.post('/api/v1/users/login', {
      account: testUser.email,
      password: 'Password123!',
      loginType: 'EMAIL'
    });
    authToken = loginResponse.data.data.accessToken;
  });

  afterEach(async () => {
    await cleanupTestData();
  });

  describe('POST /api/v1/ai/chat - AI对话', () => {
    it('应该成功创建AI对话', async () => {
      const chatRequest = {
        model: 'gpt-4',
        messages: [
          {
            role: 'user',
            content: '你好，请介绍一下你自己'
          }
        ],
        temperature: 0.7,
        maxTokens: 1000
      };

      const response = await apiClient.post('/api/v1/ai/chat', chatRequest, {
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toHaveProperty('chatId');
      expect(response.data.data).toHaveProperty('message');
      expect(response.data.data.message.role).toBe('assistant');
      expect(response.data.data.message.content).toBeTruthy();
    });

    it('应该支持多轮对话', async () => {
      const chatRequest = {
        model: 'gpt-4',
        messages: [
          {
            role: 'user',
            content: '我的名字是张三'
          },
          {
            role: 'assistant',
            content: '你好张三！很高兴认识你。'
          },
          {
            role: 'user',
            content: '你还记得我的名字吗？'
          }
        ]
      };

      const response = await apiClient.post('/api/v1/ai/chat', chatRequest, {
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data.message.content).toContain('张三');
    });

    it('当模型参数无效时应该返回错误', async () => {
      const chatRequest = {
        model: 'invalid-model',
        messages: [
          {
            role: 'user',
            content: '你好'
          }
        ]
      };

      const response = await apiClient.post('/api/v1/ai/chat', chatRequest, {
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });

      expect(response.status).toBe(400);
      expect(response.data.success).toBe(false);
      expect(response.data.code).toBe('INVALID_MODEL');
    });
  });

  describe('POST /api/v1/ai/recommendations - AI推荐', () => {
    it('应该成功获取商品推荐', async () => {
      const recommendationRequest = {
        type: 'PRODUCT',
        userId: testUser.id,
        limit: 10,
        preferences: {
          category: 'health',
          priceRange: {
            min: 100,
            max: 500
          }
        }
      };

      const response = await apiClient.post(
        '/api/v1/ai/recommendations',
        recommendationRequest,
        {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        }
      );

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toHaveProperty('recommendations');
      expect(Array.isArray(response.data.data.recommendations)).toBe(true);
    });

    it('应该成功获取内容推荐', async () => {
      const recommendationRequest = {
        type: 'CONTENT',
        userId: testUser.id,
        limit: 5,
        preferences: {
          category: 'health',
          tags: ['养生', '健康']
        }
      };

      const response = await apiClient.post(
        '/api/v1/ai/recommendations',
        recommendationRequest,
        {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        }
      );

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toHaveProperty('recommendations');
    });
  });

  describe('POST /api/v1/ai/qa - AI问答', () => {
    it('应该成功回答健康问题', async () => {
      const qaRequest = {
        question: '如何保持良好的睡眠质量？',
        context: {
          category: 'health',
          userId: testUser.id
        }
      };

      const response = await apiClient.post('/api/v1/ai/qa', qaRequest, {
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toHaveProperty('answer');
      expect(response.data.data).toHaveProperty('sources');
      expect(response.data.data.answer).toBeTruthy();
    });

    it('应该返回相关参考来源', async () => {
      const qaRequest = {
        question: '什么是健康的生活方式？',
        context: {
          category: 'health',
          userId: testUser.id
        }
      };

      const response = await apiClient.post('/api/v1/ai/qa', qaRequest, {
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data.sources).toBeDefined();
      expect(Array.isArray(response.data.data.sources)).toBe(true);
    });
  });

  describe('POST /api/v1/ai/images/generate - 图像生成', () => {
    it('应该成功生成图像', async () => {
      const imageRequest = {
        prompt: '一个宁静的森林场景，阳光透过树叶',
        negativePrompt: '模糊，低质量',
        size: '1024x1024',
        style: 'realistic',
        quality: 'standard',
        numberOfImages: 1
      };

      const response = await apiClient.post(
        '/api/v1/ai/images/generate',
        imageRequest,
        {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        }
      );

      expect(response.status).toBe(200);
      expect(response.data.success).toBe(true);
      expect(response.data.data).toHaveProperty('images');
      expect(Array.isArray(response.data.data.images)).toBe(true);
      expect(response.data.data.images[0]).toHaveProperty('url');
    });

    it('当提示词包含敏感内容时应该返回错误', async () => {
      const imageRequest = {
        prompt: '敏感内容',
        size: '1024x1024'
      };

      const response = await apiClient.post(
        '/api/v1/ai/images/generate',
        imageRequest,
        {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        }
      );

      expect(response.status).toBe(400);
      expect(response.data.success).toBe(false);
      expect(response.data.code).toBe('CONTENT_FILTERED');
    });
  });
});
```

### 5. 端到端测试

#### 5.1 用户流程E2E测试

```typescript
/**
 * @file 用户流程端到端测试
 * @description 测试完整的用户使用流程
 * @module tests/e2e/userFlow.test
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { chromium, Browser, Page, BrowserContext } from 'playwright';

describe('User Flow E2E Tests - 用户流程端到端测试', () => {
  let browser: Browser;
  let context: BrowserContext;
  let page: Page;

  beforeAll(async () => {
    browser = await chromium.launch({
      headless: true
    });
    context = await browser.newContext();
    page = await context.newPage();
  });

  afterAll(async () => {
    await context.close();
    await browser.close();
  });

  describe('完整的用户注册和登录流程', () => {
    it('应该完成从注册到登录的完整流程', async () => {
      const timestamp = Date.now();
      const testEmail = `test${timestamp}@example.com`;
      const testPhone = `1380013${String(timestamp).slice(-4)}`;

      // 1. 访问注册页面
      await page.goto('http://localhost:3200/register');
      await expect(page).toHaveTitle(/注册/);

      // 2. 填写注册表单
      await page.fill('input[name="email"]', testEmail);
      await page.fill('input[name="phone"]', testPhone);
      await page.fill('input[name="password"]', 'Password123!');
      await page.fill('input[name="confirmPassword"]', 'Password123!');
      await page.fill('input[name="name"]', '测试用户');
      await page.fill('input[name="nickname"]', '测试昵称');

      // 3. 提交注册表单
      await page.click('button[type="submit"]');

      // 4. 等待注册成功
      await expect(page.locator('.success-message')).toBeVisible();
      await expect(page.locator('.success-message')).toContainText('注册成功');

      // 5. 跳转到登录页面
      await page.click('a[href="/login"]');
      await expect(page).toHaveTitle(/登录/);

      // 6. 填写登录表单
      await page.fill('input[name="account"]', testEmail);
      await page.fill('input[name="password"]', 'Password123!');

      // 7. 提交登录表单
      await page.click('button[type="submit"]');

      // 8. 等待登录成功并跳转到首页
      await expect(page).toHaveURL('http://localhost:3200/');
      await expect(page.locator('.user-avatar')).toBeVisible();
    });
  });

  describe('购物流程', () => {
    it('应该完成从浏览商品到下单的完整流程', async () => {
      const timestamp = Date.now();
      const testEmail = `shopper${timestamp}@example.com`;

      // 1. 注册并登录
      await page.goto('http://localhost:3200/register');
      await page.fill('input[name="email"]', testEmail);
      await page.fill('input[name="phone"]', '13800139999');
      await page.fill('input[name="password"]', 'Password123!');
      await page.fill('input[name="name"]', '购物用户');
      await page.click('button[type="submit"]');
      await page.waitForSelector('.success-message');

      // 2. 浏览商品列表
      await page.goto('http://localhost:3200/products');
      await expect(page.locator('.product-list')).toBeVisible();

      // 3. 选择第一个商品
      await page.click('.product-item:first-child');
      await expect(page).toHaveURL(/\/products\/\d+/);

      // 4. 添加到购物车
      await page.click('button:has-text("加入购物车")');
      await expect(page.locator('.cart-count')).toHaveText('1');

      // 5. 查看购物车
      await page.click('a[href="/cart"]');
      await expect(page).toHaveURL('http://localhost:3200/cart');
      await expect(page.locator('.cart-item')).toBeVisible();

      // 6. 结算
      await page.click('button:has-text("去结算")');
      await expect(page).toHaveURL('http://localhost:3200/checkout');

      // 7. 填写收货地址
      await page.fill('input[name="recipientName"]', '张三');
      await page.fill('input[name="recipientPhone"]', '13800138000');
      await page.fill('input[name="province"]', '北京市');
      await page.fill('input[name="city"]', '北京市');
      await page.fill('input[name="district"]', '朝阳区');
      await page.fill('input[name="address"]', '测试地址123号');
      await page.fill('input[name="postalCode"]', '100000');

      // 8. 选择支付方式
      await page.click('input[value="ALIPAY"]');

      // 9. 提交订单
      await page.click('button:has-text("提交订单")');

      // 10. 等待订单创建成功
      await expect(page.locator('.order-success')).toBeVisible();
      await expect(page.locator('.order-id')).toBeVisible();
    });
  });

  describe('AI对话流程', () => {
    it('应该完成AI对话的完整流程', async () => {
      const timestamp = Date.now();
      const testEmail = `aiuser${timestamp}@example.com`;

      // 1. 注册并登录
      await page.goto('http://localhost:3200/register');
      await page.fill('input[name="email"]', testEmail);
      await page.fill('input[name="phone"]', '13800138888');
      await page.fill('input[name="password"]', 'Password123!');
      await page.fill('input[name="name"]', 'AI用户');
      await page.click('button[type="submit"]');
      await page.waitForSelector('.success-message');

      // 2. 进入AI对话页面
      await page.goto('http://localhost:3200/ai/chat');
      await expect(page.locator('.chat-container')).toBeVisible();

      // 3. 发送第一条消息
      await page.fill('textarea[name="message"]', '你好，请介绍一下你自己');
      await page.click('button:has-text("发送")');

      // 4. 等待AI回复
      await expect(page.locator('.message.assistant')).toBeVisible();
      await expect(page.locator('.message.assistant')).toContainText('你好');

      // 5. 发送第二条消息
      await page.fill('textarea[name="message"]', '你能给我一些健康建议吗？');
      await page.click('button:has-text("发送")');

      // 6. 等待AI回复
      await expect(page.locator('.message.assistant').nth(1)).toBeVisible();

      // 7. 查看对话历史
      await expect(page.locator('.message.user')).toHaveCount(2);
      await expect(page.locator('.message.assistant')).toHaveCount(2);
    });
  });
});
```

### 6. 性能测试

#### 6.1 负载测试脚本

```javascript
/**
 * @file 负载测试脚本
 * @description 使用k6进行API负载测试
 * @module tests/performance/loadTest.js
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

// 自定义指标
const errorRate = new Rate('errors');
const responseTime = new Trend('response_time');

// 测试配置
export const options = {
  stages: [
    { duration: '30s', target: 50 },
    { duration: '1m', target: 50 },
    { duration: '30s', target: 100 },
    { duration: '1m', target: 100 },
    { duration: '30s', target: 0 },
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'],
    errors: ['rate<0.01'],
  },
};

const BASE_URL = 'http://localhost:3200';

export function setup() {
  const registerResponse = http.post(`${BASE_URL}/api/v1/users/register`, JSON.stringify({
    email: `loadtest${Date.now()}@example.com`,
    phone: '13800139999',
    password: 'Password123!',
    name: '负载测试用户'
  }), {
    headers: { 'Content-Type': 'application/json' },
  });

  if (registerResponse.status !== 201) {
    throw new Error('Failed to create test user');
  }

  return {
    token: registerResponse.json('data.token'),
    userId: registerResponse.json('data.userId'),
  };
}

export default function (data) {
  const headers = {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${data.token}`,
  };

  let getUserResponse = http.get(`${BASE_URL}/api/v1/users/profile`, {
    headers: headers,
  });

  check(getUserResponse, {
    'GET /users/profile status is 200': (r) => r.status === 200,
    'GET /users/profile response time < 200ms': (r) => r.timings.duration < 200,
  }) || errorRate.add(1);

  responseTime.add(getUserResponse.timings.duration);

  let getProductsResponse = http.get(`${BASE_URL}/api/v1/products?page=1&limit=10`, {
    headers: headers,
  });

  check(getProductsResponse, {
    'GET /products status is 200': (r) => r.status === 200,
    'GET /products response time < 300ms': (r) => r.timings.duration < 300,
  }) || errorRate.add(1);

  responseTime.add(getProductsResponse.timings.duration);

  sleep(1);
}

export function teardown(data) {
  http.del(`${BASE_URL}/api/v1/users/${data.userId}`, null, {
    headers: {
      'Authorization': `Bearer ${data.token}`,
    },
  });
}
```

### 7. 安全测试

#### 7.1 认证安全测试

```typescript
/**
 * @file 认证安全测试
 * @description 测试认证相关的安全漏洞
 * @module tests/security/authTest
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { describe, it, expect } from 'vitest';
import { APIClient } from '@/tests/utils/apiClient';

describe('Authentication Security Tests - 认证安全测试', () => {
  let apiClient: APIClient;

  beforeEach(() => {
    apiClient = new APIClient('http://localhost:3200');
  });

  describe('Token Security - 令牌安全', () => {
    it('应该拒绝过期的令牌', async () => {
      const expiredToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MDAwMDAwMDB9.expired';

      const response = await apiClient.get('/api/v1/users/profile', {
        headers: {
          'Authorization': `Bearer ${expiredToken}`
        }
      });

      expect(response.status).toBe(401);
      expect(response.data.code).toBe('TOKEN_EXPIRED');
    });

    it('应该拒绝格式错误的令牌', async () => {
      const invalidToken = 'invalid_token_format';

      const response = await apiClient.get('/api/v1/users/profile', {
        headers: {
          'Authorization': `Bearer ${invalidToken}`
        }
      });

      expect(response.status).toBe(401);
      expect(response.data.code).toBe('INVALID_TOKEN');
    });

    it('应该拒绝被篡改的令牌', async () => {
      const tamperedToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.tampered.signature';

      const response = await apiClient.get('/api/v1/users/profile', {
        headers: {
          'Authorization': `Bearer ${tamperedToken}`
        }
      });

      expect(response.status).toBe(401);
      expect(response.data.code).toBe('INVALID_TOKEN');
    });
  });

  describe('Password Security - 密码安全', () => {
    it('应该拒绝弱密码', async () => {
      const weakPasswords = [
        '123',
        'password',
        'qwerty',
        '111111'
      ];

      for (const weakPassword of weakPasswords) {
        const response = await apiClient.post('/api/v1/users/register', {
          email: `test${Date.now()}@example.com`,
          phone: '13800138000',
          password: weakPassword,
          name: '测试用户'
        });

        expect(response.status).toBe(400);
        expect(response.data.code).toBe('WEAK_PASSWORD');
      }
    });

    it('应该拒绝常见密码', async () => {
      const commonPasswords = [
        'Password123!',
        'Admin@123',
        'Test@1234'
      ];

      for (const commonPassword of commonPasswords) {
        const response = await apiClient.post('/api/v1/users/register', {
          email: `test${Date.now()}@example.com`,
          phone: '13800138000',
          password: commonPassword,
          name: '测试用户'
        });

        expect(response.status).toBe(400);
        expect(response.data.code).toBe('COMMON_PASSWORD');
      }
    });
  });

  describe('Rate Limiting - 限流测试', () => {
    it('应该在登录失败次数过多时触发限流', async () => {
      const loginData = {
        account: 'test@example.com',
        password: 'WrongPassword123!',
        loginType: 'EMAIL'
      };

      for (let i = 0; i < 6; i++) {
        await apiClient.post('/api/v1/users/login', loginData);
      }

      const response = await apiClient.post('/api/v1/users/login', loginData);

      expect(response.status).toBe(429);
      expect(response.data.code).toBe('TOO_MANY_REQUESTS');
    });

    it('应该在短时间内发送过多验证码时触发限流', async () => {
      const phone = '13800138000';

      for (let i = 0; i < 6; i++) {
        await apiClient.post('/api/v1/sms/send-code', {
          phone: phone,
          type: 'REGISTER'
        });
      }

      const response = await apiClient.post('/api/v1/sms/send-code', {
        phone: phone,
        type: 'REGISTER'
      });

      expect(response.status).toBe(429);
      expect(response.data.code).toBe('TOO_MANY_REQUESTS');
    });
  });
});
```

#### 7.2 输入验证测试

```typescript
/**
 * @file 输入验证测试
 * @description 测试输入验证的安全性
 * @module tests/security/inputValidation.test
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { describe, it, expect } from 'vitest';
import { APIClient } from '@/tests/utils/apiClient';

describe('Input Validation Security Tests - 输入验证安全测试', () => {
  let apiClient: APIClient;

  beforeEach(() => {
    apiClient = new APIClient('http://localhost:3200');
  });

  describe('SQL Injection - SQL注入测试', () => {
    it('应该防止SQL注入攻击', async () => {
      const sqlInjectionPayloads = [
        "' OR '1'='1",
        "'; DROP TABLE users; --",
        "' UNION SELECT * FROM users --",
        "1' AND '1'='1"
      ];

      for (const payload of sqlInjectionPayloads) {
        const response = await apiClient.post('/api/v1/users/login', {
          account: payload,
          password: 'Password123!',
          loginType: 'EMAIL'
        });

        expect(response.status).not.toBe(500);
        expect(response.data.success).toBe(false);
      }
    });
  });

  describe('XSS Prevention - XSS防护测试', () => {
    it('应该防止XSS攻击', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        'javascript:alert("XSS")',
        '<svg onload=alert("XSS")>'
      ];

      for (const payload of xssPayloads) {
        const response = await apiClient.post('/api/v1/users/register', {
          email: `test${Date.now()}@example.com`,
          phone: '13800138000',
          password: 'Password123!',
          name: payload,
          nickname: payload
        });

        expect(response.status).not.toBe(500);
        if (response.status === 201) {
          expect(response.data.data.user.name).not.toContain('<script>');
        }
      }
    });
  });

  describe('CSRF Protection - CSRF防护测试', () => {
    it('应该验证CSRF令牌', async () => {
      const response = await apiClient.post('/api/v1/users/logout', {}, {
        headers: {
          'X-CSRF-Token': 'invalid_token'
        }
      });

      expect(response.status).toBe(403);
      expect(response.data.code).toBe('INVALID_CSRF_TOKEN');
    });
  });
});
```

### 8. 测试工具和辅助函数

#### 8.1 测试辅助函数

```typescript
/**
 * @file 测试辅助函数
 * @description 提供测试过程中常用的辅助函数
 * @module tests/utils/testHelpers
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { UserRepository } from '@/repositories/userRepository';
import { ProductRepository } from '@/repositories/productRepository';
import { OrderRepository } from '@/repositories/orderRepository';
import { CryptoService } from '@/services/cryptoService';

/**
 * 创建测试用户
 */
export async function createTestUser(overrides: any = {}): Promise<any> {
  const timestamp = Date.now();
  const userData = {
    email: `test${timestamp}@example.com`,
    phone: `1380013${String(timestamp).slice(-4)}`,
    password: 'Password123!',
    name: '测试用户',
    nickname: '测试昵称',
    avatar: 'https://example.com/avatar.jpg',
    gender: 'MALE',
    birthdate: '1990-01-01',
    status: 'ACTIVE',
    ...overrides
  };

  const cryptoService = new CryptoService();
  const hashedPassword = await cryptoService.hashPassword(userData.password);

  const user = await UserRepository.create({
    ...userData,
    password: hashedPassword
  });

  return user;
}

/**
 * 创建测试商品
 */
export async function createTestProduct(overrides: any = {}): Promise<any> {
  const timestamp = Date.now();
  const productData = {
    name: `测试商品${timestamp}`,
    description: '这是一个测试商品',
    category: 'health',
    price: 199.00,
    originalPrice: 299.00,
    stock: 100,
    images: ['https://example.com/product.jpg'],
    specifications: {
      brand: '测试品牌',
      model: '测试型号',
      material: '测试材质'
    },
    status: 'ON_SALE',
    ...overrides
  };

  const product = await ProductRepository.create(productData);
  return product;
}

/**
 * 创建测试订单
 */
export async function createTestOrder(userId: string, overrides: any = {}): Promise<any> {
  const orderData = {
    userId: userId,
    orderNo: generateOrderNo(),
    totalAmount: 199.00,
    paymentMethod: 'ALIPAY',
    paymentStatus: 'PAID',
    orderStatus: 'PENDING_SHIPMENT',
    recipientName: '张三',
    recipientPhone: '13800138000',
    province: '北京市',
    city: '北京市',
    district: '朝阳区',
    address: '测试地址123号',
    postalCode: '100000',
    ...overrides
  };

  const order = await OrderRepository.create(orderData);
  return order;
}

/**
 * 生成订单号
 */
function generateOrderNo(): string {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
  return `ORD${timestamp}${random}`;
}

/**
 * 清理测试数据
 */
export async function cleanupTestData() {
  await UserRepository.deleteMany({
    email: { $regex: /^test.*@example\.com$/ }
  });
  await ProductRepository.deleteMany({
    name: { $regex: /^测试商品/ }
  });
  await OrderRepository.deleteMany({
    orderNo: { $regex: /^ORD/ }
  });
}

/**
 * 等待异步操作完成
 */
export async function waitFor(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * 生成随机字符串
 */
export function generateRandomString(length: number = 10): string {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}

/**
 * 生成随机手机号
 */
export function generateRandomPhone(): string {
  const prefix = '138';
  const suffix = Math.floor(Math.random() * 100000000).toString().padStart(8, '0');
  return `${prefix}${suffix}`;
}

/**
 * 生成随机邮箱
 */
export function generateRandomEmail(): string {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000);
  return `test${timestamp}${random}@example.com`;
}
```

#### 8.2 API客户端

```typescript
/**
 * @file API客户端
 * @description 封装HTTP请求，提供统一的API调用接口
 * @module tests/utils/apiClient
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export class APIClient {
  private client: AxiosInstance;

  constructor(baseURL: string) {
    this.client = axios.create({
      baseURL: baseURL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }

  /**
   * GET请求
   */
  async get(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse> {
    return this.client.get(url, config);
  }

  /**
   * POST请求
   */
  async post(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse> {
    return this.client.post(url, data, config);
  }

  /**
   * PUT请求
   */
  async put(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse> {
    return this.client.put(url, data, config);
  }

  /**
   * DELETE请求
   */
  async delete(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse> {
    return this.client.delete(url, config);
  }

  /**
   * PATCH请求
   */
  async patch(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse> {
    return this.client.patch(url, data, config);
  }

  /**
   * 设置认证令牌
   */
  setAuthToken(token: string): void {
    this.client.defaults.headers.common['Authorization'] = `Bearer ${token}`;
  }

  /**
   * 清除认证令牌
   */
  clearAuthToken(): void {
    delete this.client.defaults.headers.common['Authorization'];
  }
}
```

### 9. 测试配置

#### 9.1 Vitest配置

```typescript
/**
 * @file Vitest配置
 * @description Vitest测试框架的配置文件
 * @module vitest.config.ts
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'c8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'tests/',
        '**/*.test.ts',
        '**/*.spec.ts',
        '**/dist/',
        '**/build/',
        '**/*.config.ts',
        '**/*.d.ts'
      ],
      lines: 80,
      functions: 80,
      branches: 75,
      statements: 80
    },
    setupFiles: ['./tests/config/testSetup.ts'],
    reporters: ['verbose', 'json'],
    outputFile: './test-results/results.json'
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@tests': path.resolve(__dirname, './tests')
    }
  }
});
```

#### 9.2 测试环境设置

```typescript
/**
 * @file 测试环境设置
 * @description 测试运行前的环境配置
 * @module tests/config/testSetup.ts
 * @author YYC³
 * @version 1.0.0
 * @created 2026-01-26
 */

import { beforeAll, afterAll } from 'vitest';
import { setupTestDatabase, teardownTestDatabase } from './databaseSetup';
import { setupTestRedis, teardownTestRedis } from './redisSetup';
import { setupTestServer, teardownTestServer } from './serverSetup';

beforeAll(async () => {
  await setupTestDatabase();
  await setupTestRedis();
  await setupTestServer();
});

afterAll(async () => {
  await teardownTestServer();
  await teardownTestRedis();
  await teardownTestDatabase();
});
```

### 10. CI/CD集成

#### 10.1 GitHub Actions配置

```yaml
name: API Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Setup test environment
      run: |
        docker-compose -f docker-compose.test.yml up -d
        npm run test:setup

    - name: Run unit tests
      run: npm run test:unit

    - name: Run integration tests
      run: npm run test:integration

    - name: Run e2e tests
      run: npm run test:e2e

    - name: Run security tests
      run: npm run test:security

    - name: Generate coverage report
      run: npm run test:coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage/coverage-final.json
        flags: unittests
        name: codecov-umbrella

    - name: Run performance tests
      run: npm run test:performance

    - name: Cleanup test environment
      if: always()
      run: |
        docker-compose -f docker-compose.test.yml down -v
        npm run test:cleanup
```

#### 10.2 测试脚本配置

```json
{
  "scripts": {
    "test": "vitest",
    "test:unit": "vitest run tests/unit",
    "test:integration": "vitest run tests/integration",
    "test:e2e": "vitest run tests/e2e",
    "test:security": "vitest run tests/security",
    "test:performance": "k6 run tests/performance/loadTest.js",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest watch",
    "test:setup": "node tests/scripts/setup.js",
    "test:cleanup": "node tests/scripts/cleanup.js",
    "test:ui": "vitest --ui"
  }
}
```

### 11. 测试报告

#### 11.1 测试报告生成

测试报告应包含以下内容：

- **测试摘要**：总测试数、通过数、失败数、跳过数、执行时间
- **覆盖率报告**：代码行覆盖率、函数覆盖率、分支覆盖率、语句覆盖率
- **性能指标**：响应时间、吞吐量、错误率
- **安全测试结果**：漏洞扫描结果、安全测试通过率
- **详细测试结果**：每个测试用例的执行结果和错误信息

#### 11.2 测试报告示例

```markdown
# API自动化测试报告

## 测试摘要

| 指标 | 数值 |
|------|------|
| 总测试数 | 1,234 |
| 通过数 | 1,200 |
| 失败数 | 20 |
| 跳过数 | 14 |
| 执行时间 | 15分32秒 |
| 通过率 | 97.2% |

## 覆盖率报告

| 类型 | 覆盖率 | 目标 | 状态 |
|------|--------|------|------|
| 代码行覆盖率 | 85.3% | 80% | ✅ 通过 |
| 函数覆盖率 | 88.7% | 80% | ✅ 通过 |
| 分支覆盖率 | 78.2% | 75% | ✅ 通过 |
| 语句覆盖率 | 84.9% | 80% | ✅ 通过 |

## 性能指标

| 指标 | 数值 | 目标 | 状态 |
|------|------|------|------|
| 平均响应时间 | 156ms | <200ms | ✅ 通过 |
| P95响应时间 | 487ms | <500ms | ✅ 通过 |
| P99响应时间 | 892ms | <1000ms | ✅ 通过 |
| 吞吐量 | 1,234 req/s | >1000 req/s | ✅ 通过 |
| 错误率 | 0.12% | <1% | ✅ 通过 |

## 安全测试结果

| 测试类型 | 通过数 | 失败数 | 状态 |
|----------|--------|--------|------|
| SQL注入测试 | 15 | 0 | ✅ 通过 |
| XSS防护测试 | 12 | 0 | ✅ 通过 |
| CSRF防护测试 | 8 | 0 | ✅ 通过 |
| 认证安全测试 | 20 | 0 | ✅ 通过 |
| 输入验证测试 | 25 | 0 | ✅ 通过 |

## 失败测试用例

| 测试用例 | 错误信息 | 优先级 |
|----------|----------|--------|
| UserService.createUser - 当用户已存在时应该抛出错误 | 超时错误 | P1 |
| AIChatService.chat - 当模型不可用时应该返回错误 | 超时错误 | P2 |

## 建议

1. 修复失败的测试用例，确保所有测试通过
2. 继续保持高测试覆盖率，目标达到90%以上
3. 优化性能瓶颈，降低P99响应时间
4. 定期执行安全测试，确保系统安全性
```

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
