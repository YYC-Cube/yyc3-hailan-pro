---
@file: 080-第三方-AI服务集成接口.md
@description: HaiLan Pro 对接OpenAI/国产大模型API的接口规范与调用实现
@author: YanYuCloudCube Team
@version: v1.0.0
@created: 2026-01-26
@updated: 2026-01-26
@status: published
@tags: [HaiLan-Pro-API文档],[第三方集成],[AI服务],[LLM]
---

> ***YanYuCloudCube***
> **标语**：言启象限 | 语枢未来
> ***Words Initiate Quadrants, Language Serves as Core for the Future***
> **标语**：万象归元于云枢 | 深栈智启新纪元
> ***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***`

---

# 080 第三方-AI服务集成接口

## 概述

本文档详细描述HaiLan Pro项目中第三方AI服务的集成接口规范，包括OpenAI、国产大模型等AI服务的对话、推荐、问答、图像生成等功能的设计与实现，确保项目按照YYC³标准规范进行开发和实施。

## 核心内容

### 1. 背景与目标

#### 1.1 项目背景
HaiLan Pro (海蓝) 是新一代高端、私密、智能的情趣健康生活管理平台。项目基于「五高五标五化」理念，通过 PWA 技术结合 AI 智能辅助与物联网，为用户提供从生理健康到心理愉悦的全方位解决方案。

#### 1.2 项目愿景
打造极致隐私、智能陪伴、品质合规、全场景覆盖的情趣健康生活管理平台，为用户提供安全、专业、高端的健康生活体验。

#### 1.3 核心价值主张
- **极致隐私**：双重加密、隐私浏览模式及伪装发货机制
- **智能陪伴**：基于 LLM 的 AI 情感与生理健康顾问
- **品质合规**：医疗级标准商品，高端"海蓝蓝"视觉调性
- **全场景覆盖**：PWA 端支持离线浏览、桌面安装及无缝推送

#### 1.4 文档目标
- 规范第三方AI服务集成接口相关的业务标准与技术落地要求
- 为项目相关人员提供清晰的参考依据
- 保障相关模块开发、实施、运维的一致性与规范性

### 2. 设计原则

#### 2.1 五高原则
- **高可用性**：确保AI服务7x24小时稳定运行，支持多厂商容灾切换
- **高性能**：优化响应时间和处理能力，支持高并发访问
- **高安全性**：保护用户数据和隐私安全，双重加密机制
- **高扩展性**：支持多模型接入，灵活切换AI服务提供商
- **高可维护性**：便于后续维护和升级，模块化设计

#### 2.2 五标体系
- **标准化**：统一的接口和消息格式标准
- **规范化**：严格的AI使用和审核规范
- **自动化**：提高AI服务效率和质量，自动重试机制
- **智能化**：利用智能路由优化AI响应质量
- **可视化**：直观的AI调用监控和统计界面

#### 2.3 五化架构
- **流程化**：标准化的AI服务调用流程
- **文档化**：完善的提示词和配置文档
- **工具化**：高效的提示词管理和测试工具
- **数字化**：数据驱动的AI优化
- **生态化**：开放的第三方AI服务集成

### 3. 服务架构

#### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        应用层                                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ 用户服务  │  │ 内容服务  │  │ 推荐服务  │  │ 咨询服务  │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      AI服务层                               │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              AI服务 (AIService)                     │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│  │  │ 对话服务  │  │ 推荐服务  │  │ 问答服务  │          │  │
│  │  └──────────┘  └──────────┘  └──────────┘          │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│  │  │ 图像生成  │  │ 语音识别  │  │ 语音合成  │          │  │
│  │  └──────────┘  └──────────┘  └──────────┘          │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │  │
│  │  │ 提示词管理 │  │ 模型管理  │  │ 限流服务  │          │  │
│  │  └──────────┘  └──────────┘  └──────────┘          │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      第三方AI服务层                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ OpenAI   │  │ Claude   │  │ 文心一言 │  │ 通义千问 │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ 智谱GLM  │  │ 百川大模型 │  │ Midjourney│  │ StableDiff│  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      数据存储层                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ 对话记录  │  │ 提示词库  │  │ 模型配置  │  │ 调用统计  │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
```

#### 3.2 服务组件

##### 3.2.1 对话服务 (ChatService)
- AI对话交互
- 多轮对话管理
- 上下文理解
- 对话历史记录
- 对话质量评估

##### 3.2.2 推荐服务 (RecommendationService)
- 商品推荐
- 内容推荐
- 个性化推荐
- 协同过滤
- 深度学习推荐

##### 3.2.3 问答服务 (QAService)
- 知识问答
- FAQ自动回答
- 智能检索
- 答案生成
- 答案质量评估

##### 3.2.4 图像生成服务 (ImageGenerationService)
- 文本生成图像
- 图像编辑
- 图像风格转换
- 图像增强
- 图像优化

##### 3.2.5 语音识别服务 (SpeechRecognitionService)
- 语音转文字
- 实时语音识别
- 多语言识别
- 语音纠错
- 语音质量评估

##### 3.2.6 语音合成服务 (SpeechSynthesisService)
- 文字转语音
- 多音色合成
- 情感语音合成
- 语音风格控制
- 语音质量优化

##### 3.2.7 提示词管理 (PromptManagementService)
- 提示词模板管理
- 提示词版本控制
- 提示词优化
- 提示词测试
- 提示词效果评估

##### 3.2.8 模型管理 (ModelManagementService)
- 模型配置管理
- 模型切换
- 模型性能监控
- 模型版本管理
- 模型A/B测试

##### 3.2.9 限流服务 (AIRateLimitService)
- 用户调用限流
- IP调用限流
- 模型调用限流
- 限流策略配置
- 限流统计

### 4. AI对话接口

#### 4.1 创建对话

##### 4.1.1 接口描述
创建新的AI对话会话。

##### 4.1.2 接口定义

```typescript
/**
 * 创建对话请求
 */
interface CreateChatRequest {
  model: string;
  messages: ChatMessage[];
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  stream?: boolean;
  userId?: string;
  sessionId?: string;
}

/**
 * 聊天消息
 */
interface ChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
  timestamp?: Date;
}

/**
 * 创建对话响应
 */
interface CreateChatResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    chatId: string;
    message: ChatMessage;
    usage: {
      promptTokens: number;
      completionTokens: number;
      totalTokens: number;
    };
    model: string;
    finishReason: string;
  };
}
```

##### 4.1.3 接口实现

```typescript
/**
 * AI对话服务
 */
class ChatService {
  private readonly DEFAULT_TEMPERATURE = 0.7;
  private readonly DEFAULT_MAX_TOKENS = 2000;
  private readonly MAX_HISTORY_LENGTH = 10;
  
  constructor(
    private aiProvider: AIProvider,
    private cacheService: CacheService,
    private rateLimitService: AIRateLimitService,
    private promptService: PromptManagementService
  ) {}
  
  /**
   * 创建对话
   */
  async createChat(request: CreateChatRequest): Promise<CreateChatResponse> {
    // 检查限流
    const limitCheck = await this.rateLimitService.checkUserLimit(request.userId);
    if (!limitCheck) {
      return {
        success: false,
        code: 'RATE_LIMIT_EXCEEDED',
        message: '调用次数已达上限'
      };
    }
    
    // 获取系统提示词
    const systemPrompt = await this.getSystemPrompt(request.model);
    
    // 构建消息列表
    const messages = this.buildMessages(request.messages, systemPrompt);
    
    // 调用AI服务
    const result = await this.aiProvider.chat({
      model: request.model,
      messages: messages,
      temperature: request.temperature || this.DEFAULT_TEMPERATURE,
      maxTokens: request.maxTokens || this.DEFAULT_MAX_TOKENS,
      topP: request.topP,
      frequencyPenalty: request.frequencyPenalty,
      presencePenalty: request.presencePenalty,
      stream: request.stream || false
    });
    
    if (result.success) {
      // 保存对话记录
      await this.saveChatRecord({
        chatId: generateChatId(),
        userId: request.userId,
        sessionId: request.sessionId,
        messages: [...request.messages, result.message],
        model: request.model,
        usage: result.usage,
        createdAt: new Date()
      });
      
      return {
        success: true,
        code: 'SUCCESS',
        message: '对话创建成功',
        data: {
          chatId: generateChatId(),
          message: result.message,
          usage: result.usage,
          model: request.model,
          finishReason: result.finishReason
        }
      };
    } else {
      return {
        success: false,
        code: result.errorCode,
        message: result.errorMessage || '对话创建失败'
      };
    }
  }
  
  /**
   * 构建消息列表
   */
  private buildMessages(messages: ChatMessage[], systemPrompt?: string): ChatMessage[] {
    const result: ChatMessage[] = [];
    
    if (systemPrompt) {
      result.push({
        role: 'system',
        content: systemPrompt
      });
    }
    
    // 限制历史消息长度
    const limitedMessages = messages.slice(-this.MAX_HISTORY_LENGTH);
    result.push(...limitedMessages);
    
    return result;
  }
  
  /**
   * 获取系统提示词
   */
  private async getSystemPrompt(model: string): Promise<string> {
    const prompt = await this.promptService.getSystemPrompt(model);
    return prompt?.content || '';
  }
}
```

#### 4.2 流式对话

##### 4.2.1 接口描述
创建流式AI对话，实时返回生成内容。

##### 4.2.2 接口定义

```typescript
/**
 * 流式对话请求
 */
interface StreamChatRequest {
  model: string;
  messages: ChatMessage[];
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  userId?: string;
  sessionId?: string;
}

/**
 * 流式对话响应
 */
interface StreamChatResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    chatId: string;
    stream: AsyncIterable<StreamChunk>;
  };
}

/**
 * 流式数据块
 */
interface StreamChunk {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: StreamChoice[];
}

interface StreamChoice {
  index: number;
  delta: {
    role?: string;
    content?: string;
  };
  finishReason: string | null;
}
```

##### 4.2.3 接口实现

```typescript
/**
 * 流式对话
 */
async streamChat(request: StreamChatRequest): Promise<StreamChatResponse> {
  const chatId = generateChatId();
  
  try {
    const stream = await this.aiProvider.streamChat({
      model: request.model,
      messages: request.messages,
      temperature: request.temperature || this.DEFAULT_TEMPERATURE,
      maxTokens: request.maxTokens || this.DEFAULT_MAX_TOKENS,
      topP: request.topP
    });
    
    return {
      success: true,
      code: 'SUCCESS',
      message: '流式对话创建成功',
      data: {
        chatId: chatId,
        stream: stream
      }
    };
  } catch (error) {
    return {
      success: false,
      code: 'STREAM_FAILED',
      message: '流式对话创建失败'
    };
  }
}
```

### 5. AI推荐接口

#### 5.1 商品推荐

##### 5.1.1 接口描述
基于用户行为和偏好推荐商品。

##### 5.1.2 接口定义

```typescript
/**
 * 商品推荐请求
 */
interface ProductRecommendationRequest {
  userId: string;
  category?: string;
  limit?: number;
  excludeIds?: string[];
  context?: RecommendationContext;
}

/**
 * 推荐上下文
 */
interface RecommendationContext {
  sessionId?: string;
  recentViews?: string[];
  recentPurchases?: string[];
  userTags?: string[];
  timeOfDay?: string;
  deviceType?: string;
}

/**
 * 商品推荐响应
 */
interface ProductRecommendationResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    products: RecommendedProduct[];
    algorithm: string;
    confidence: number;
  };
}

/**
 * 推荐商品
 */
interface RecommendedProduct {
  productId: string;
  name: string;
  price: number;
  imageUrl: string;
  score: number;
  reason: string;
}
```

##### 5.1.3 接口实现

```typescript
/**
 * 推荐服务
 */
class RecommendationService {
  constructor(
    private aiProvider: AIProvider,
    private userService: UserService,
    private productService: ProductService,
    private cacheService: CacheService
  ) {}
  
  /**
   * 商品推荐
   */
  async recommendProducts(request: ProductRecommendationRequest): Promise<ProductRecommendationResponse> {
    const limit = request.limit || 10;
    
    try {
      // 获取用户画像
      const userProfile = await this.getUserProfile(request.userId);
      
      // 构建推荐请求
      const recommendRequest = {
        userId: request.userId,
        userProfile: userProfile,
        category: request.category,
        excludeIds: request.excludeIds || [],
        context: request.context,
        limit: limit
      };
      
      // 调用AI推荐
      const result = await this.aiProvider.recommendProducts(recommendRequest);
      
      if (result.success && result.products.length > 0) {
        // 获取商品详情
        const productIds = result.products.map(p => p.productId);
        const products = await this.productService.getProductsByIds(productIds);
        
        // 合并推荐分数和原因
        const recommendedProducts = result.products.map(rec => {
          const product = products.find(p => p.id === rec.productId);
          return {
            ...product,
            score: rec.score,
            reason: rec.reason
          };
        });
        
        return {
          success: true,
          code: 'SUCCESS',
          message: '推荐成功',
          data: {
            products: recommendedProducts,
            algorithm: result.algorithm,
            confidence: result.confidence
          }
        };
      } else {
        // 如果AI推荐失败，使用默认推荐
        const defaultProducts = await this.getDefaultRecommendations(request);
        
        return {
          success: true,
          code: 'SUCCESS',
          message: '推荐成功',
          data: {
            products: defaultProducts,
            algorithm: 'DEFAULT',
            confidence: 0.5
          }
        };
      }
    } catch (error) {
      return {
        success: false,
        code: 'RECOMMENDATION_FAILED',
        message: '推荐失败'
      };
    }
  }
  
  /**
   * 获取用户画像
   */
  private async getUserProfile(userId: string): Promise<UserProfile> {
    const cacheKey = `user:profile:${userId}`;
    let profile = await this.cacheService.get(cacheKey);
    
    if (!profile) {
      profile = await this.userService.getUserProfile(userId);
      await this.cacheService.set(cacheKey, profile, 3600);
    }
    
    return profile;
  }
  
  /**
   * 获取默认推荐
   */
  private async getDefaultRecommendations(request: ProductRecommendationRequest): Promise<RecommendedProduct[]> {
    const products = await this.productService.getPopularProducts({
      category: request.category,
      limit: request.limit || 10,
      excludeIds: request.excludeIds
    });
    
    return products.map(p => ({
      ...p,
      score: 0.5,
      reason: '热门推荐'
    }));
  }
}
```

### 6. AI问答接口

#### 6.1 知识问答

##### 6.1.1 接口描述
基于知识库回答用户问题。

##### 6.1.2 接口定义

```typescript
/**
 * 知识问答请求
 */
interface KnowledgeQARequest {
  question: string;
  context?: string;
  userId?: string;
  sessionId?: string;
  topK?: number;
}

/**
 * 知识问答响应
 */
interface KnowledgeQAResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    answer: string;
    sources: QASource[];
    confidence: number;
    relatedQuestions: string[];
  };
}

/**
 * 问答来源
 */
interface QASource {
  id: string;
  title: string;
  url: string;
  snippet: string;
  relevance: number;
}
```

##### 6.1.3 接口实现

```typescript
/**
 * 问答服务
 */
class QAService {
  constructor(
    private aiProvider: AIProvider,
    private knowledgeBase: KnowledgeBase,
    private cacheService: CacheService
  ) {}
  
  /**
   * 知识问答
   */
  async answerQuestion(request: KnowledgeQARequest): Promise<KnowledgeQAResponse> {
    const topK = request.topK || 5;
    
    try {
      // 检查缓存
      const cacheKey = `qa:${this.hashQuestion(request.question)}`;
      const cachedAnswer = await this.cacheService.get(cacheKey);
      
      if (cachedAnswer) {
        return {
          success: true,
          code: 'SUCCESS',
          message: '问答成功',
          data: cachedAnswer
        };
      }
      
      // 检索相关知识
      const searchResults = await this.knowledgeBase.search({
        query: request.question,
        topK: topK,
        context: request.context
      });
      
      if (searchResults.length === 0) {
        return {
          success: false,
          code: 'NO_RELEVANT_CONTENT',
          message: '未找到相关内容'
        };
      }
      
      // 构建上下文
      const context = this.buildContext(searchResults);
      
      // 调用AI生成答案
      const result = await this.aiProvider.answerQuestion({
        question: request.question,
        context: context,
        sources: searchResults
      });
      
      if (result.success) {
        const answerData = {
          answer: result.answer,
          sources: searchResults,
          confidence: result.confidence,
          relatedQuestions: result.relatedQuestions || []
        };
        
        // 缓存答案
        await this.cacheService.set(cacheKey, answerData, 3600);
        
        return {
          success: true,
          code: 'SUCCESS',
          message: '问答成功',
          data: answerData
        };
      } else {
        return {
          success: false,
          code: result.errorCode,
          message: result.errorMessage || '问答失败'
        };
      }
    } catch (error) {
      return {
        success: false,
        code: 'QA_FAILED',
        message: '问答失败'
      };
    }
  }
  
  /**
   * 构建上下文
   */
  private buildContext(sources: QASource[]): string {
    return sources.map((source, index) => {
      return `[${index + 1}] ${source.title}\n${source.snippet}`;
    }).join('\n\n');
  }
  
  /**
   * 问题哈希
   */
  private hashQuestion(question: string): string {
    return crypto.createHash('md5').update(question).digest('hex');
  }
}
```

### 7. AI图像生成接口

#### 7.1 文本生成图像

##### 7.1.1 接口描述
根据文本描述生成图像。

##### 7.1.2 接口定义

```typescript
/**
 * 文本生成图像请求
 */
interface TextToImageRequest {
  prompt: string;
  negativePrompt?: string;
  size?: string;
  style?: string;
  quality?: string;
  numberOfImages?: number;
  userId?: string;
}

/**
 * 文本生成图像响应
 */
interface TextToImageResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    images: GeneratedImage[];
    model: string;
    parameters: ImageGenerationParameters;
  };
}

/**
 * 生成的图像
 */
interface GeneratedImage {
  imageId: string;
  url: string;
  thumbnailUrl: string;
  width: number;
  height: number;
  seed: number;
}

/**
 * 图像生成参数
 */
interface ImageGenerationParameters {
  prompt: string;
  negativePrompt: string;
  size: string;
  style: string;
  quality: string;
  numberOfImages: number;
}
```

##### 7.1.3 接口实现

```typescript
/**
 * 图像生成服务
 */
class ImageGenerationService {
  private readonly DEFAULT_SIZE = '1024x1024';
  private readonly DEFAULT_STYLE = 'realistic';
  private readonly DEFAULT_QUALITY = 'standard';
  private readonly MAX_IMAGES = 4;
  
  constructor(
    private aiProvider: AIProvider,
    private storageService: StorageService,
    private contentFilter: ContentFilterService,
    private rateLimitService: AIRateLimitService
  ) {}
  
  /**
   * 文本生成图像
   */
  async generateImage(request: TextToImageRequest): Promise<TextToImageResponse> {
    // 检查限流
    const limitCheck = await this.rateLimitService.checkUserImageLimit(request.userId);
    if (!limitCheck) {
      return {
        success: false,
        code: 'RATE_LIMIT_EXCEEDED',
        message: '生成次数已达上限'
      };
    }
    
    // 内容过滤
    const filterResult = this.contentFilter.filter(request.prompt);
    if (filterResult.hasSensitiveWords) {
      return {
        success: false,
        code: 'CONTENT_FILTERED',
        message: '提示词包含敏感内容'
      };
    }
    
    // 限制生成数量
    const numberOfImages = Math.min(request.numberOfImages || 1, this.MAX_IMAGES);
    
    try {
      const result = await this.aiProvider.generateImage({
        prompt: filterResult.filteredContent,
        negativePrompt: request.negativePrompt || '',
        size: request.size || this.DEFAULT_SIZE,
        style: request.style || this.DEFAULT_STYLE,
        quality: request.quality || this.DEFAULT_QUALITY,
        numberOfImages: numberOfImages
      });
      
      if (result.success && result.images.length > 0) {
        // 上传图像到存储
        const uploadedImages = await Promise.all(
          result.images.map(async (image) => {
            const uploaded = await this.storageService.uploadImage({
              data: image.data,
              fileName: `${generateImageId()}.png`
            });
            
            return {
              imageId: uploaded.fileId,
              url: uploaded.url,
              thumbnailUrl: uploaded.thumbnailUrl,
              width: image.width,
              height: image.height,
              seed: image.seed
            };
          })
        );
        
        // 保存生成记录
        await this.saveGenerationRecord({
          userId: request.userId,
          prompt: request.prompt,
          negativePrompt: request.negativePrompt,
          images: uploadedImages,
          model: result.model,
          parameters: {
            prompt: request.prompt,
            negativePrompt: request.negativePrompt || '',
            size: request.size || this.DEFAULT_SIZE,
            style: request.style || this.DEFAULT_STYLE,
            quality: request.quality || this.DEFAULT_QUALITY,
            numberOfImages: numberOfImages
          },
          createdAt: new Date()
        });
        
        return {
          success: true,
          code: 'SUCCESS',
          message: '图像生成成功',
          data: {
            images: uploadedImages,
            model: result.model,
            parameters: {
              prompt: request.prompt,
              negativePrompt: request.negativePrompt || '',
              size: request.size || this.DEFAULT_SIZE,
              style: request.style || this.DEFAULT_STYLE,
              quality: request.quality || this.DEFAULT_QUALITY,
              numberOfImages: numberOfImages
            }
          }
        };
      } else {
        return {
          success: false,
          code: result.errorCode,
          message: result.errorMessage || '图像生成失败'
        };
      }
    } catch (error) {
      return {
        success: false,
        code: 'GENERATION_FAILED',
        message: '图像生成失败'
      };
    }
  }
}
```

### 8. 提示词管理接口

#### 8.1 创建提示词模板

##### 8.1.1 接口描述
创建新的提示词模板。

##### 8.1.2 接口定义

```typescript
/**
 * 创建提示词模板请求
 */
interface CreatePromptTemplateRequest {
  name: string;
  type: 'SYSTEM' | 'USER' | 'ASSISTANT';
  model: string;
  content: string;
  variables?: PromptVariable[];
  description?: string;
  tags?: string[];
}

/**
 * 提示词变量
 */
interface PromptVariable {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'array';
  description?: string;
  defaultValue?: any;
  required?: boolean;
}

/**
 * 创建提示词模板响应
 */
interface CreatePromptTemplateResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    templateId: string;
    version: number;
    status: 'ACTIVE' | 'DRAFT' | 'ARCHIVED';
  };
}
```

##### 8.1.3 接口实现

```typescript
/**
 * 提示词管理服务
 */
class PromptManagementService {
  constructor(
    private promptRepository: PromptRepository,
    private versionService: VersionService
  ) {}
  
  /**
   * 创建提示词模板
   */
  async createTemplate(request: CreatePromptTemplateRequest): Promise<CreatePromptTemplateResponse> {
    // 验证提示词内容
    const validation = this.validatePromptContent(request.content);
    if (!validation.valid) {
      return {
        success: false,
        code: 'INVALID_PROMPT',
        message: validation.message
      };
    }
    
    // 提取变量
    const variables = this.extractVariables(request.content);
    
    // 保存模板
    const template = await this.promptRepository.create({
      id: generateTemplateId(),
      name: request.name,
      type: request.type,
      model: request.model,
      content: request.content,
      variables: variables,
      description: request.description,
      tags: request.tags || [],
      version: 1,
      status: 'ACTIVE',
      createdAt: new Date(),
      createdBy: getCurrentUserId()
    });
    
    return {
      success: true,
      code: 'SUCCESS',
      message: '提示词模板创建成功',
      data: {
        templateId: template.id,
        version: template.version,
        status: template.status
      }
    };
  }
  
  /**
   * 验证提示词内容
   */
  private validatePromptContent(content: string): ValidationResult {
    if (!content || content.trim().length === 0) {
      return {
        valid: false,
        message: '提示词内容不能为空'
      };
    }
    
    if (content.length > 10000) {
      return {
        valid: false,
        message: '提示词内容过长'
      };
    }
    
    return {
      valid: true,
      message: ''
    };
  }
  
  /**
   * 提取变量
   */
  private extractVariables(content: string): PromptVariable[] {
    const variableRegex = /\{\{(\w+)\}\}/g;
    const variables: PromptVariable[] = [];
    const found = new Set<string>();
    
    let match;
    while ((match = variableRegex.exec(content)) !== null) {
      const name = match[1];
      if (!found.has(name)) {
        found.add(name);
        variables.push({
          name: name,
          type: 'string',
          required: true
        });
      }
    }
    
    return variables;
  }
}
```

### 9. 模型管理接口

#### 9.1 切换模型

##### 9.1.1 接口描述
切换AI模型。

##### 9.1.2 接口定义

```typescript
/**
 * 切换模型请求
 */
interface SwitchModelRequest {
  currentModel: string;
  newModel: string;
  scope: 'GLOBAL' | 'USER' | 'SESSION';
  userId?: string;
  sessionId?: string;
}

/**
 * 切换模型响应
 */
interface SwitchModelResponse {
  success: boolean;
  code: string;
  message: string;
  data?: {
    previousModel: string;
    currentModel: string;
    switchedAt: Date;
  };
}
```

##### 9.1.3 接口实现

```typescript
/**
 * 模型管理服务
 */
class ModelManagementService {
  constructor(
    private modelRepository: ModelRepository,
    private cacheService: CacheService
  ) {}
  
  /**
   * 切换模型
   */
  async switchModel(request: SwitchModelRequest): Promise<SwitchModelResponse> {
    // 验证新模型是否可用
    const newModel = await this.modelRepository.getModel(request.newModel);
    if (!newModel || newModel.status !== 'ACTIVE') {
      return {
        success: false,
        code: 'MODEL_NOT_AVAILABLE',
        message: '模型不可用'
      };
    }
    
    // 根据范围切换模型
    switch (request.scope) {
      case 'GLOBAL':
        await this.switchGlobalModel(request.newModel);
        break;
      case 'USER':
        await this.switchUserModel(request.userId, request.newModel);
        break;
      case 'SESSION':
        await this.switchSessionModel(request.sessionId, request.newModel);
        break;
    }
    
    return {
      success: true,
      code: 'SUCCESS',
      message: '模型切换成功',
      data: {
        previousModel: request.currentModel,
        currentModel: request.newModel,
        switchedAt: new Date()
      }
    };
  }
  
  /**
   * 切换全局模型
   */
  private async switchGlobalModel(model: string): Promise<void> {
    await this.cacheService.set('model:global', model);
  }
  
  /**
   * 切换用户模型
   */
  private async switchUserModel(userId: string, model: string): Promise<void> {
    await this.cacheService.set(`model:user:${userId}`, model, 86400);
  }
  
  /**
   * 切换会话模型
   */
  private async switchSessionModel(sessionId: string, model: string): Promise<void> {
    await this.cacheService.set(`model:session:${sessionId}`, model, 3600);
  }
}
```

### 10. 安全机制

#### 10.1 内容过滤

##### 10.1.1 接口实现

```typescript
/**
 * 内容过滤服务
 */
class AIContentFilterService {
  private sensitiveWords: string[] = [];
  private prohibitedPatterns: RegExp[] = [];
  
  constructor(private wordRepository: WordRepository) {
    this.loadSensitiveContent();
  }
  
  /**
   * 加载敏感内容
   */
  private async loadSensitiveContent() {
    this.sensitiveWords = await this.wordRepository.getSensitiveWords();
    this.prohibitedPatterns = await this.wordRepository.getProhibitedPatterns();
  }
  
  /**
   * 过滤内容
   */
  filter(content: string): FilterResult {
    let filteredContent = content;
    const foundWords: string[] = [];
    const foundPatterns: string[] = [];
    
    // 检查敏感词
    for (const word of this.sensitiveWords) {
      const regex = new RegExp(word, 'gi');
      if (regex.test(content)) {
        foundWords.push(word);
        filteredContent = filteredContent.replace(regex, '***');
      }
    }
    
    // 检查禁止模式
    for (const pattern of this.prohibitedPatterns) {
      if (pattern.test(content)) {
        foundPatterns.push(pattern.source);
      }
    }
    
    return {
      originalContent: content,
      filteredContent: filteredContent,
      hasSensitiveWords: foundWords.length > 0 || foundPatterns.length > 0,
      sensitiveWords: foundWords,
      prohibitedPatterns: foundPatterns
    };
  }
  
  /**
   * 检查是否允许
   */
  isAllowed(content: string): boolean {
    const result = this.filter(content);
    return !result.hasSensitiveWords;
  }
}
```

### 11. 性能优化

#### 11.1 缓存策略

##### 11.1.1 接口实现

```typescript
/**
 * AI缓存服务
 */
class AICacheService {
  private cache: Map<string, CacheEntry> = new Map();
  private readonly DEFAULT_TTL = 3600; // 1小时
  
  /**
   * 获取缓存
   */
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return null;
    }
    
    if (entry.expiresAt < Date.now()) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.value as T;
  }
  
  /**
   * 设置缓存
   */
  set<T>(key: string, value: T, ttl?: number): void {
    const expiresAt = Date.now() + (ttl || this.DEFAULT_TTL) * 1000;
    
    this.cache.set(key, {
      value: value,
      expiresAt: expiresAt,
      createdAt: Date.now()
    });
  }
  
  /**
   * 删除缓存
   */
  delete(key: string): void {
    this.cache.delete(key);
  }
  
  /**
   * 清空缓存
   */
  clear(): void {
    this.cache.clear();
  }
  
  /**
   * 清理过期缓存
   */
  cleanup(): void {
    const now = Date.now();
    
    for (const [key, entry] of this.cache.entries()) {
      if (entry.expiresAt < now) {
        this.cache.delete(key);
      }
    }
  }
}

interface CacheEntry {
  value: any;
  expiresAt: number;
  createdAt: number;
}
```

### 12. 最佳实践

#### 12.1 提示词优化

- 使用清晰、具体的描述
- 提供示例和上下文
- 使用结构化的提示词
- 迭代优化提示词
- A/B测试不同提示词

#### 12.2 性能优化

- 使用缓存减少重复调用
- 实现请求批处理
- 使用流式响应提升用户体验
- 优化模型选择策略
- 实现智能路由

#### 12.3 安全建议

- 实现内容过滤机制
- 限制API调用频率
- 保护用户隐私数据
- 记录详细的调用日志
- 实现异常检测

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in cloud pivot; Deep stacks ignite a new era of intelligence***」
